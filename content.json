{"meta":{"title":"Python,C/C++ Club","subtitle":"重庆大学在线公开课程","description":"分享有关Python, C/C++程序设计课程的技术文章","author":"Alex CHEN","url":"http://codelearn.club","root":"/"},"pages":[{"title":"关于我们","date":"2020-03-03T03:43:07.872Z","updated":"2020-03-03T03:43:07.872Z","comments":true,"path":"about/index.html","permalink":"http://codelearn.club/about/index.html","excerpt":"","text":"本网站出于公益及非商业目的构建。 如果侵权行为，均非故意，请联络删除。 海洋饼干叔叔@重庆大学 CSDN博客： https://blog.csdn.net/SeaBiscuitUncle 知乎专栏： https://zhuanlan.zhihu.com/codelearn B站： https://space.bilibili.com/384177380"},{"title":"下载","date":"2020-10-06T12:57:48.258Z","updated":"2020-10-06T12:57:48.258Z","comments":true,"path":"download/index.html","permalink":"http://codelearn.club/download/index.html","excerpt":"","text":"《Python编程基础及应用》随书源代码： pylearn.zip下载方法 https://codelearn.club/2020/05/getpycode/ 海洋饼干叔叔@重庆大学 CSDN博客： https://blog.csdn.net/SeaBiscuitUncle 知乎专栏： https://zhuanlan.zhihu.com/codelearn B站： https://space.bilibili.com/384177380"},{"title":"纸质图书","date":"2020-10-06T12:48:16.960Z","updated":"2020-10-06T12:48:16.960Z","comments":true,"path":"book/index.html","permalink":"http://codelearn.club/book/index.html","excerpt":"","text":"《Python编程基础及应用》 ，高等教育出版社 淘宝购书链接 京东购书链接 当当购书链接 海洋饼干叔叔@重庆大学 CSDN博客： https://blog.csdn.net/SeaBiscuitUncle 知乎专栏： https://zhuanlan.zhihu.com/codelearn B站： https://space.bilibili.com/384177380"},{"title":"在线MOOC","date":"2020-03-03T03:49:53.558Z","updated":"2020-03-03T03:49:53.558Z","comments":true,"path":"mooc/index.html","permalink":"http://codelearn.club/mooc/index.html","excerpt":"","text":"Python编程及应用 @BILIBILI https://www.bilibili.com/video/av34409478/ 从C到C++ @BILIBILI https://www.bilibili.com/video/av34586138/ 海洋饼干叔叔@重庆大学 CSDN博客： https://blog.csdn.net/SeaBiscuitUncle 知乎专栏： https://zhuanlan.zhihu.com/codelearn B站： https://space.bilibili.com/384177380"},{"title":"致谢","date":"2020-03-03T03:56:46.971Z","updated":"2020-03-03T03:56:46.971Z","comments":true,"path":"thanks/index.html","permalink":"http://codelearn.club/thanks/index.html","excerpt":"","text":"致谢 http://hexo.io 创造了这么伟大的博客网站框架。 致谢 https://volantis.js.org/ 构建了volantis的hexo主题。 受益于无私的开源程序员们的贡献，本网站的作者仅花了几个小时就完成了网站的搭建。 海洋饼干叔叔@重庆大学 CSDN博客： https://blog.csdn.net/SeaBiscuitUncle 知乎专栏： https://zhuanlan.zhihu.com/codelearn B站： https://space.bilibili.com/384177380"}],"posts":[{"title":"简洁的C及C++","slug":"C-CppBook","date":"2020-09-13T04:35:04.000Z","updated":"2020-09-17T14:21:50.444Z","comments":true,"path":"2020/09/C-CppBook/","link":"","permalink":"http://codelearn.club/2020/09/C-CppBook/","excerpt":"新冠病毒肆虐，困在宜昌，不知道做什么好，那就开始写书吧。 ――― 2020年1月31日星期五 本讲义系重庆大学C/C++课程的教学笔记。 作者： 海洋饼干叔叔/陈波 chenbo@cqu.edu.cn， All rights reserved. 未经作者许可，不允许经由互联网展示或提供下载。 本文不允许转载。 不允许以纸质出版为目的进行摘抄或改编。 配套B站在线MOOC, 重庆大学2020秋随堂录制，每周更新两次。 https://www.bilibili.com/video/BV1it411d7zx/","text":"新冠病毒肆虐，困在宜昌，不知道做什么好，那就开始写书吧。 ――― 2020年1月31日星期五 本讲义系重庆大学C/C++课程的教学笔记。 作者： 海洋饼干叔叔/陈波 chenbo@cqu.edu.cn， All rights reserved. 未经作者许可，不允许经由互联网展示或提供下载。 本文不允许转载。 不允许以纸质出版为目的进行摘抄或改编。 配套B站在线MOOC, 重庆大学2020秋随堂录制，每周更新两次。 https://www.bilibili.com/video/BV1it411d7zx/ [TOC] 1. 学习准备​ 我觉得每个人都应该学习一门编程语言。学习编程教你如何思考，就像学习法律一样。学习法律并不一定是为了成为律师，而是教你一种思考方式。学习编程也是一样，我把计算机科学看作基础教育，每个人都应该花至少一年的时间学习编程。 ​ ———— Steve Jobs ​ ​ 科学技术正以令人吃惊的加速度前进，任何踌躇不前者都将被时代所抛弃。在埋头做了20年程序员、电气工程师和大学讲师之后，作者惊讶地发现：​ 编程正在成为一项基本的人生技能！ ​ 20年前，作者还热衷于跟小伙伴在火车上用英语对女孩子的长相品头论足。彼时，英语的普及程度还不太高，虽然中学开了英语课，但大部分人还不能够流利地听说读写。所以，这种不礼貌的用英文品头论足的行为风险还不太高。但在20年后的今天，作者已经不敢做这样的事了，凡是年轻人，鲜有不懂、不会英语者。 ​ 作者深信，与英语一样，编程正在成为一项基本技能！ 一二十年后，完全不会编程的年轻人将会是稀有品种！ 这不是耸人听闻，作者8岁的女儿正在上小学，小学三年级已经开始编程教育了。 ​ 历史学家借助程序设计，能更好地研究历史上的气温变化和雪线南移对历史进程的影响，这种对历史进行量化研究的学科现已成为显学，我们称之为“计量历史学” 。经济学家借助程序设计，可对宏观经济数据进行分析和预测，通过发电量、网络支付的活跃状况等大数据来评估经济的热度和走向。工业自动化工程师借助程序设计，可更快更好地识别传送带上的零件的位置和方向，规划机器人的工作节拍和顺序。艺术工作者借助编程工具，可更快更好地批量“生成”平面乃至立体艺术作品。靠码字为生的文化人借助编程工具设计一个信息爬虫程序，将网络上与指定话题相关的全部信息下载并自动归类整理，撰写文章的效率将大大提高，文章的支持证据将充分而又翔实。建筑设计师借助程序设计在将来成功保住了饭碗，因为自动化的建筑设计工具软件将在不远的将来替换大多数的绘图工人。会计师、银行家、记者、教师更需要学习编程，因为人工智能正跃跃欲试，试图在工作环境中替代这些从业者。 ​ 即便读者将来就是一个平凡的普通人，那么本书带给你的编程体验可以帮助你更好地理解人工智能和信息安全，以及网络商店里的商品推荐、甚至机票订购网站的价格策略，让你更加从容地面对未来世界。 ​ 无论是早起吃虫的鸟儿，还是跃跃欲试希望有一番作为的年轻人或者正在探索人类知识边界的科学家，甚至在家带孩子的全职太太，都应该了解和学习编程。 1.1 C及C++简史​ 1972年，Dennis M. Ritchie（1941-2011）在贝尔实验室以B语言为基础设计了一种新的语言，他取了BCPL语言的第二个字母作为这种语言的名字，即C语言。 ​ 1973年初，C语言的主体完成。Ken Thompson和Dennis M. Ritchie用C语言重写了UNIX操作系统。Linux以及苹果的Mac OS，均脱胎于UNIX。当代手机上运行的Android系统，则运行在Linux操作系统内核之上。 ​ 1979年，Bjame Sgoustrup到贝尔实验室从事将C语言改良为带类的C（C with classes）的工作。改进后的语言在1983年被正式命名为C++。 ​ 粗略地，可以认为C语言是C++语言的子集，即C++ ≈ C + 类语法。在过去的数十年中，C/C++语言演化了多个标准版本，如表1-1所示。 ​ 表1-1 C及C++语言标准版本演化 版本 年份 标准号 版本 年份 标准号 C89/ANSI C 1989 ANSI X3.159-1989 C++ 98 1998 ISO/IEC 14882:1998 C90 1990 ISO/IEC 9899: 1990 C++ 03 2003 ISO/IEC 14882:2003 C99 1999 ISO/IEC 9899: 1999 C++ 11 2011 ISO/IEC 14882:2011 C11 2011 ISO/IEC 9899:2011 C++ 14 2014 ISO/IEC 14882:2014 C18 2018 ISO/IEC 9899:2018 C++ 17 2017 ISO/IEC 14882:2017 ​ 2020年8月新发布的TOIBE的编程语言排行榜中，C语言以16.98%的市场占有率力挫Java重回第1名，C++语言则以6.84%的市场占有率排名第4。要知道，C语言已经是接近50高龄的老人家了，而C++语言也差不多40岁了。 ​ 表1-2 TOIBE的编程语言排行榜（前5位，2020年8月） 2020年8月 2019年8月 排名变化 编程语言 占有率 变化率 1 2 ↑ C 16.98% +1.83% 2 1 ↓ Java 14.43% -1.60% 3 3 Python 9.69% -0.33% 4 4 C++ 6.84% +0.78% 5 5 C# 4.68% +0.83% ​ C/C++是执行效率最高的程序设计语言，C语言的执行速度甚至十分逼近汇编语言。然而天下武功，唯快不破，至少在下述领域，C/C++语言发挥着舍我其谁的不可替代的重要作用： 编写操作系统：无论是Windows、Linux、UNIX还是Mac OS，其内核均由C语言混合汇编语言编写，非内核部分则会部分使用C++语言。对于运行于底层的操作系统而言，运行速度以及与硬件打交道的便捷性均是最重要的考量因素，而这些，正是C/C++语言之所长。 编写其他高级语言的解释器、虚拟机：Java语言虚拟机是由C+汇编语法编写的；Python语言解释器（特指CPython）是由C语言编写的。可以说，C语言是各种程序设计语言之母。 高性能的系统软件：关系数据库系统mysql是用C及C++语言编写而成；高性能Web服务器软件nginx则由C语言编写。 资源耗费巨大、对速度要求高的大型工具软件：计算机辅助设计软件AutoCAD、集成电路设计软件Cadence等都是用C/C++语言为主编写的。 单片机程序：受限于单片机有限的计算资源和能力，目前单片机片上程序的编写仍以C语言为主。最近几年，以 5G及物联网为基础，大量的低功耗可编程器件被广泛使用， 受限于有限的计算资源和能力，这些器件上的程序编写以C语言为主。 ​ C/C++语言比很多读者的父辈还要年长。在数十年的发展历程中，不断丰富和发展。在语言变得更加强大和健壮的同时，其语法也变得异常复杂。同一行代码，一个有经验的程序员很容易给出5种以上不同的写法。从软件工程角度，这种复杂性不必要而且有害。但考虑到对遗留代码的兼容，C++不得不背负这些历史包袱。作者并不试图全面介绍C/C++的全部语法特性，而只是介绍那些常用的，必须的语法特性。作者认为，对于大多数的工程实践而言，掌握这些必要特性就足够应付了。 ​ 本书使用下述符号来标识C/C++不同版本之间的差异。 ​ 表1-3 表示语言版本差异的符号 符号 说明 【C】 该特性仅在C语言中得到支持 【C++】 该特性仅在C++语言中得到支持 【C++ 11】 该特性在C++ 11及其以后版本中得到支持 【C++ 14】 该特性在C++ 14及其以后版本中得到支持 【C++ 17】 该特性在C++ 17及其以后版本中得到支持 1.2 计算机原理现代电子计算机仍然没有超出由匈牙利科学家冯·诺依曼（von Neumann）于1945年提出的冯·诺依曼体系结构。在该结构中，计算机被认为由5大部件组成，如图1-1所示。 ​ 图1-1 冯 · 诺依曼体系结构 其中，典型的输入设备包括键盘、鼠标、网卡等，它们负责从计算机外部输入数据到计算机；典型的输出设备包括显示器、打印机、网卡等，它们负责将计算机内部的数据输出到计算机外部。读者可能注意到了，网卡既是输入，也是输出设备。 中央处理单元（Central Processing Unit），简称CPU，是计算机的核心。它由运算器和控制器组成。其中，运算器负责加、减、乘、除四则运算，与、或、非、异或等逻辑操作，以及移位、比较、传送等操作。控制器则是计算机中指令的解释和执行机构，它控制运算器、存储器、输入输出设备等部件的协调动作。 存储器又分为内部存储器及外部存储器两个部分。其中，内部存储器简称内存，通常是易失的，容量相对较小，但存取速度显著快于外部存储器。所谓易失，是指计算机断电后，内存中的数据会自动丢失。外部存储器通常指硬盘、固态硬盘、U盘等存储设备，相对于内存，其数据可以在断电后永久保存，容量通常也更大，但数据存取速度通常显著慢于内存。如果把计算机看作一个完成计算任务的计算员的话，内存可以理解为计算员的草稿纸，它存储计算步骤以及临时的中间结果，而外存，则用于存储计算任务的输入以及计算的最终结果。 冯 · 诺依曼计算机是所谓存储程序计算机，计算机处理的数据和指令（程序）一律用二进制表示，并存储于存储器中。在CPU内部控制器的控制下，CPU从存储器逐条读入并执行程序的每条指令。每条指令执行一个单一的任务：比如将寄存器R0与整数3相加，并将计算结果存储到指定地址的内存单元中。借助于跳转、逻辑判断等指令，程序员可以将各种简单的计算操作进行组合，从而让计算机完成诸如从一大堆图片中找出加菲猫等复杂任务。 计算机可以执行的原始指令的集合称之为指令集。当代的计算机，最主要的指令集分为两类，一类是Intel的x86指令集，主要用在笔记本及台式计算机上；另一类则是ARM的ARM指令集，主要使用在手机等移动终端，以及大量的嵌入式低功耗计算机上。上述两类指令集均是商业指令集，任何公司如果期望生产使用上述指令集的计算机，需需要获得相应的授权。为了实现更美好的共享的全球化的世界，另一种开源的指令集RISC-V，近年来异军突起，得到工业界相当多的关注和支持。 注意📢 本节所描述的计算机结构是一个极简化的版本，真实的情况要复杂得多。广义地说，一台笔记本电脑、一部手机、一张使用IC的银行卡上的IC，都属于计算机的范畴，其具体结构差异非常大。 1.3 内存模型 ​ 图1-2 内存模型 计算机的内存在逻辑上可以用图1-2表示。存储器的最小单位为比特（bit）,一个比特可以存储0和1两种状态，对应一个二进制数的1位。每8个比特被组织成一个单元，称为一个字节（byte），其比特位按位权从低到高编号为第0位至第7位。一个字节的8个比特可以表示28，即256种组合，当视为无符号数时，其储值范围为0 ~ 255；当视为有符号数时，符号位要占掉1位，只余7位表示有效值，其储值范围为 -128 ~ +127。如果要表示更大的数，则可以将2个、4个或8个字节联合使用，其可以表达的组合数分别为216、232以及264。 表1-4总结了常用的存储容量单位及其换算关系。 ​ 表1-4 常用存储容量单位 单位符号 名称 换算 单位符号 名称 换算 bit 比特 最小存储单位 byte 字节 1 byte = 8 bit kB 千字节 1 kB = 1024 byte = 210 byte MB 兆字节 1 MB = 1024 kB = 220 byte GB 吉字节 1 GB = 1024 MB = 230 byte TB 太字节 1 TB＝ 1024 GB = 240 byte 当一台计算机总共拥有N个字节容量的内存时，通常情况下，其每个字节存储单元的地址依次为1 ~ N。假设你的计算机安装了一根4 GB容量的内存条，其内存容量为232字节，每个字节存储单元的地址依次为1 ~ 232。 要点🎯 内存地址以字节为单位编排。CPU从内存存取数据的最小单位为1个字节。如果期望对1字节存储单元的特定比特位进行修改，只能先读出整个字节，然后使用按位操作指令对特定位进行操作，再将整个字节作为整体写回内存。 1.4 编译器1.5 Qt集成开发环境[缺：Qt的简介] Qt集成开发环境的下载与安装 https://codelearn.club/2020/01/qt-install-win/ Qt Creator操作入门 https://codelearn.club/2020/02/simpleqtuse/ 1.6 学习方法2. 变量及简单数据类型本讲义系重庆大学C/C++课程的教学笔记。 作者： 陈波 chenbo@cqu.edu.cn， All rights reserved. 未经作者许可，不允许经由互联网展示或提供下载。 不允许以纸质出版为目的进行摘抄或改编。 2.1 Hello World编程教材的民俗是先打印输出一个“Hello World”向世界问好，这里我们先赞美一下美好的生活。按照?1.2节介绍的方法在Qt Creator中创建一个Non-Qt Project/Plain C Application，可在其项目主程序文件main.c中看到下述代码： 123456#include &lt;stdio.h&gt;int main() &#123; printf(\"Hello World!\\n\"); return 0;&#125; 单击Qt Creator左下角的运行（run）按钮（或使用Ctrl+R组合键），构建（build）并运行，可得如图2- 所示的运行结果： 图2- Hello World运行结果 按Enter键或者单击该窗口右上角的X按钮，可关闭上述结果窗口。 说明：按照Windows操作系统的通常设置，该运行窗口为黑底白字，为阅读方便，本书的后续部分将以白底黑字形式展现运行结果。 第3 ~ 6行：main( )是一个标准C/C++程序的入口函数（function），即程序启动后会从main( )函数开始执行。main为其函数名，( )里提供的是这个函数的参数(parameter)，函数收到参数并执行特定任务后返回一个整数(int)。这个返回的整数可以帮助操作系统判断程序的执行过程是否正常。图2- 描绘了该函数的结构。 图2- main( )函数的结构 1#include &lt;stdio.h&gt; 第1行：这是一行预处理指令（preprocessor directive），该行代码将标准输入输出头文件（header file）stdio.h包含至main.c程序文件内。对于上述代码而言，该头文件引入了printf( )函数。换言之，如果期望在代码中使用printf( )函数，必须包含stdio.h头文件。 1printf(\"Hello World!\\n\"); 第4行：printf( )函数将参数字符串（string）格式化输出至控制台（console）。字符串以双引号包裹，上述代码中的”\\n“是转义字符，表示接下来的输出另起一行。在C/C++里，每一个完整的指令称为一个语句（statement），语句总是以”;”号分隔。 1return 0; 第5行：return语句返回整数0作为main( )函数的执行结果。在操作系统看来，0值表示该程序的执行没有发生异常。 操作系统以及诸如Qt Creator这样的集成开发环境（Integrated Development Environment）通过文件的扩展名来识别文件的类型。表2- 总结了C/C++开发过程中常用的文件类型。 表2- 常用的文件类型 扩展名 文件类型 .h C/C++的头文件 .hpp C++的头文件 .c C语言程序文件 .cpp C++语言程序文件 .o 编译过程中生成的目标文件▲ .exe Windows操作系统下的可执行文件 .pro Qt Creator项目文件 ▲：同时兼顾初学者的学习曲线和知识内容的结构是一件不太容易的事，读者在阅读过程中有时会遇到一些暂时无法理解的内容，比如上述表格中的目标文件。不用担心， 随着内容的逐步展开，我们会在后续章节中进行讨论。我们给此类内容加上▲符号，便于读者在恰当时间进行回顾。 2.2 变量新建一个Plain C Application，将main.c修改如下： 12345678910111213//Project - Variable#include &lt;stdio.h&gt;int main()&#123; int n = 3; float fPrice = 3.6; float fAmount = n * fPrice; float fMoney = 20; fMoney = fMoney - fAmount; printf(\"%d apples, %.1f for each, %.2f in total.\\n\",n,fPrice,fAmount); printf(\"20 - %.2f = %.2f.\",fAmount,fMoney); return 0;&#125; 上述代码的执行结果为： 123 apples, 3.6 for each, 10.80 in total.20 - 10.80 &#x3D; 9.20. 上述代码的第1行以”//“开头，为注释（comment）。注释是程序员写给自己或者同事看的，编译器编译过程中会自动忽略注释。 约定：示例代码的首行注释提示了该代码文件在随书代码目录中的位置。本例中的Project - Variable提示该代码文件位于随书代码第2章中的名为Variable的项目（Project）中。 上述代码中的n、fPrice、fAmount和fMoney都是变量（variable），每个变量都存储一个值。其中，n为整数类型（int），fPrice, fAmount, fMoney为浮点数类型（float）。在程序运行过程中，变量的值可以随时修改。 1int n = 3; 第5行：代码完成了两个任务。 声明并定义了一个名为n的变量，其类型为整数（int）。 将这个变量的值初始化为3。 后续fPrice、fMoney等变量的定义和初始化过程与此类似。请注意，变量必须先定义，后使用。 注意：提醒那些先前学习过Python语言的读者，n = 3与Python里的名字绑定完全不同。C/C++里，读者可以认为n就是一块内存空间，n = 3就是把整数3存入名称为n的内存空间中。 上述代码还使用了几个操作符（operator），表2- 列出了几个最常用的C/C++操作符及其使用示例。 表2- 常用操作符 操作符 说明 示例 = 赋值（assignment），通常用于将右方的值传递给左方的变量。 n = 3 + 加（add） b + c - 减（substract） fMoney - fAmount * 乘（multiply） n * fPrice / 除（divide） 30 / 2.3 1printf(\"%d apples, %.1f for each, %.2f in total.\\n\",n,fPrice,fAmount); 第10行：printf( )函数共有4个参数，其中，第1个参数由双引号包裹，是一个字符串。该字符串中包含了三个占位符（place holder），在格式化输出过程中，这些占位符将依次由后续参数的值替换。图2- 展示了该行的各占位符、参数与输出文本之间的对应关系，表2- 列出了几个最常用的C/C++占位符。 图2- 占位符对应关系 表2- 常用占位符 占位符 说明 %d 整数 %f 浮点数（小数）， %.1f表示精确到小数点后一位的浮点数， 依次类推 %s 字符串 %p 指针（地址）▲ %c 字符 %o 八进制整数 %x 十六进制整数 printf( )函数可以接受多个参数，其第1个参数预期为一个字符串，该字符串中的占位符个数以及要求的类型应与后续其他参数相匹配，否则会产生错误。 2.3 简单数据类型新建一个Plain C++ Application，将main.cpp修改如下： 1234567891011121314151617181920212223242526272829303132//Project - DataType#include &lt;iostream&gt;using namespace std;int main()&#123; char c = 'z'; cout &lt;&lt; \"char c = \" &lt;&lt; c &lt;&lt; \", size = \" &lt;&lt; sizeof(char) &lt;&lt; \" bytes.\" &lt;&lt; endl; short si = 2194; cout &lt;&lt; \"short si = \" &lt;&lt; si &lt;&lt; \", size = \" &lt;&lt; sizeof(si) &lt;&lt; \" bytes.\" &lt;&lt; endl; int i = int(12); cout &lt;&lt; \"int i = \" &lt;&lt; i &lt;&lt; \", size = \" &lt;&lt; sizeof(i) &lt;&lt; \" bytes.\" &lt;&lt; endl; long li = 298289282; cout &lt;&lt; \"long li = \" &lt;&lt; li &lt;&lt; \", size = \" &lt;&lt; sizeof(li) &lt;&lt; \" bytes.\" &lt;&lt; endl; long long ll = 28929829982892; cout &lt;&lt; \"long long ll = \" &lt;&lt; ll &lt;&lt; \", size = \" &lt;&lt; sizeof(long long) &lt;&lt; \" bytes.\" &lt;&lt; endl; bool b = 3 &gt; 2; cout &lt;&lt; \"bool b = \" &lt;&lt; b &lt;&lt; \", size = \" &lt;&lt; sizeof(bool) &lt;&lt; \" bytes.\" &lt;&lt; endl; float f &#123;79.23&#125;; cout &lt;&lt; \"float f = \" &lt;&lt; f &lt;&lt; \", size = \" &lt;&lt; sizeof(float) &lt;&lt; \" bytes.\" &lt;&lt; endl; double d &#123;&#125;; cout &lt;&lt; \"double d = \" &lt;&lt; d &lt;&lt; \", size = \" &lt;&lt; sizeof(d) &lt;&lt; \" bytes.\" &lt;&lt; endl; return 0;&#125; 上述代码的执行结果为： 12345678char c &#x3D; z, size &#x3D; 1 bytes.short si &#x3D; 2194, size &#x3D; 2 bytes.int i &#x3D; 12, size &#x3D; 4 bytes.long li &#x3D; 298289282, size &#x3D; 4 bytes.long long ll &#x3D; 28929829982892, size &#x3D; 8 bytes.bool b &#x3D; 1, size &#x3D; 1 bytes.float f &#x3D; 79.23, size &#x3D; 4 bytes.double d &#x3D; 0, size &#x3D; 8 bytes. 上述代码定义并使用了多个类型的变量。从面向对象程序设计的观点来看，变量（variable）也称为对象（Object），每个对象都有特定的数据类型（Type），数据类型有时也称为类（class）。在本书的后续部分，变量、对象等术语将会混用。 C/C++是所谓强类型语言，即每个对象都须先通过定义给予确定的数据类型。在类型确定的情况下，编译器可以方便地安排对象的存储空间，以便于生成高效率的执行代码。每个对象，都需要占用计算机的存储器空间，相同类型的对象，占据相同大小的存储空间，该空间以字节（byte）为单位。上述代码中的sizeof( )在使用形式上很象函数，但它事实上是一个操作符，用于计算一个特定类型的对象所占据的存储器字节数。在该操作符的括号，既可以提供对象，如sizeof(i)，也可以提供数据类型，如sizeof(float)。由于编译器“知道”每个对象的类型，所以，当编译器遇到代码sizeof(i)时，会自动推断出实际需要被计算的是sizeof(float)。表2- 列出了常用的简单数据类型。 1#include &lt;iostream&gt; 第2行：包含了iostream【C++】，这是C++中的”输入输出流“（input &amp; output stream）头文件，它负责基本的输入输出操作。上述程序中的cout就是由iostream引入的。 1using namespace std; 第3行：引入了std名字空间（namespace）【C++】，为了避免变量/对象的重名，C++通过名字空间来区分同名的变量。严格地说，cout的全名应为std::cout，由于第3行代码引入了std名字空间，所以我们可以在后续代码中直接使用cout变量。关于名字空间▲，我们将在后续章节进一步讨论。 上述代码还多次使用cout对象以及&lt;&lt;操作符向控制台输出信息，其功能类似于printf( )函数。以下述代码为例，我们简述通过cout进行打印输出的过程。 1cout &lt;&lt; \"char c= \" &lt;&lt; c &lt;&lt; \", size= \" &lt;&lt; sizeof(char) &lt;&lt; \" bytes.\" &lt;&lt; endl; 第7行：cout是一个定义在iostream头文件中的变量，作为控制台输出流（console output stream）使用，其类型为ostream（输出流）; endl也由iostream定义，表示一个换行符，即控制台输出另起一行。上述&lt;&lt;操作符可以连着使用，此处我们总共使用了6个&lt;&lt;操作符，向控制台输出了6个值，这6个值中，有的是字符串，有的是整数（sizeof操作符的返回值），还可以是其它类型。事实上，该行代码的执行过程及其工作原理十分复杂，其中的部分内容需要到本书的后半部分才能彻底解释清楚。当前阶段，读者依照上述格式直接使用即可。 上述程序中的下述代码展现了几种不同的变量初始化的方法： 1234short si = 2194;int i = int(12);float f &#123;79.23&#125;;double d &#123;&#125;; 其中，第1行使用了赋值操作符来初始化si变量；第2行使用了面向对象程序设计中的构造函数▲语法，在类型名之后的括号里提供变量的初始值；第3，4行【C++ 11】使用一对花括号来包含变量的初始值，同时省略了赋值操作符，当花括号内为空时，表明初始化变量为0。 注意：按照软件工程规范，程序员应在定义变量时给变量赋以确定的初始值。未作初始化的变量极可能导致软件缺陷。 表2- 常用简单数据类型 类型 说明 字节数 char 字符 1 short 短整数，也可以写作short int 2 int 整数 4 long 整数（注意，与直觉相反，在多数编译器下，long跟int相同，占据4个字节） 4 long long 长整数 8 bool 布尔型【C++】 1 float 单精度浮点数 4 double 双精度浮点数 8 long double 更长的双精度浮点数 16 注意：表2- 中的各类型字节数代表了大多数编译器的情况，在部分编译器下，长度可能会不同。 2.3.1 字符类型每个字符类型的对象占据1个字节的存储空间。如图2- 所示，1个字节由8个比特（bit）构成，这8个比特人为编上序号，分别为第0位至第7位，其中第7位为最高位。每个比特可以存储一个为0或者为1的二进制位，故1个字节总共可以表达28共256种不同的状态。 图2- 一个字节的存储结构 为便于解释，我们创建一个Plain C++ Application，将main.cpp修改如下： 1234567891011121314151617181920212223//Project - CharType#include &lt;iostream&gt;#include &lt;climits&gt;using namespace std;int main()&#123; cout &lt;&lt; \"Number of bits: \" &lt;&lt; CHAR_BIT &lt;&lt; endl; cout &lt;&lt; \"Range of signed char: \" &lt;&lt; CHAR_MIN &lt;&lt; \" ~ \" &lt;&lt; CHAR_MAX &lt;&lt; endl; cout &lt;&lt; \"Range of unsigned char: \" &lt;&lt; 0 &lt;&lt; \" ~ \" &lt;&lt; UCHAR_MAX &lt;&lt; endl; char c = 'c'; cout &lt;&lt; \"ASCII code of 'c': \" &lt;&lt; (int)c &lt;&lt; endl; c += 1; cout &lt;&lt; \"'c' + 1 = \" &lt;&lt; c &lt;&lt; endl; c = 250; cout &lt;&lt; \"signed char with value 250: \" &lt;&lt; int(c) &lt;&lt; endl; unsigned char uc = 250; cout &lt;&lt; \"unsigned char with value 250: \" &lt;&lt; int(uc) &lt;&lt; endl; return 0;&#125; 上述代码的执行结果为： 1234567Number of bits: 8Range of signed char: -128 ~ 127Range of unsigned char: 0 ~ 255ASCII code of &#39;c&#39;: 99&#39;c&#39; + 1 &#x3D; dsigned char with value 250: -6unsigned char with value 250: 250 上述代码中的char类型，事实上是signed char（有符号字符）的简写形式，由于需要大约1个比特来表示值的正负，所以只余下7个比特来表示值的大小。因此，signed char的取值范围为 -27 ~ 27-1，即-128 ~ +127。无符号字符（unsigned char）类型只表达非负值，故能充分利用8个比特的全部256种状态，其取值范围为0 ~ 28-1，即0 ~ 255。 1#include &lt;climits&gt; 第3行：climits头文件引入了一系列通过#define预处理指令▲定义的符号常量（symbolic constant），这些常量可以帮助我们确定各种类型的取值范围及存储比特数，详情请见表2- 。由于计算机内的存储空间分配是以字节为单位的，所以各类型的存储比特数均为8的倍数。区别于变量，常量（constant）的值不可以在程序执行过程中发生变化，即不可以被赋值。 表2- climits上定义的符号常量 名称 用途 值 名称 用途 值 CHAR_BIT char类型比特数 8 CHAR_MAX char类型最大值 +27-1 CHAR_MIN char类型最小值 -27 UCHAR_MAX unsigned char类型最大值 +28-1 SHRT_MAX short类型最大值 +215-1 SHRT_MIN short类型最小值 -215 USHRT_MAX unsigned short类型最大值 +216-1 INT_MAX int类型最大值 +231-1 INT_MIN int类型最小值 -231 UINT_MAX unsigned int类型最大值 +232-1 LONG_MAX long类型最大值 +231-1 LONG_MIN long类型最小值 -231 ULONG_MAX unsigned long类型最大值 +232-1 LLONG_MAX long long类型最大值 +263-1 LLONG_MIN long long类型最小值 -263 ULLONG_MAX unsigned long long类型最大值 +264-1 注意：表2- 中给出的范围值代表了大多数编译器的情况，在部分编译器下，范围值可能会不同。 上述代码中7 ~ 9行的输出结果与上表相符。 1char c = 'c'; 第11行：将小写的英文字符’c’赋值给了变量c，请注意，单个的字符应使用单引号包裹。根据美国标准信息交换代码（ASCII），char类型取值的正值部分与英文字符可以一一对应。表2- 即为ASCII码表。查表可知，小写字母c对应码值99。 关于ASCII码表，请读者注意如下事实： 1). 英文字母a-z、A-Z以及数字0 - 9的编码是连续的。b的编码比a大1，c比b大1，依次类推。这种英文字符编码的连续性构成了对字符串进行比较运算▲的数学基础。 2). 字符’0’的ASCII码值为48，即，如果一个char类型变量，其存储空间所存值等于48时，说明这个变量存储的是字符‘0’。 3). ASCII码值0表示空字符（NULL）。如果一个char类型变量，其存储空间所存值为数值0时，并不意味着这个变量存储着字符’0’。相反，0值的char被C/C++用于表示一个字符串的结尾。▲ char类型事实上就是8比特的有符号整数。它有如下特性： 当把一个字符赋值比如’c’赋值给一个char类型变量时，事实上存入该变量的是’c’字符的ASCII码值。 可以直接把整数赋值给char类型变量，也可以把一个char类型变量直接赋值给一个整数类型变量。 char类型变量可以作为一个整数参与加减乘除等数学运算。 当把char类型变量输出给cout或者替换printf( )中的占位符%c时，计算机会输出与变量内所存整数对应的ASCII码字符。 1cout &lt;&lt; \"ASCII code of 'c': \" &lt;&lt; (int)c &lt;&lt; endl; 第12行：（int)c是C语言进行类型转换的格式，转换的目标类型置于对象/值前方的括号中。这种转换形式存在错误转换的风险，较新的C++标准不建议这种转换形式。在Qt Creator中，我们可以看到IDE环境对该行代码给出了警告信息。此处，我们先将char类型的变量c转换为int，然后再交给cout进行输出得到’c’的ASCII码值99。如果直接把c输出给cout，则会在屏幕上得到输出字符c。 注意：变量的类型转换并不会改变变量本身的类型。通常，编译器会创建一个用完即弃的目标类型的临时对象，并尽量让这个临时对象的值与原变量的值一致。第12行代码中的(int)c被执行后，c的类型仍为char，其值未变。 1c += 1; 第13行：c += 1使用了复合操作符（compound operator）+=，其语法含义等价于c = c + 1。该行执行后，c变量的“整数”值由99变为了100，第14行将c变量输出给cout，cout按照ASCII码对c变量进行解释输出，得到字符d。 表2- 美国标准信息交换代码表（ASCII） 【？缺表】 变量c的类型为char，实为signed char，其取值范围为-128 ~ +127。第16行试图给c赋值250，这显然超出了signed char类型的储值范围，这种情况我们称之为溢出。当溢出发生时，程序会错误解读变量的值，从17行代码的输出结果看，250的正值被解读为-6。程序员在编程时，应注意避免溢出。庆幸的是，现代计算机的内存资源已相对宽松，本书的读者大概用不着跟二十年前的前辈一样在内存的使用上锱铢必较了。 1cout &lt;&lt; \"signed char with value 250: \" &lt;&lt; int(c) &lt;&lt; endl; 第17行：int(c)达成了与第12行类似的变量类型转换效果，这种语法形式类似于面向对象中的构造函数▲。类似地，如果要把变量c转换为浮点数，相应代码为float(c)。 12unsigned char uc = 250;cout &lt;&lt; \"unsigned char with value 250: \" &lt;&lt; int(uc) &lt;&lt; endl; 第19 ~ 20行：代码及其输出结果证明了一个unsigned char类型的对象，能够存储和正确处理整数250。 2.3.2 整数类型short, int, long, long long都是整数类型，其区别仅在于存储空间的字节数，以及由此导致的储值范围的差异。详情请回顾表2- 及表2- 。 下面以int类型为例，说明全部整数类型的存储结构。如图2- 所示，一个int类型的对象由相邻的4个字节组成，每个字节8比特，共32比特。其中，第0位为最低位，第31位为最高位。这32比特以二进制补码▲形式存储一个整数。由于需要使用大约1个比特来表示整数的正负，有符号整数（signed int）的储值范围为-231 ~ +231-1；无符号整数（unsigned int）的储值范围为0 ~ 232-1。 图2- int类型的存储结构 类似地，short, long, long long类型默认为有符号类型，可以存储正整数及负整数；在类型名前加一个unsigned，如unsigned short，即为对应的无符号类型，仅可存储非负值。 【？选哪种整型】 扩展阅读📕 要彻底理解有符号类型与无符号类型在储值范围上的差异，以及当溢出发生时，到底发生了什么，需要首先弄明白整数的二进制编码，特别是补码的编码格式。【？缺】 2.3.3 浮点数类型浮点数就是所谓的小数，一个float类型的对象占据4个字节共32比特。这32个比特以类似于科学计数法的形式来表达一个浮点数，按照IEEE 754标准，其数学表示为：$$\\pm M \\times 2^E$$如图2- 所示，最高的1位(第31位）用做符号位，接着的 8 位(第23-30位）是指数E，剩下的 23 位（第0-22位）为有效数字 M。 图2- float的存储结构 相对于float，double类型使用8个字节来存储一个浮点数，它的储值范围以及精度都会高一些。习惯上，我们称float为单精度浮点数，double为双精度浮点数。所有的浮点数类型都是有符号的。 受限于有效数字的位数，浮点数的精度受到限制，会存在微小的误差。为了观察float与double的精度差异及其存储误差，我们创建一个Plain C Application，并修改main.c如下： 1234567891011121314151617//Project - FloatError#include &lt;stdio.h&gt;int main()&#123; float f = 0.00001; printf(\"The stored value of 0.00001 with float: %.30f\\n\",f); double d = 0.00001; printf(\"The stored value of 0.00001 with double: %.30f\\n\",d); if (f==0.00001) printf(\"f == 0.00001\"); else printf(\"f &lt;&gt; 0.00001\"); return 0;&#125; 上述代码的执行结果为： 123The stored value of 0.00001 with float: 0.000009999999747378751600000000The stored value of 0.00001 with double: 0.000010000000000000001000000000f &lt;&gt; 0.00001 代码第6，9行的输出结果表明，0.00001存储至浮点数内，均有微弱误差，但double双精度浮点数的误差显然比float要小。 第11~14行是后面章节要讨论的条件分支语句▲，可以简单理解为如果… 则… 否则… 。当11行括号内的条件判断成立时，执行第12行，否则，执行第14行。（f==0.00001）中的==号用于判断两端的值是否相等，如果相等，表示逻辑真，否则为逻辑假。从执行结果可以看出，由于存储误差的原因，上述相等判断被认为是假的，第14行代码被执行。 注意：一般不要对浮点数进行逻辑相等判断，误差的存在会导致意料之外的结果。 2.3.4 布尔类型1bool b = 3 &lt; 2; 3 &lt; 2显然不成立，这种不成立的结果逻辑上称为假(false)。这个值被赋值给了变量b， b的类型为布尔型【C++】，值为false。相对于假，表示一个命题成立或者正确的值称为真(true)。布尔型只有true和false两个取值。一个布尔类型的对象仅占据1个字节的空间。 C语言没有提供bool类型。在一些C语言开发包里，常见于各种单片机的C语言开发包，可以看到如下代码▲，这些代码通过int类型来模拟布尔型。 123typedef int BOOL;#define TRUE 1#define FALSE 0 为更好地理解bool型，我们创建一个Plain C++ Application，并将main.cpp修改如下： 123456789101112131415161718192021//Project - BoolType#include &lt;iostream&gt;using namespace std;int main()&#123; bool a = 3 &gt; 2; bool b = false; cout &lt;&lt; \"value of a: \" &lt;&lt; a &lt;&lt; \",value of b: \" &lt;&lt; b &lt;&lt; endl; cout &lt;&lt; \"int(true): \" &lt;&lt; int(true) &lt;&lt; \",int(false): \" &lt;&lt; int(false) &lt;&lt; endl; if (-0.00000012) cout &lt;&lt; \"-0.00000012 is true.\" &lt;&lt; endl; if (2*2-4) cout &lt;&lt; \"2*2-4 is true.\" &lt;&lt; endl; else cout &lt;&lt; \"2*2-4 is false.\" &lt;&lt; endl; return 0;&#125; 上述代码的执行结果为： 1234value of a: 1,value of b: 0int(true): 1,int(false): 0-0.00000012 is true.2*2-4 is false. 显而易见，a被赋值为true，b为false。从第9行代码的输出结果可以看到，当a被输出给cout时，得到1，b被输出给cout时，得到0。第10行代码中的int(true)将bool型的true值转换成整数，int(false)则将bool型的false值转换成整数，同样，从输出结果可以看到，true对应整数1， false对应整数0。 第12，15行分别将一个浮点数和一个整数当成布尔型看待，从输出结果看，-0.00000012作为逻辑判断其结果为真，22-4作为逻辑判断其结果为假。事实上，绝大多数编程语言都执行*非零即真*的原则，当一个值被视作布尔型时，只要该值不是0，就视为逻辑真。此处，-0.00000012不是0为真，2\\2-4的计算结果是0为假。 2.4 变量命名前述示例中的变量取名都是程序员决定的，当程序员给变量取名时，应符合下述规则： 变量的命名规则 - 变量名只能包含字母、数字和下划线，且不能以数字打头； - 变量名不能包括空格； - 不能将C/C++关键字和函数名用作变量名； - 慎用小写字母l和大写字母O, 容易看成数字1和数字0； - C/C++的命名是大小写敏感的，也就是说cat跟Cat对于编译器而言，是两个不同的名字。 下表列举了一示变量命名的示例： 娈量名举例 评价 iCount，sStudentNo, fPrice 正确并且好的命名 √ A9, _a678, U2_1 正确但不好的命名，不具备恰当的描述性 × 9B 错误，不能以数字开头 × $y7 错误，以特殊符号开头 × for, printf 错误，与关键字或者函数名冲突 × MA U2 错误，包含空格 × lO2 正确但不好的命名，字母l及字母O易被错误看成数字1和0 × 符合语言命名规则的命名都是正确的，但正确并不等于好。本书配套网站总结了本书程序中的命名规则，读者可以在阅读完本书的大部分内容后再阅读。零基础的初学者，现在还无法理解其中的内容。 [To 编辑: 网络提供 https://codelearn.club/2019/06/namemethod/] 2.5 字面量所谓字面量（literal），就是在程序代码中显示给出的值，比如199，0.127，’c’等。 2.5.1 整数整数字面量默认以十进制方式提供，程序员也可以使用十六进制、八进制和二进制方式提供整数字面量。请见下述C++代码： 123456789101112131415//Project - HexOct#include &lt;iostream&gt;#include &lt;stdio.h&gt;using namespace std;int main()&#123; int b = 0x17; //十六进制 hexadecimal int c = 017; //八进制 octal int d = 0b01111110; //二进制 binary cout &lt;&lt; \"0x17 = \" &lt;&lt; b &lt;&lt; \", 017 = \" &lt;&lt; c &lt;&lt; \", 0b01111110 = \" &lt;&lt; d &lt;&lt; endl; printf(\"17: %x, %d, %o\\n\", 17, 17, 17); cout &lt;&lt; \"17: \" &lt;&lt; hex &lt;&lt; 17 &lt;&lt; \", \" &lt;&lt; dec &lt;&lt; 17 &lt;&lt; \", \" &lt;&lt; oct &lt;&lt; 17 &lt;&lt; endl; return 0;&#125; 上述代码的执行结果为： 1230x17 &#x3D; 23, 017 &#x3D; 15, 0b01111110 &#x3D; 12617: 11, 17, 2117: 11, 17, 21 0x17表示十六进制的17，以数字0打头的017表示八进制的17，以0b开头的是二进制字面量。 1cout &lt;&lt; \"0x17 = \" &lt;&lt; b &lt;&lt; \", 017 = \" &lt;&lt; c &lt;&lt; \", 0b01111110 = \" &lt;&lt; d &lt;&lt; endl; 第11行：输出结果证实，0x17对应十进制的23， 017对应十进制的15，0b01111110【C++ 14】对应十进制的126。 1printf(\"17: %x, %d, %o\\n\", 17, 17, 17); 第12行：通过占位符，将十进制的整数17分别以十六进制、十进制、八进制形式输出。 1cout &lt;&lt; \"17: \" &lt;&lt; hex &lt;&lt; 17 &lt;&lt; \", \" &lt;&lt; dec &lt;&lt; 17 &lt;&lt; \", \" &lt;&lt; oct &lt;&lt; 17 &lt;&lt; endl; 第13行通过cout实现与第12行类似的功能。下述代码并不会在屏幕上显示任何内容： 1cout &lt;&lt; hex; 事实上，标识符（identifier）hex在iostream头文件中定义，上述代码相当于改变了cout的内部状态，使得cout在接下来的整数输出当中会使用十六进制格式。同理，dec指示cout以十进制形式输出整数，oct指示cout以八进制形式输出整数。 注意：代码以及输出内容中的进制，只是一种表达和解释数据的方式。事实上，数据在计算机存储器中的存储，永远是二进制的。 调整C++版本 需要注意的是，二进制形式的整数字面量是C++ 14版本引入的新特性，而默认创建的Qt Creator项目默认执行C++ 11标准。所以，读者可能会在Qt Creator中看到对第9行代码的警告甚至是报错。此处，可以点开HexOct.pro项目文件，将其第2行中的c++11改为c++17即可解决。 1234567TEMPLATE &#x3D; appCONFIG +&#x3D; console c++17CONFIG -&#x3D; app_bundleCONFIG -&#x3D; qtSOURCES +&#x3D; \\ main.cpp 对于整数字面量，还可以在末尾添加下述后缀来表明其类型，见下表： 表2- 整数字面量的后缀 后缀 说明 示例 l, L long类型 512l, 512L u, U unsigned int类型 1230u, 82882U ul, UL unsigned long类型 1230ul， 82882UL ll, LL【C++ 11】 long long类型 8282ll, 2828LL ull, Ull, uLL, ULL【C++ 11】 unsigned long long类型 9272733ULL 正如读者看到的那样，小写字母l很容易与整数1混淆。我们建议在使用后缀标识整数字面量类型时，使用大写字母L。 2.5.2 字符及字符串单个字符的字面量用单引号包裹（示例如下），由多个字符所构成的字符串字面量用双引号包裹。 字面量 ASCII码值 含义 字面量 ASCII码值 含义 ‘D’ 68 大写字母D ‘d’ 100 小写字母d ‘0’ 48 阿拉伯数字0 ‘ ’ 32 空格 ‘?’ 63 问号? ‘@’ 64 @符号 但计算机里存在这样一符特殊符号，难以在字面量中表达。比如下述单引号和双引号，由于其同时具备语法意义，编译器在编译时无法区分它是语法符号还是字面量的构成部分。 12&#39;&#39;&#39; &#x2F;&#x2F;单引号字符，存在语法歧义&quot;&quot;C&#x2F;C++ is terrible.&quot;&quot; &#x2F;&#x2F;包含双引号的字符串，存在语法歧义 为了解决上述问题，C/C++引入了转义字符（escape sequence），如下表所示： 表2- C/C++转义字符 转义字符 ASCII码 说明 转义字符 ASCII码 说明 \\n 10 换行符 \\t 9 水平制表符Tab \\v 11 垂直制表符 \\b 8 回退删除符（backspace） \\r 13 返回行首 \\a 7 发生警告声 \\\\ 92 右斜杠 \\‘ 39 单引号 \\“ 34 双引号 下述C++程序部分展示了上述转义字符的用法： 12345678910//Project - CharLiteral#include &lt;iostream&gt;using namespace std;int main()&#123; cout &lt;&lt; \"I told you, \\\"C/C++ is hard to learn\\\".\" &lt;&lt; '\\n'; cout &lt;&lt; \"When you need a \\\\ in string, put \\\\\\\\ in your code.\" &lt;&lt; \"\\n\"; cout &lt;&lt; \"Popular languages:\\n\\tJavaScript\\n\\tPython\\n\\tJava\\n\\tC\\n\\tC++\\n\\tRuby\"; return 0;&#125; 上述代码的执行结果为： 123456789I told you, &quot;C&#x2F;C++ is hard to learn&quot;.When you need a \\ in string, put \\\\ in your code.Popular languages: JavaScript Python Java C C++ Ruby 上述代码及其输出结果证实，\\“生成了字面量内部的一个双引号；\\\\ 生成了字面量内部的一个右斜杠；’\\n’以及“\\n”输出给cout都可以获得类似于endl相同的换行效果； \\t构成了大概8个空格（部分平台上可能是4个空格）的间距，直观上达到了将输出内容象表格一样对齐的目的，故得名“制表符”。 下述代码中的前缀R表明字符串字面量是生字符串（raw string）【C++ 11】。 12string s = R\"(I told you, \"C/C++\" is hard to learn, \\n means a new line.)\";cout &lt;&lt; s &lt;&lt; endl; 将上述代码置入一个C++的main( )函数中，其输出结果应为： 1I told you, &quot;C&#x2F;C++&quot; is hard to learn, \\n means a new line. 可以看出，一个生字符串以R”(开头，以)”结尾。两者之中的部分全部为字符串的直接构成部分，其中的转义字符不转义。上述字符串s，等价于下述字面量： 12string s = \"I told you, \\\"C/C++\\\" is hard to learn, \\\\n means a new line.\";cout &lt;&lt; s &lt;&lt; endl; 2.5.3 浮点数除了3.14这种形式的传统小数写法外，也可以使用科学计数法来表达浮点数。此外，通过给浮点数字面量增加恰当的后缀，可以指定字面量的类型。请见下述C++代码示例： 1234567891011121314151617//Project - FloatIteral#include &lt;iostream&gt;using namespace std;int main()&#123; auto a = 3; //int auto b &#123;3.0&#125;; //double auto c = 1.2E-5; //double auto d = 1.2E+5L; //long double auto e = -3.01e+12f; //float cout &lt;&lt; \"Name:\\ta\\tb\\tc\\td\\te\\n\"; cout &lt;&lt; \"Type:\\t\" &lt;&lt; typeid(a).name() &lt;&lt; \"\\t\" &lt;&lt; typeid(b).name() &lt;&lt; \"\\t\" &lt;&lt; typeid(c).name() &lt;&lt; \"\\t\" &lt;&lt; typeid(d).name() &lt;&lt; \"\\t\" &lt;&lt; typeid(e).name(); return 0;&#125; 上述代码的执行结果为： 12Name: a b c d eType: i d d e f auto【C++ 11】指示编译器根据后方初始值的类型来推断变量的类型，即上述变量a，b，c，d，e的类型均与后方字面量的类型相同。 同sizeof( )一样，typeid( )也是一个操作符。typeid(a)返回一个类型为type_info▲的对象，该对象包含了变量a的类型信息。执行该对象的name( )成员函数▲可以获得a的类型名称字符串（简写形式）。 从输出结果可以看出，第6行的字面量3被编译器认为是int类型（简写为i）。第7行的3.0被编译器认为是double类型（简写为d）。 第8~10行使用了科学计数法，1.2E-5等价于1.2 x 10-5，-3.01e+12等价于-3.01x1012。当使用科学计数法时，e和E通用。此外，还可以通过在浮点数字面量后添加后缀来指明浮点数类型，其中，f或F为float类型（简写为f），l或L为long double类型（简写为e），当没有后缀时，为double类型。上述程序所用到的字面量列表如下。 表2- 浮点数字面量示例 字面量 说明 字面量 说明 3 int类型，简写为i 3.0 double类型，简写为d 1.2E-5 double类型，简写为d，等价于1.2x10-5 1.2E+5L long double类型，简写为e，等价于1.2x105 -3.01e+12f float类型，简写为f，等价于-3.01x1012 由于小写字母l不易正确识别，当使用long double类型的字面量时，作者总是使用L。 12cout &lt;&lt; \"Type:\\t\" &lt;&lt; typeid(a).name() &lt;&lt; \"\\t\" &lt;&lt; typeid(b).name() &lt;&lt; \"\\t\" &lt;&lt; typeid(c).name() &lt;&lt; \"\\t\" &lt;&lt; typeid(d).name() &lt;&lt; \"\\t\" &lt;&lt; typeid(e).name(); 第14行：事实上是第13行的后半部分，为了阅读和印刷方便分成了两行，在语法意义上与合为一行没有区别。 微实践 - 鸡兔同笼鸡兔同笼是中国古代的数学名题之一。大约在1500年前，《孙子算经》中就记载了这个有趣的问题。书中是这样叙述的：​ 今有雉兔同笼，上有三十五头，下有九十四足，问雉兔各几何？这四句话的意思是：有若干只鸡兔同在一个笼子里，从上面数，有35个头，从下面数，有94只脚。问笼中各有多少只鸡和兔？ 首先分析下鸡兔同笼问题，一只鸡有一个头和两只脚，一只兔有一个头和四只脚。假定笼中全部是鸡，每个头对应两只脚，35个头对应70只脚。但总共有94只脚，多出脚的原因是因为有一部分是兔子，多余的脚就是兔子的另外两只脚，只需要将剩余的脚除以2就可以得到兔子的数量。有了兔子的数量就可以计算得到鸡的数量。 解决本问题的C语言代码如下： 123456789101112131415161718//Project - ChickenRabbit#include &lt;stdio.h&gt;int main()&#123; int iHeads = 35; //变量 - 头的数量 int iFeet = 94; //变量 - 脚的数量 int a = iFeet - 2 * iHeads; //假设全部是鸡，余下的脚的数量 int iRabbits = a / 2; //免的数量等于余下的脚数/2 int iChicken = iHeads - iRabbits; //鸡的数量等于 头的数量 - 兔的数量 printf(\"Number of chicken = %d, Number of rabbits = %d.\\n\", iChicken, iRabbits); if (iFeet == iChicken*2+iRabbits*4) //验证脚数 = 鸡数*2 + 兔数*4 printf(\"The answer is right.\"); else printf(\"The answer is wrong.\"); return 0;&#125; 上述代码的执行结果为： 12Number of chicken &#x3D; 23, Number of rabbits &#x3D; 12.The answer is right. 第8行的/号是除法运算符，将整数a除以整数2，虽然理论上有除不尽的可能，但除法运算的结果仍然是整数，这跟Python语言不同。所以，第8行等号左端的变量与右端的运算结果的类型都是int。C/C++的这种处理方式有助于提高目标代码的执行效率。这里的目标代码可理解为编译器编译出来的二进制机器指令。 第12行代码进行验算, ==操作符判断两边的数字是否相等，返回一个布尔型。从输出结果可以看到，验算通过，答案是正确的。 3. 语法基础本讲义系重庆大学C/C++课程的教学笔记。 作者： 陈波 chenbo@cqu.edu.cn， All rights reserved. 未经作者许可，不允许经由互联网展示或提供下载。 不允许以纸质出版为目的进行摘抄或改编。 3.1 源代码格式下述C/C++代码完全”正确“： 12345#include &lt;stdio.h&gt; int main() &#123; printf(\"Working codes, but in chaos.\"); return 0 ; &#125; 区别于Python的严格缩进语法，C/C++对语法格式的要求极低。上述程序虽然能够得到正确的执行结果，但在视觉上十分丑陋，不利于代码的维护和阅读。因此，强烈建议读者在程序设计过程中使用与本书代码类似的组织风格，示例如下： 123456#include &lt;stdio.h&gt; int main() &#123; printf(\"Working codes, but in chaos.\"); return 0;&#125; 需要说明的是，为了节约纸张，作者经常会把第4行的{上移至main()的后方。同时，为了在视觉上更好地分隔代码块，比如将一个工作过程的几个步骤分隔开，作者会添加一些空行。调整后的代码如下： 123456#include &lt;stdio.h&gt; int main() &#123; printf(\"Working codes, but in chaos.\"); return 0;&#125; 上述代码的第4行向右缩进了4个空格。书写代码时，如果需要向右缩进行，按Tab键比空格键更高效。幸运的是，大多数现代的集成开发环境都会帮助编码者缩进和优化代码显示，编码者只要不”主动“破坏，代码排列不太可能很差。 3.2 源代码符号请找出下述C语言代码的错误： 1234567#include &lt;stdio.h&gt;int main() &#123; int iNumber = 3; printf(\"There are %d stars surrounding three body planet.”, inumber）; return 0;&#125; 上述错误有至少三个错误： 第5行的变量名inumber与第4行的变量名iNumber不一致； 第5行最右端的括号是中文全角的括号，不是英文括号； printf( )的参数字符中右方的双引号是中文的双引号，不是英文双引号。 为了让读者看得更清楚，作者把修改正确的代码列在下面： 1234567#include &lt;stdio.h&gt;int main() &#123; int iNumber = 3; //\" vs ” ) vs ） printf(\"There are %d stars surrounding three body planet.\", iNumber); return 0;&#125; 请注意第4行的注释，在某些特定字体下，中文符号与英文符号很难用肉眼区分。除了注释和字符串字面量内容内部，C/C++代码不允许使用中文以及中文符号，对于初学者，建议刚开始练习时关闭中文输入法，以免意外录入中文符号。 提示： 程序设计是严谨的科学，任何微小的错误或者疏忽都可能导致失败。 3.3 操作符3.3.1 复合操作符在编程中，我们常用+、-、*、/来分别执行加、减、乘、除数学运算，用=来执行赋值操作。下述C++示例中的第6~7行代码运用了+及=运算符。若期望在进行数学运算的同时也进行赋值操作，可用复合运算符+=、-=、*=、/=来实现，如下述示例中的第11行。 123456789101112131415//Project - CompoundOperator#include &lt;iostream&gt;using namespace std;int main() &#123; int a = 3; a = a + 2; cout &lt;&lt; \"a = \" &lt;&lt; a &lt;&lt; endl; int b = 3; b += 2; //复合运算符，等价于b = b + 2 cout &lt;&lt; \"b = \" &lt;&lt; b &lt;&lt; endl; return 0;&#125; 上述代码的执行结果为： 12a &#x3D; 5b &#x3D; 5 不难看出，b += 2 就是b = b + 2的简写形式；该行执行前，b值为3，b += 2先从b取得值3，然后把3与2相加，结果为5，接下来把5赋值给b。 同理，b -= 2等价于b = b - 2；b *= 2等价于b = b * 2; b /= 2等价于b = b / 2。 3.3.2 求模操作符a % b称为a对b求模（modulus），简言之就是求a除以b的余数。下述C程序演示了求模操作符的用法： 123456789//Project - Modulus#include &lt;stdio.h&gt;int main()&#123; int a = 10; int b = a % 7; printf(\"%d is an %s number.\", b, b%2==0?\"even\":\"odd\"); return 0;&#125; 上述代码的执行结果为： 13 is an odd number. 可以看到，10 % 7，即10除以7的余数为3。通过求模运算，可以判断一个数是否能被另一个数整除。b % 2的结果如果是0，说明b能被2整数，它是一个偶数，否则为奇数。 1b%2==0?\"even\":\"odd\" 这是一个条件表达式（conditional expression），其格式为a?b:c，其中，a一般为一个逻辑判断。当a为真时，表达式返回b做为结果，否则返回c。在上述程序中，b%2==0为假，故该条件表达式的结果为”odd”，该结果字符串在输出结果中替换了占位符%s。 下述代码中的retired变量将被赋值为1，因为a &gt;= 60成立，条件表达式取冒号左边的值。 12int age = 63;int retired = age &gt;= 60 ? 1: 0; 3.3.3 比较与逻辑下述C++程序展示了C/C++中的比较及逻辑运算符： 1234567891011121314//Project - CompLogic#include &lt;iostream&gt;using namespace std;int main()&#123; int a = 10; cout &lt;&lt; \"a&gt;5: \" &lt;&lt; (a&gt;5) &lt;&lt; endl; cout &lt;&lt; \"a&lt;20 and a&gt;=10: \" &lt;&lt; (a&lt;20 &amp;&amp; a&gt;=10) &lt;&lt; endl; cout &lt;&lt; \"a==9: \" &lt;&lt; (a==9) &lt;&lt; endl; cout &lt;&lt; \"a!=3: \" &lt;&lt; (a!=3) &lt;&lt; endl; cout &lt;&lt; \"a&gt;100 or a&lt;20: \" &lt;&lt; (a&gt;100 || a&lt;20) &lt;&lt; endl; cout &lt;&lt; \"not a&gt;=10: \" &lt;&lt; (!(a&gt;=10)) &lt;&lt; endl; return 0;&#125; 上述代码的执行结果为： 123456a&gt;5: 1a&lt;20 and a&gt;&#x3D;10: 1a&#x3D;&#x3D;9: 0a!&#x3D;3: 1a&gt;100 or a&lt;20: 1not a&gt;&#x3D;10: 0 上述代码中的&gt;、&gt;=、&lt;、&lt;=与我们在小学数学中所学的用法相同。a&gt;5成立时，该表达式的值为true，否则为false。!=是==的反操作符，用于判断左右两端的值是否相等，不相等时返回true，否则返回false。第10行中的a!=3成立，返回true。当把布尔型的值输出给cout时，true被转换成1，false被转换成0。所以，输出结果中的1表示true，0表示false。 上述代码中的逻辑表达式，例如a==9，都用( )括号包裹起来了，括号用于确保括号内的表达式先进行计算，得到结果后再通过&lt;&lt;操作符输出给cout。 上述代码中还应用到下述逻辑运算符，列表如下： 表3- 逻辑运算符 运算符 说明 &amp;&amp; 逻辑与，第8行中a&lt;20为真，a&gt;=10也为真，逻辑与的结果为真 || 逻辑或，第11行中a&gt;100为假，a&lt;20为真，逻辑或的结果为真 ! 逻辑非，第12行中，a&gt;=10为真，逻辑非的结果为假 注意：逻辑与是&amp;&amp;，逻辑或是||，不是&amp;或者|。单个的&amp;和|符号在C/C++语言中具有完全不同的用途。 【? 缺 布尔运算的短路】 3.3.5 赋值操作符a = 3中的赋值（assignment）操作符除了将3传递给变量a之外，还有其它额外功能。请先看下述C语言代码： 123456789101112131415//Project - Assignment#include &lt;stdio.h&gt;int main()&#123; int a, b; a = b = 3; printf(\"a = %d, b = %d.\\n\",a,b); if (a=4) printf(\"a is equal to 4.\"); else printf(\"a is not equal to 4.\"); return 0;&#125; 上述代码的执行结果为： 12a &#x3D; 3, b &#x3D; 3.a is equal to 4. 第6行a = b = 3的执行过程如下： b = 3是一个表达式，该表达式中的赋值操作符将3赋值给变量b，同时返回整数3作为表达式的值。 a = b = 3也是一个表达式，子表达式 b = 3 的值作为右值（right value）被第1个赋值操作符赋值给变量a。 第9 ~ 12行代码的本意是判断变量b是否等于4。显然，b的值为3，代码预期应输出”a is not equal to 4.”，但实际的输出结果却是”a is equal to 4.”。问题出现在第9行，判断两个值是否相等，应使用双等号，即(a == 4)。(a=4)对于编译器而言，是完全正确的表达。这个表达式除了将4赋值给变量a之外，还会返回整数4作为表达式的值。对于if条件语句，非零即真，因此，（a=4）被视为逻辑真，第10行代码被执行。 说明：类似于上述代码第9行的错误很多初学者都犯过。在早期的编译器里，上述代码被“愉快”接受。可能是意识到第9行的写法多半是个错误，作者注意到mingw编译器会在第9行代码处给出一个警告。 3.3.6 递增与递减1a++; 此行代码中的++称为递增操作符，它完成两项任务（假设该行执行前a值为10）： 将变量a的值增加1，该行代码执行后，a值变为11； 作为一个表达式，它返回a被递增之前的值，即10，作为表达式的值。 这种置于变量之后的++操作符的执行过程可以总结为：先取值，后递增。 1++a; 此行代码中的++也是递增操作符，区别是它位于变量名之前。它也完成两项任务（假设该行执行前a值为10）： 将变量a的值增加1，该行代码执行后，a值变为11； 作为一个表达式，它返回a被递增之后的值，即11，作为表达式的值。 这种置于变量之前的++操作符的执行过程可以总结为：先递增，后取值。 1a--; --a; 同理，上述代码中的–为递减操作符，它们都将a的值减1，同时作为表达式返回一个值。区别在于，前者是先取值，后递减，后者是先递减，后取值。 下述C程序演示了递增及递减操作符的应用，请留意代码中的注释。 12345678910111213141516//Project - IncDec#include &lt;stdio.h&gt;int main()&#123; int a = 10, b, c; b = a++; //先取值，后递增，a改为11，b得递增之前的值10 c = ++a; //先递增，后取值，a改为12，c得递增之后的值12 printf(\"a = %d, b = %d, c = %d.\\n\",a,b,c); float f = 10.1f, g, h; g = f--; //先取值，后递减 h = --f; //先递减，后取值 printf(\"f = %f, g = %f, h = %f.\",f,g,h); return 0;&#125; 上述代码的执行结果为： 12a &#x3D; 12, b &#x3D; 10, c &#x3D; 12.f &#x3D; 8.100000, g &#x3D; 10.100000, h &#x3D; 8.100000. 上述代码及执行结果证实，除整数外，浮点数也可以进行递增及递减操作，效果相同。 注意：当对一个指针▲类型的对象使用递增或递减操作符时，其含义与本节的描述有显著差异。细节在后续章节中讨论。 多年的实践证明，递增和递减操作符的不恰当使用是诸多软件缺陷的来源。在那些新的编程语言比如Python里，不提供递增及递减操作符。下述C语言代码在不同的编译器里可能会有不同的执行结果： 123456789101112//Project - AmbiguousIncDec#include &lt;stdio.h&gt;int main()&#123; int n = 4; printf(\"%d - %d\\n\",n,n*n++); n = 5; printf(\"%d\",n/2+5*(1+n++)); return 0;&#125; 上述代码在作者机器（Qt Creator 4.11.0, mingw 7.3.0 64 bit）上的运行结果为： 125 - 2032 1printf(\"%d - %d\\n\",n,n*n++); 第6行：printf( )函数有三个参数，其中，参数2和参数3都使用到了n。由于C语言标准并没有规定先从参数2还是先从参数3取值，所以，不同编译器允许有不同的实现。显而易见， 先从参数3取值，再从参数2取值时，得到的n将会是加1递增之后的，反之则不同。此外，n * n++ 以号作分隔，可以分成两个部分。对a * b的乘法运算本身而言，先算a还是先算b是没有区别的。本例中，编译器可以先取\\号的左操作数n，也可以先取*号的右操作数n++，如果先取后者，则前者将取得n加1递增之后的值，反之则不同。 在作者的机器上，第6行代码中printf( )函数先从参数3取值。n * n++的表达式里，先取*号的右操作数n++，由于是先取值，后递增，故得值4；然后，再取*号的左操作数n，由于此时n已经递增，故得值5；5 * 4得到结果20。接下来，printf( )函数从参数2取值，此时n已经递增，故得值5。 1printf(\"%d\",n/2+5*(1+n++)); 第9行：同理，表达式n/2+5*(1+n++)以+号作分隔，也可以分成两个部分。+号的左操作数先取值，还是右操作数先取值，取决于编译器的具体实现。现在请读者根据输出结果32反推一下该表达式的计算顺序。 上述程序的执行结果的不确定使得程序不能容易地移植。而且，编译器版本的升级也可能会改变程序的执行结果。毕竟，编译器只要符合C/C++的标准，就是“合法”的，而C/C++的标准没有对上述计算顺序作出确切规定。 请读者遵从如下规则以避免上述问题： 一次函数调用的多个参数中出现了同一个变量，则不要对该变量应用递增或递减操作符； 一个表达式中同一个变量出现多于一次，则不要对该变量应用递增或递减操作符。 ⚠ 即便读者对C/C++的标准烂熟于胸，也要尽量避免在实际编程中不必要地使用“技巧”。因为避免掉下悬崖的最好办法不是练习高超的平衡术，而是远离悬崖。 3.3.7 逗号操作符现在讨论逗号操作符为时尚早，详见4.3.1节。 3.4 运算优先级在同一个表达式里，经常存在多个运算符。此时，运算的最终结果与运算符的顺序有关。请看如下C语言代码： 1234567891011//Project - Precedence#include &lt;stdio.h&gt;int main()&#123; int n = 3 + 2 * 6 / 3; printf(\"%d\\n\",n); n = (3 + 2) * 6 / 3; printf(\"%d\\n\",n); return 0;&#125; 上述代码的执行结果为： 12710 C/C++中四则混合运算依然遵循先乘除，后加减的规则，对于相同的优先级，例如乘法和除法，按从左往右的顺序执行。如果期望某些运算先执行，与数学中的方法类似，将这些运算用括号括起来即可，如上述代码中的第8行。 再考虑如下C语言示例： 1234567891011121314//Project - ChangePrecedence#include &lt;stdio.h&gt;int main()&#123; int r = 3 + 2 &amp;&amp; 0; printf(\"3 + 2 &amp;&amp; 0 = %d\\n\",r); r = (3 + 2) &amp;&amp; 0; printf(\"(3 + 2) &amp;&amp; 0 = %d\\n\",r); r = 3 + (2 &amp;&amp; 0); printf(\"3 + (2 &amp;&amp; 0) = %d\\n\",r); return 0;&#125; 上述代码的执行结果为： 1233 + 2 &amp;&amp; 0 &#x3D; 0(3 + 2) &amp;&amp; 0 &#x3D; 03 + (2 &amp;&amp; 0) &#x3D; 3 对于表达式 3 + 2 &amp;&amp; 0，其中有+及&amp;&amp;两个操作符。根据规定，+的优先级高于&amp;&amp;（逻辑与），故该表达式事实上等价于(3 + 2) &amp;&amp; 0。因此，第6行与第9行的输出结果相同。在该表达式中，3+2等5，逻辑与操作符将5和0作为左操作数及右操作数，5为真，0为假，结果为逻辑假。逻辑假替换printf( )中的占位符”%d”，被转换成整数输出，故结果为0。 对于表达式3 + (2 &amp;&amp; 0)，由于括号的存在， 2 &amp;&amp; 0先计算，2为真，0为假，2 &amp;&amp; 0为假。显然，编译器无法把整数3与逻辑假相加，所以编译器选择先将逻辑假转换成整数，其值为0，3 + 0等于3，故第12行的输出结果为3。 当读者读到3 + 2 &amp;&amp; 0时，多半是不知道+的优先级是高于&amp;&amp;的，作者也不知道。C/C++有着数量众多的操作符，全部的操作符及其优先级可以列出一个长长的表格。试图记忆这些操作符的优先级是徒劳的，因为会忘。所以，本书选择不提供这个优先级列表，而是慎重建议：在凡是存在优先级疑惑的表达式里，使用括号消除疑惑。如上述代码的第8行及第11行。这样做，无论是写代码的还是读代码的，都放心。 3.5 隐式类型转换在下述三种情况下，C/C++会进行隐式类型转换（implicit type cast）： 变量初始化或者赋值时，值与变量的类型不同； 表达式中不同类型的变量/值进行运算时； 函数参数传递▲时。 3.5.1 赋值/变量初始化我们通过对下述C++程序及其执行结果的分析来解释赋值/变量初始化时的隐式类型转换及其影响： 1234567891011121314151617//Project - AssignType#include &lt;iostream&gt;using namespace std;int main()&#123; bool a = 3.0; //转换为bool类型：0为false，非0为true float b = -99999.2301; //double转float，精度降低，可能超出储值范围 int c = b; //float转int, 小数部分丢失，可能超出储值范围 unsigned int d = c; //int转unsigned int，负值被错误解释 short e = d; //unsigned int转short，可能超出储值范围 double f = b; //float转double，安全 cout.setf(ios_base::fixed, ios_base::floatfield); cout &lt;&lt; \"a = \" &lt;&lt; a &lt;&lt; \"\\nb = \" &lt;&lt; b &lt;&lt; \"\\nc = \" &lt;&lt; c &lt;&lt; \"\\nd = \" &lt;&lt; d &lt;&lt; \"\\ne = \" &lt;&lt; e &lt;&lt; \"\\nf = \" &lt;&lt; f; return 0;&#125; 上述代码的执行结果为： 123456a &#x3D; 1b &#x3D; -99999.226562c &#x3D; -99999d &#x3D; 4294867297e &#x3D; 31073f &#x3D; -99999.226562 1bool a = 3.0; //转换为bool类型：0为false，非0为true 第6行：任意值赋值给布尔型变量，按非零即真原则，0值转换为false, 非零转换为true。double类型的字面量3.0赋值给布尔类型的变量a，被转换成true。true输出给cout，结果为1。 1float b = -99999.2301; //double转float，精度降低，可能超出储值范围 第7行：double转换为float时，可能发生精度损失。因为double类型对象由64个比特组成，而float类型只有32个比特。如果double类型的值超过float的储值范围，转换结果将是不确定的。本行进行了此类转换，可以看到转换后的float类型变量b丢失了精度（值不等于-99999.2301）。如果把b的类型改为double，将更可能保持精度。 1int c = b; //float转int, 小数部分丢失，可能超出储值范围 第8行：float转换为int时，小数部分丢失。当储值范围超出时，结果不确定。输出结果证实，这种转换只保留了整数部分-99999。 1unsigned int d = c; //int转unsigned int，负值被错误解释 第9行：int（有符号）转换为unsigned int时，如果原值为负数，则结果不确定，因为无符号整数只能存储非负值。输出结果中，可以看到c值-99999被错误转换成了4294867297。 1short e = d; //unsigned int转short，可能超出储值范围 第10行：unsigned int转成short（有符号），是从32位无符号整数到16位有符号整数的转换，如果超出储值范围，则结果不确定。输出结果中，可以看到无符号整数d值4294867297被错误转换成了有符号短整数31073。 1double f = b; //float转double，安全 第11行：float转换为double则是安全的，因为double的储值范围更大，精度也更高。输出结果证实，double类型变量f完美复制了float类型变量b的值。同理，short到int，int到long long也是安全的。 1cout.setf(ios_base::fixed, ios_base::floatfield); 第13行：对cout输出浮点数的格式进行了设置：按定点小数（相对于科学计算法）输出，保留6位小数。具体细节本书略过不提，因为实践中的应用程序，较少使用cout以及相关的控制台界面。 将储值范围和精度较低的对象赋值给储值范围更大，精度更高的对象是安全的，反之则不然。程序员应尽量避免将储值范围大/精度高的对象赋值给储值范围小/精度低的对象。如果因为某些原因不得不这么做，则需要反复确认两件事： 精度的损失在可接受范围内； 源对象的值不会超过目标对象的储值范围。 使用列表初始化（list initialization） 【C++ 11】可以避免变量初始化过程中不恰当的隐式类型转换所带来的差错。如下述C++代码所示： 12345678910111213//Project - ListInit#include &lt;iostream&gt;using namespace std;int main()&#123; char c = 712; //允许，但会溢出 char d &#123;66&#125;; //允许，66在char的储值范围内 char e &#123;712&#125;; //不允许，712超过char的储值范围 unsigned int f &#123;-1&#125;; //不允许，unsigned int只能存非负整数 int g &#123;3.12&#125;; //不允许，收窄会导致精度丢失 return 0;&#125; 与传统的赋值初始化不同，列表初始化不允许收窄（narrowing）,即：当被初始化的变量无法准确表达{ }内的字面量或者常量▲时，编译器会报错，拒绝编译。 1char c = 712; //允许，但会溢出 第6行：char类型对象c只有8个比特的存储空间，由于是有符号字符，其储值范围为-128 ~ +127。显然，字面量712超过了c的储值范围。但由于这是传统的赋值初始化，编译器将放任这种情况的发生，至多给出一个警告。 1char d &#123;66&#125;; //允许，66在char的储值范围内 第7行：字面量66在d的储值范围内，该行代码会被编译器所接受。 123char e &#123;712&#125;; //不允许，712超过char的储值范围unsigned int f &#123;-1&#125;; //不允许，unsigned int只能存非负整数int g &#123;3.12&#125;; //不允许，收窄会导致精度丢失 第8 ~ 10行的变量不能准确表达{ }内的字面量，编译器将报错拒绝。 3.5.2 表达式在表达式a/b中，a，b称为操作数（operand），/称为操作符（operator）。当算术运算发生时，如果参与运算的操作符具有不同的类型，则编译器会生成额外的代码将其转变成相同的类型后再进行运算。因为，绝大多数的CPU指令集均只支持同类型对象之间的算术运算，比如两个有符号32位整数之间的运算。显然，算术运算的结果类型也受上述操作数类型转换的影响。 下述C++代码以除法运算为例，研究算术运算过程中的类型转换过程： 123456789101112131415161718192021222324252627//Project - DivisionOperator#include &lt;iostream&gt;using namespace std;int main()&#123; int i = 3; //有符号整数 auto a = 10 / i; //整数 / 整数 = 整数 cout &lt;&lt; \"10/3 = \" &lt;&lt; a &lt;&lt; \", type = \" &lt;&lt; typeid(a).name() &lt;&lt; endl; auto b = double(10.0) / i; //浮点数 / 整数 = 浮点数 cout &lt;&lt; \"10.0/3 = \" &lt;&lt; b &lt;&lt; \", type = \" &lt;&lt; typeid(b).name() &lt;&lt; endl; auto c = i / double(10.0); //整数 / 浮点数 = 浮点数 cout &lt;&lt; \"3/10.0 = \" &lt;&lt; c &lt;&lt; \", type = \" &lt;&lt; typeid(c).name() &lt;&lt; endl; auto d = double(10.0) / 3.0f; //双精度浮点数 / 单精度浮点数 = 双精度浮点数 cout &lt;&lt; \"10.0/3.0f = \" &lt;&lt; d &lt;&lt; \", type = \" &lt;&lt; typeid(d).name() &lt;&lt; endl; auto e = (unsigned int)10 / i; //无符号整数 / 有符号整数 = 无符号整数 cout &lt;&lt; \"unsigned 10/3 = \" &lt;&lt; e &lt;&lt; \", type = \" &lt;&lt; typeid(e).name() &lt;&lt; endl; auto f = 10 / (unsigned int)3; //有符号整数 / 无符号整数 = 无符号整数 cout &lt;&lt; \"10/unsigned 3 = \" &lt;&lt; f &lt;&lt; \", type = \" &lt;&lt; typeid(f).name() &lt;&lt; endl; return 0;&#125; 上述代码的执行结果为： 12345610&#x2F;3 &#x3D; 3, type &#x3D; i10.0&#x2F;3 &#x3D; 3.33333, type &#x3D; d3&#x2F;10.0 &#x3D; 0.3, type &#x3D; d10.0&#x2F;3.0f &#x3D; 3.33333, type &#x3D; dunsigned 10&#x2F;3 &#x3D; 3, type &#x3D; j10&#x2F;unsigned 3 &#x3D; 3, type &#x3D; j 1int i = 3; //有符号整数 第6行：为了便于解释， 此处显式定义了一个值为3的整数i，根据前述章节的描述，它事实上是一个有符号整数 （signed int）。接下来的代码里，我们使用auto【C++ 11】来推断商的结果类型，并使用typeid( )操作符及其name成员函数▲将商的类型打印出来。 12auto a = 10 / i; //整数 / 整数 = 整数cout &lt;&lt; \"10/3 = \" &lt;&lt; a &lt;&lt; \", type = \" &lt;&lt; typeid(a).name() &lt;&lt; endl; 第8 ~ 9行：输出结果证实，整数/整数的结果类型为整数，商的小数部分被舍弃。请学习过Python语言的读者注意，这与Python语言不同。 12auto b = double(10.0) / i; //浮点数 / 整数 = 浮点数cout &lt;&lt; \"10.0/3 = \" &lt;&lt; b &lt;&lt; \", type = \" &lt;&lt; typeid(b).name() &lt;&lt; endl; 第11 ~ 12行：输出结果证实，浮点数/整数的结果类型为浮点数，此处的浮点数类型为double。请读者注意，字面量10.0的类型也是double。作者在这里有意写成double(10.0)，通过一个显式的double类型构造函数▲将10.0“转换”成一个double，是因为担心读者无法正确识别10.0字面量的类型而产生疑惑。 12auto c = i / double(10.0); //整数 / 浮点数 = 浮点数cout &lt;&lt; \"3/10.0 = \" &lt;&lt; c &lt;&lt; \", type = \" &lt;&lt; typeid(c).name() &lt;&lt; endl; 第14行：输出结果证实，整数/浮点数的结果类型为浮点数。 12auto d = double(10.0) / 3.0f; //双精度浮点数 / 单精度浮点数 = 双精度浮点数cout &lt;&lt; \"10.0/3.0f = \" &lt;&lt; d &lt;&lt; \", type = \" &lt;&lt; typeid(d).name() &lt;&lt; endl; 第17 ~ 18行：输出结果证实，双精度浮点数/单精度浮点数的结果类型为双精度浮点数。3.0f中的后缀f表明该字面量为float类型。 12345auto e = (unsigned int)10 / i; //无符号整数 / 有符号整数 = 无符号整数cout &lt;&lt; \"unsigned 10/3 = \" &lt;&lt; e &lt;&lt; \", type = \" &lt;&lt; typeid(e).name() &lt;&lt; endl;auto f = 10 / (unsigned int)3; //有符号整数 / 无符号整数 = 无符号整数cout &lt;&lt; \"10/unsigned 3 = \" &lt;&lt; f &lt;&lt; \", type = \" &lt;&lt; typeid(f).name() &lt;&lt; endl; 第20 ~ 24行：输出结果证实，有符号整数与无符号整数进行除法运算的结果为无符号整数。输出结果type = j中的j指无符号整数。 1auto b = double(10.0) / i; //浮点数 / 整数 = 浮点数 当表达式中两种不同类型的对象进行算术运算时，编译器总是将较小的类型转换为较大的类型再进行计算。第11行中，一个double除以一个int，编译器会先将整数i转换成double，再进行除法运算。两个double相除，其结果自然是double。 需要注意的是，这种形式的隐式类型转换只是创建一个被转换对象的副本，不会改变被转换对象自身。比如第11行的i被转成double，编译器只是创建了一个double类型的用完即弃的临时对象，其值与i相同。第11行代码执行完后，对象i不会有任何变化。 3.6 显式类型转换有的编译器会对有风险的隐式类型转换给出警告。程序员可以通过显示类型转换（explicit type cast）告知编译器，这些转换是有意为之且经过复核的。请阅读下述C++代码： 123456789101112//Project - TypeCast#include &lt;iostream&gt;using namespace std;int main()&#123; char c = 'K'; cout &lt;&lt; \"c = \" &lt;&lt; c &lt;&lt; endl; cout &lt;&lt; \"ASCII code for 'K': \" &lt;&lt; (int)c &lt;&lt; endl; cout &lt;&lt; \"ASCII code for 'K': \" &lt;&lt; int(c) &lt;&lt; endl; cout &lt;&lt; \"ASCII code for 'K': \" &lt;&lt; static_cast&lt;int&gt;(c) &lt;&lt; endl; return 0;&#125; 上述代码的执行结果为： 1234c &#x3D; KASCII code for &#39;K&#39;: 75ASCII code for &#39;K&#39;: 75ASCII code for &#39;K&#39;: 75 1cout &lt;&lt; \"c = \" &lt;&lt; c &lt;&lt; endl; 第7行：直接把char c输出给cout，会得到字符K。 1cout &lt;&lt; \"ASCII code for 'K': \" &lt;&lt; (int)c &lt;&lt; endl; 第8行：(int)c将c对象显示类型转换为int，然后再输出给cout，得到K的ASCII码值75。这种转换形式是C语言的语法，其通用格式为： 1(目标类型名)值 1cout &lt;&lt; \"ASCII code for 'K': \" &lt;&lt; int(c) &lt;&lt; endl; 第9行：int(c)是C++的类型转换格式。从面向对象的观点看来，它像是执行int类型的构造函数▲，从参数创建一个int类型的对象。其通用格式为： 1目标类型名(值) 1cout &lt;&lt; \"ASCII code for 'K': \" &lt;&lt; static_cast&lt;int&gt;(c) &lt;&lt; endl; 第10行：C++认为C语言形式的类型转换没有进行恰当的合法性检查，存在较大风险。因此，C++额外定义了4种强制类型转换操作符，代码中的static_cast&lt;int&gt;(c)是其中一种。另外三种将在后续章节中详细讨论。static_cast操作符的通用格式为： 1static_cast&lt;目标类型名&gt;(值) 3.7 使用函数前述章节中我们多次用到的printf( )就是一个函数。函数接受用户提供的0个或多个参数，执行特定任务后返回运行结果。除了printf()函数之外，C/C++的标准库提供了数量众多的函数供我们使用。请阅读下述C语言示例： 123456789101112131415161718192021//Project - UseFunc#include &lt;stdio.h&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;int main()&#123; double x = 2, y = 8; printf(\"2^8 = %f\\n\", pow(x,y)); //x的y次方 printf(\"round(25.51) = %f\\n\", round(25.51)); //四舍五入 printf(\"floor(25.997) = %f\\n\",floor(25.997));//下取整 printf(\"ceil(25.01) = %f\\n\", ceil(25.01)); //上取整 printf(\"sqrt(5) = %f\\n\",sqrt(5)); //平方根 int r0 = rand(); //0 ~ RAND_MAX之间的随机整数 int r1 = rand() % 100; //0 ~ 99之间的随机数 double r2 = 0.1 + 0.1*rand()/RAND_MAX; //0.1 ~ 0.2之间的随机浮点数 printf(\"r0 - %d, r1 - %d, r2 - %f\\n\",r0,r1,r2); printf(\"RAND_MAX = %x\",RAND_MAX); return 0;&#125; 上述代码的执行结果为： 12345672^8 &#x3D; 256.000000round(25.51) &#x3D; 26.000000floor(25.997) &#x3D; 25.000000ceil(25.01) &#x3D; 26.000000sqrt(5) &#x3D; 2.236068r0 - 41, r1 - 67, r2 - 0.119330RAND_MAX &#x3D; 7fff 说明：因为随机数的存在以及开发环境的差异，读者机器上的运行结果的第6 ~ 7行可能与作者的结果不同。 第3 ~ 4行：math.h头文件引入了C语言的数学函数库，stdlib.h头文件引入了rand( )函数及其相关的RAND_MAX常量。下表总结了本例中使用到的库函数。 表3- UseFunc项目中的函数 函数 说明 pow(x,y) 计算x的y次方，x,y以及返回值都是double类型。 round(x) 计算x的四舍五入值，x以及返回值都是double类型。如果期望获得int类型的结果，则需要进行类型转换。 floor(x) 计算x的下取整，x以及返回值都是double类型。同上，如果期望获得整型结果，需要类型转换。注意25.997的下取整结果是25.0。 ceil(x) 计算x的上取整，x以及返回值都是double类型。同上，可以通过类型转换获得整型结果。注意25.01的上取整结果是26.0。 sqrt(x) 计算x的平方根。x以及返回值都是double类型。 rand( ) 生成0 ~ RAND_MAX之间的伪随机整数（pseudo-random integral number）。RAND_MAX是由stdlib.h头文件引入的常量▲，在作者的开发环境中，其值为0x7fff，即短整型（signed short）所能存储的最大正数。 说明：在C++的标准库里，上述函数可能存在多个函数名重载▲版本。对C++而言，表中关函数的参数及返回值类型可能不够准确。 读者可能期望round( )、floor( )、ceil( )等函数返回一个整数类型的结果，但事实上不是。在多数集成开发环境里，都会给出函数的原型以提示函数的参数个数，类型以及返回值类型。在图3- 中可以看到round( )函数接受一个double类型的参数，返回一个double。数学上，读者会期望四舍五入的结果是整数，为达到该目的，可以通过下述格式进行类型转换：(int)round(25.51)。 图3- 集成开发环境的提示 1int r1 = rand() % 100; //0 ~ 99之间的随机数 第15行：将rand( )函数的返回值对100求模，即可得取值范围为0 ~ 99的随机整数。 1double r2 = 0.1 + 0.1*rand()/RAND_MAX; //0.1 ~ 0.2之间的随机浮点数 第16行：将rand( )函数的返回值 / RAND_MAX，可得取值范围为 0 ~ 1的随机浮点数，该浮点数乘以0.1，可得取值范围为0 ~ 0.1的随机浮点数，再加上0.1，即得取值范围为0.1 ~ 0.2的随机浮点数。 简单地总结，使用C/C++的某些库函数或者第三方库函数，需要这样几个步骤： 查询文档及资料，了解函数的定义及包含它的头文件的名称。 通过#include预处理指令包含相应的头文件，有些时候，还需要在编译时链接相应的库文件（扩展名可能为lib、DLL或者so）▲。 在代码中调用该函数。 微实践 - 地球时间现代计算机内部均安装有RTC(Real Time Clock)芯片或者其CPU具备RTC功能。 RTC芯片内部有一个计数器，通常用于记录从GMT时间（格林尼治时间）1970年1月1日零时起，总共流逝的Tick(滴答)个数。RTC芯片会按照固定的节拍增加这个计数器的值，以达到计时的目的。至于一个Tick是何种精度，则取决于计算机的工作频率及RTC的能力，大部分都在微秒级。RTC芯片工作是需要消耗电能的，那么计算机断电时计时会停止吗？ 不会，读者可以在自己的计算机主板甚至手机主板上找到用于给RTC供电的纽扣锂电池。 有的读者可能还会想到，北京和东京分处不同时区，计算机显示日期时间时是否还需进行时区转换呢？是的，在操作系统中可以设置时区，设置完成后，操作系统会自动完成从RTC内部计数器计数值到特定时区的时间转换。顺便提一句，现代计算机大部分会连网，在连上Internet时，操作系统很可能会自动从网上刷新时间，以消除RTC的计时误差。 下述C程序获取并打印了系统当前的格林尼治时间，以及自1970年1月1日零时起至现在，总共流逝的秒数。 12345678910111213141516171819202122232425//Project - EarthTime#include &lt;stdio.h&gt;#include &lt;time.h&gt;int main() &#123; time_t t; time(&amp;t); //获取当前时间,从1970年1月1日零时起经过的秒数 long long totalSeconds = (long long)t; //总秒数转换为long long类型 long long curSecond = totalSeconds % 60; //当前秒数 = 总秒数对60取余 long long totalMinutes = totalSeconds / 60; //总分钟 = 总秒数除60 long long curMinute = totalMinutes % 60; //当前分钟 = 总分钟对60取余 long long totalHours = totalMinutes / 60; //总小时 = 总分钟除60 long long curHour = totalHours % 24; //当前小时 = 总小时对24取余 printf(\"格林尼治时间 %lld 时 %lld 分 %lld 秒,1970年1月1日零时到现在经过了 %lld 秒.\", curHour,curMinute,curSecond,totalSeconds); /* printf的英文版本 printf(\"%lld:%lld:%lld, %lld seconds after 1970/1/1 00:00::00\", curHour,curMinute,curSecond,totalSeconds); */ return 0;&#125; 执行结果 1格林尼治时间 6 时 50 分 54 秒,1970年1月1日零时到现在经过了 1581835854 秒. 第3行：time.h引入了time( )函数及time_t类型。在作者的开发环境里，time_t事实上是long long类型，表示自1970年1月1日零时起到现在经过了多少秒。 1time(&amp;t) 这行代码涉及以后要学习的知识。可简单理解为：将t的地址传递给函数，让time( )函数的执行部分把从RTC获取的值存在t变量里。 获得t之后，我们先将其转换成long long类型的总数秒（totalSeconds），然后借助于求模和整数除法，计算出当前的小时、分钟和秒数。 12printf(\"格林尼治时间 %lld 时 %lld 分 %lld 秒,1970年1月1日零时到现在经过了 %lld 秒.\", curHour,curMinute,curSecond,totalSeconds); 第16 ~ 17行：%lld表示输出long long类型的整数，如果写成%d，则该行代码需要隐式地将long long类的值转换成int型，再输出，可能因超范围而出错。 中文输出问题：第16行的输出使用了中文，在某些开发环境的默认配置下，控制台输出中文可能会乱码。此时，读者可以使用第20行的英文输出版本。 扩展阅读📕 Windows控制台环境下Qt Creator的中文输出。 https://codelearn.club/2020/02/qtconsolechinese/ 读者可能觉得上述计算过程非常麻烦。事实上，这只是为了找一个题目给读者练习取模及除法操作符。对这些常见的问题，C/C++肯定有更快更好的解决方案，该问题也可用下述C程序解决▲。 12345678910111213141516//Project - LocalTime#include &lt;stdio.h&gt;#include &lt;time.h&gt;int main() &#123; time_t t; struct tm * timeInfo; time(&amp;t); timeInfo = localtime(&amp;t); //从t转换出本地日期时间 printf(\"%d-%d-%d %d:%d:%d\",1900+timeInfo-&gt;tm_year,timeInfo-&gt;tm_mon, timeInfo-&gt;tm_mday,timeInfo-&gt;tm_hour,timeInfo-&gt;tm_min,timeInfo-&gt;tm_sec); return 0;&#125; 执行结果 12020-1-16 15:3:29 这段程序超出读者当前的知识背景。跟这段程序有关的知识会在后续章节中逐步讨论。 3.8 自定义函数C/C++提供的库函数并不能满足我们的全部需要。此时，我们可以自定义函数。请先阅读下述C语言代码： 12345678910111213141516171819//Project - DefFunc#include &lt;stdio.h&gt;//电费计算: (期末读数 - 期初读数) * 单价float costCompute(int iStart, int iEnd)&#123; int iConsume = iEnd - iStart; return iConsume * 0.85f;&#125;int main()&#123; float fElecFee1 = costCompute(1201,1786); printf(\"Electronic Power Cost of Mr Zhang: %.2f\\n\", fElecFee1); float fElecFee2 = costCompute(1322,1423); printf(\"Electronic Power Cost of Mr Lee: %.2f\", fElecFee2); return 0;&#125; 上述代码的执行结果为： 12Electronic Power Cost of Mr Zhang: 497.25Electronic Power Cost of Mr Lee: 85.85 第5 ~ 9行定义了一个名为costCompute的电费计算函数。由于是用户自己定义的，故称为自定义函数（user defined function）。该函数结构如下图所示。 图3- costCompute函数的结构 costCompute是函数名，函数名后的括号里是以逗号分隔的形式参数列表。函数接受0至多个形式参数作为输入，当形参的数量为0时，包含形参列表的括号可以为空。{ }内的部分为函数体（function body），函数体内的代码为函数的实际执行部分。这个部分通常会使用形参进行一些计算或者处理，然后通过return语句返回一个值。 costCompute函数的返回值类型为float，这意味着，该函数的函数体必须使用return语句返回一个float类型的对象。当一个函数没有返回值时，其返回值类型用void代替。此时，其函数体内的如果有return语句的话，只能是： 1return; 这表示不带返回值的”返回“。 1int iConsume = iEnd - iStart; 第7行：用期末读数（iEnd）减去期初读数（iStart），得到当月用电度数（iConsume）。 1return iConsume * 0.85f; 第8行：用电度数与0.85f的单价相乘，然后用return语句返回。 函数的定义起到向编译器介绍函数的作用，它并不会导致函数的执行。上述代码中的第12行、第15行两次调用执行了该函数。 图3- 函数调用 我们借助于图3- 来解释函数调用过程。 ① CPU依次执行函数调用前的代码。 ② 函数调用点，跳转至函数执行。本例中，跳转过程伴随参数传递，1322传递给了iStart，1423传递给了iEnd。 ③ 函数体内的代码依次执行。 ④ 执行到函数体内的return语句，从函数跳转回调用点。本例中，跳转过程”携带“着函数的返回值，该值作为赋值操作符的右值被传递给了fElecFee2变量。 ⑤ CPU继续执行函数调用后的代码。 可以看出，一个函数可以一次定义，多次执行，每次执行时可传递不同的参数。本例中出现在函数定义中的参数iStart，iEnd称为形式参数，简称形参，函数调用过程中实际提供的参数，如1322，称为实际参数，简称实参。 为什么要定义这么一个简单的函数直接用fElecFee = (1786-1201)*0.85难道不是更简单么？ 不，适时的舍简求繁实际是删繁就简！- costCompute被抽象成函数以后，读者一看便知这个函数是在计算费用，程序可读性好。- 如果有一天要实施阶梯电价或者电价变更，用户只需修改costCompute函数即可完成升级；如果使用直接计算的方案，假设在程序当中有n处电费计算的话，就需要修改n处，如果遗漏了一处，就是程序缺陷，即我们所熟知的Bug。 3.9 地址程序中的每个变量/对象，都会占据存储空间。而存储空间，是有地址（address）的。下述C语言程序演示了如何获得并打印对象的地址。 1234567891011//Project - GetAddr#include &lt;stdio.h&gt;int main()&#123; int i = 1, j = 2; char c = 'c'; long double ld = 0.0; printf(\"&amp;i=%p, &amp;j=%p, &amp;c=%p, &amp;ld=%p\",&amp;i,&amp;j,&amp;c,&amp;ld); return 0;&#125; 上述代码的执行结果为： 1&amp;i&#x3D;000000000061FE1C, &amp;j&#x3D;000000000061FE18, &amp;c&#x3D;000000000061FE17, &amp;ld&#x3D;000000000061FE00 注意：读者在自己计算机上的运行结果不太可能与上述结果相同。计算机上的内存分配是一个受诸多因素影响的复杂过程，这些因素包括硬件差异、操作系统与编译器版本、当前计算机的内存占用情况等。 表达式&amp;a表示获取a对象在内存中的存储地址。该表达式中的&amp;操作符仅有一个操作数（operand），即对象a。printf( )中的占符符%p表示输出一个指针▲，也就是地址。显然，这个被输出的地址是以十六进制显示的。 上述输出结果中，i的地址是0x000000000061FE1C，这说明变对象i存储在地址0x000000000061FE1C开始的连续4个字节的存储空间内。 根据上述输出，作者绘制了如下的内存地图。 图3- 内存地图 从图中可以看到，对象i，j，c，ld按定义顺序从高地址往低地址顺序分配存储空间。其中，i,j各占4个字节，ld占16个字节。比较令人费解是字符c，它事实上只占据地址为0x000000000061FE17的1个字节的空间，程序却事实上为其留出了8个字节的连续空间，并将其余7个字节的空间空置。这是编译器数据对齐（data alignment）的结果，作者的计算机是64位，即计算机一个指令可以处理的的最大数据量是8个字节。编译器在分配空间时，会“尽量”以8个字节为”单位”。 再次说明，最终的内存分配结果与编译器、计算机、操作系统紧密相关。在读者的实际计算机上，所看到的情况不太可能与上述内存地图完全一致。 3.10 获取用户输入3.10.1 CC语言控制台应用中获取用户输入主要靠scanf( )函数，示例如下： 1234567891011121314151617181920//Project - CInput#include &lt;stdio.h&gt;#include &lt;math.h&gt;int main() &#123; int iAge = 0,iHeight = 0; float fWeight = 0; printf(\"Please input your age, weight(kg):\\n\"); scanf(\"%d,%f\",&amp;iAge,&amp;fWeight); printf(\"Please input your height(cm):\\n\"); scanf(\"%d\",&amp;iHeight); float fBMI = fWeight / pow((iHeight/100.0),2); printf(\"Age = %d, Weight(kg) = %.2f, Height(cm) = %d, BMI = %.2f\", iAge,fWeight,iHeight,fBMI); return 0;&#125; 上述代码的执行结果为： 12345Please input your age, weight(kg):17,52.53Please input your height(cm):170Age &#x3D; 17, Weight(kg) &#x3D; 52.53, Height(cm) &#x3D; 170, BMI &#x3D; 18.18 说明：执行结果中的第2行，第4行需要操作者输入。输入时请注意格式，输入值不同，输出结果也会不同。 scanf( )函数用于从控制台读取操作者的键盘输入，其格式与printf( )有相似之处。它可以接受多个参数，其中第1个预期为字符串，字符串中可包含1个或者多个占位符。占位符的个数、类型以及顺序应与后续其它参数相匹配。请注意，后续其它参数通过&amp;符号取地址，事实上传递给scanf( )函数的是变量的地址。其中，占位符指定了期望获得的输入的类型和格式，地址参数则用于说明获得输入后将值传递给哪个变量。 1scanf(\"%d,%f\",&amp;iAge,&amp;fWeight); 第10行：一种形象解释是，老板，订两份外卖，一份卤肉饭（%d），一份鸡汤面（%f）。送过来后，卤肉饭放2号楼门口（&amp;iAge），鸡汤面交给小区门岗（&amp;fWeight）。需要注意的是，本行代码的格式字符串中包含了一个逗号，意即整数和浮点数之间用逗号作分隔。输入时必须录入上述逗号。 123float fBMI = fWeight / pow((iHeight/100.0),2);printf(\"Age = %d, Weight(kg) = %.2f, Height(cm) = %d, BMI = %.2f\", iAge,fWeight,iHeight,fBMI); 第15 ~ 17行：计算并打印了人体质量指数（Body Mass Index），其值为体重（千克）除以身高（米）的平方。 3.10.2 C++C++语言控制台应用中获取用户输入主要靠cin对象来进行。cin由iostream头文件引入，指控制台输入流（console input stream）,其类型为istream。我们使用cin和cout实现了与上节程序功能相同的C++代码，如下： 123456789101112131415161718192021//Project - CppInput#include &lt;iostream&gt;#include &lt;math.h&gt;using namespace std;int main() &#123; int iAge &#123;&#125;, iHeight &#123;&#125;; float fWeight &#123;&#125;; cout &lt;&lt; \"Please input your age, weight(kg):\" &lt;&lt; endl; cin &gt;&gt; iAge &gt;&gt; fWeight; cout &lt;&lt; \"Please input your height(cm):\\n\"; cin &gt;&gt; iHeight; float fBMI = fWeight / pow((iHeight/100.0),2); cout &lt;&lt; \"Age = \" &lt;&lt; iAge &lt;&lt; \", Weight(kg) = \" &lt;&lt; fWeight &lt;&lt; \", Height(cm) = \" &lt;&lt; iHeight &lt;&lt; \", BMI = \" &lt;&lt; fBMI; return 0;&#125; 上述代码的执行结果为： 12345Please input your age, weight(kg):52 102.24Please input your height(cm):168Age &#x3D; 52, Weight(kg) &#x3D; 102.24, Height(cm) &#x3D; 168, BMI &#x3D; 36.2245 说明：执行结果中的第2行，第4行需要操作者输入。请注意第2行的两个数之间用空格作分隔。 1cin &gt;&gt; iAge &gt;&gt; fWeight; 这行代码从控制台依次接受两个变量输入，默认以空格作分隔。请注意与cin配用的&gt;&gt;操作符和与cout配用的&lt;&lt;操作符方向相反。关于这行代码背后的工作原理，我们要到本书的后半部分才能讲得清楚。当前阶段，读者参照使用即可。 3.11 常量常量（constant）是相对于变量而言的。变量的值可以在程序运行过程中反复修改，但常量不允许修改，为固定值。C/C++中，有两种定义常量的方法，请见下述C语言示例： 1234567891011121314//Program - Constant#include &lt;stdio.h&gt;#define PI 3.1415926int main()&#123; float r = 2; const float CPI = 3.1415926f; //CPI = 4; //常量不能修改 printf(\"Area of circle = %.2f\\n\", PI*r*r); printf(\"Area of circle = %.2f\", CPI*r*r); return 0;&#125; 上述代码的执行结果为： 12Area of circle &#x3D; 12.57Area of circle &#x3D; 12.57 1#define PI 3.1415926 第4行：使用预处理指令#define定义了常量PI, 其值为3.1415926。在编译器开始编译前，预处理器▲会将程序中的PI替换为3.1415926。 1const float CPI = 3.1415926f; 第8行：在类型名前加上const修饰，表明CPI是类型为float的常量，其值为3.1415926。常量定义时，可以提供初始值，但定义之后，便不可修改。 1//CPI = 4; //常量不能修改 第9行：如果试图修改常量，编译器会拒绝。 相对于预处理指令定义的PI，作者更建议使用const修饰符来定义常量，因为后者定义的常量有明确的类型。除非必要，编译器不会为常量分配存储空间以节约资源。 3.12 注释注释是程序员写给明天的自己或者同事看的，解释器执行时会自动忽略注释。 1234567891011121314/*The following program was written by Alex, all rights reserved.I hope that this book can lead you into the fantastic world of programming.Loving Alex chenbo@cqu.edu.cn*///stdio.h introduced printf function to this file#include &lt;stdio.h&gt;int main()&#123; printf(\"Hello World!\\n\"); return 0;&#125; 单行注释以//打头；多行注释则用/* /包裹。在代码中书写*简洁、有意义的注释**十分重要 微实践 - 哈利波特之心灵感应哈利波特之心灵感应魔法是一种常见的儿童益智游戏。表演者首先会要求观众在心中默想一个60以内的整数，然后依次将下述卡片1到卡片6出示给观众看，并询问观众他所默想的数字是否在卡片上。在卡片出示的过程中，卡片是背对表演者的，即表演者是看不到卡片的。在听完观众的6个回答之后，表演者即可＂猜＂出观众默想的数字，仿佛掌握了＂读心术＂。 表演者显然没有＂读心术＂, 他依赖于观众关于数字在不在卡片上的6个回答来计算答案。解题思路与二进制有关。一个6位的二进制数，其可以表达的最大数字是26 - 1 = 63。所以，任意60以内的整数，都可以用不超过6位的二进制数来表达。比如，41，其二进制值如下表所示： 表3- 41的二进制表示 我们以十进制整数(4321)₁₀来说明表3- 中的位号、位值及位权。位值1、2、3、4从低到高，分别处于位号1（个位）到位号4（千位）。而(4321)₁₀ = 4 ⅹ10³ + 3ⅹ10²+2ⅹ10¹+1ⅹ10⁰，这里的10³为位号4的位权，10⁰为位号1的位权。同理，(41)₁₀=(101001)₂中，位号6处的位值为1，其对应的位权为2⁵=32；位号2处的位值为0，其对应的位权为2¹=2。 每一个60以内的整数，均可转换成一个6位二进制数。如果对应的二进制数的第1位（最低位）为1，该数包括在卡片1中，同理，二进制第2位为1的数包括在卡片2中，… 二进制第6位为1的数包括在卡片6中。上述数字41，其二进制的第1， 4， 6位为1。读者可以看到，41只出现在卡片1，4，6中，卡片2，3，5里没有41。所以，观众每回答一个按顺序给出的问题，其实就告诉了表演者该数字6位二进制数中的其中一位是0还是1。 我们用数字58来模拟一下。卡片1，3里没有58，卡片2，4，5，6里有58。所以表演者从观众那里得到的6个回答依次是：无，有，无，有，有 ，有。将上述回答换成二进制就是111010。按照对应的位权把0b111010换成十进制就是32+16+8+2 = 58。 现在我们知道表演者是如何表演的了。他一直在做加法，从0值开始。如果卡片1的回答是有，加1，卡片2的回答是有，加2，卡片3有，加4，… ， 卡片6有，加32。最后直接报出和数即可。 读者可以运行下述C++程序才模拟执行上述游戏过程：心里先默想一个数，然后运行程序，通过输入y或者n来回答6个问题。看看计算机能否猜出你默想的数，是否跟你有心灵感应。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//Project - NumMagic#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() &#123; string sCard1 = \"Card 1:\\n \\ 1 11 21 31 41 51\\n \\ 3 13 23 33 43 53\\n \\ 5 15 25 35 45 55\\n \\ 7 17 27 37 47 57\\n \\ 9 19 29 39 49 59\\n\"; ... string sCard6 = \"Card 6:\\n \\ 32 37 42 47 52 57\\n \\ 33 38 43 48 53 58\\n \\ 34 39 44 49 54 59\\n \\ 35 40 45 50 55 60\\n \\ 36 41 46 51 56 *\\n\"; string sQuestion = \"Is your number in this card? y for yes, n for no:\"; string sInput &#123;&#125;; cout &lt;&lt; sCard1 &lt;&lt; sQuestion; cin &gt;&gt; sInput; int b1 = sInput == \"y\"?1:0; cout &lt;&lt; sCard2 &lt;&lt; sQuestion; cin &gt;&gt; sInput; int b2 = sInput == \"y\"?1:0; cout &lt;&lt; sCard3 &lt;&lt; sQuestion; cin &gt;&gt; sInput; int b3 = sInput == \"y\"?1:0; cout &lt;&lt; sCard4 &lt;&lt; sQuestion; cin &gt;&gt; sInput; int b4 = sInput == \"y\"?1:0; cout &lt;&lt; sCard5 &lt;&lt; sQuestion; cin &gt;&gt; sInput; int b5 = sInput == \"y\"?1:0; cout &lt;&lt; sCard6 &lt;&lt; sQuestion; cin &gt;&gt; sInput; int b6 = sInput == \"y\"?1:0; cout &lt;&lt; \"Binary answer: \" &lt;&lt;b6&lt;&lt;b5&lt;&lt;b4&lt;&lt;b3&lt;&lt;b2&lt;&lt;b1&lt;&lt; endl; cout &lt;&lt; \"The number is: \" &lt;&lt; b6*32 + b5*16 + b4*8 + b3*4 + b2*2 + b1*1; return 0;&#125; 上述代码的执行结果为（输入依次为n,n,n,y,y,n）： 12345678910...Card 6: 32 37 42 47 52 57 33 38 43 48 53 58 34 39 44 49 54 59 35 40 45 50 55 60 36 41 46 51 56 *Is your number in this card? y for yes, n for no:nBinary answer: 011000The number is: 24 注意：上述输入y, n要小写，且不要有多余空格。 1#include &lt;string&gt; 第3行：string头文件引入了string类型【C++】，该类型可以存储一个字符串。其工作原理在本书的后续部分逐步讨论。 第7 ~ 21行：定义了sCard1 ~ 6共6个多行字符串。第14行的省略号代表此处有删节（节省篇幅），具体代码以网络下载的随书代码为准。在这些由双引号包裹的多行字符串里，\\n表示换行，每行末尾的\\称之为续行符，它表明下行代码的内容是本行字符串的后续部分。 在输出了卡片字符串之后，程序向用户提问：数字是否在卡片中。用户的回答保存在sInput字符串中。 1int b1 = sInput == \"y\"?1:0; 第28行：条件语句， 如果sInput的值为”y”，b1赋值为1，否则赋值为0。 1cout &lt;&lt; \"Binary answer: \" &lt;&lt;b6&lt;&lt;b5&lt;&lt;b4&lt;&lt;b3&lt;&lt;b2&lt;&lt;b1&lt;&lt; endl; 第45行：上述提问重复6次后，b6,b5,b4,b3,b2,b1分别对应数字的6个二进制位，使用printf( )将数字的二进制形式打印出来。 1cout &lt;&lt; \"The number is: \" &lt;&lt; b6*32 + b5*16 + b4*8 + b3*4 + b2*2 + b1*1; 第46行：通过对各二进制位的加权求和，得到猜测数，并输出给cout。 4. 分支与循环本讲义系重庆大学C/C++课程的教学笔记。 作者： 陈波 chenbo@cqu.edu.cn， All rights reserved. 未经作者许可，不允许经由互联网展示或提供下载。 不允许以纸质出版为目的进行摘抄或改编。 分支语句根据条件的不同作出选择；循环则适用于处理重复的工作。 4.1 if else语句if语句的通用语法格式为： 12345678if (表达式) 语句; if (表达式) &#123; 语句; ... 语句;&#125; if关键字后的括号内包含一个表达式，这个包裹表达式的括号是必须的。当该表达式的结果为真时，if语句的下层代码会被执行。当下层代码的语句多于1条时，需要用{ }包裹。如上述格式中的第4 ~ 8行所示。 下述C语言代码演示了if语句的使用方法： 123456789101112131415161718//Project - IfStatement#include &lt;stdio.h&gt;int main()&#123; int iAge = 0; printf(\"Hey, how old are you ? boy.\\n\"); scanf(\"%d\",&amp;iAge); if (iAge&gt;=18) //括号()必须 printf(\"You are legally an adult.\\n\"); if (iAge&gt;=22)&#123; printf(\"Congratulations, son!\\n\"); printf(\"You are of legal age for marriage.\\n\"); &#125; return 0;&#125; 上述代码的执行结果为（输入为23）： 12345Hey, how old are you ? boy.23You are legally an adult.Congratulations, son!You are of legal age for marriage. 第9行：根据输入iAge的值为23，if后括号内的表达式成立，第10行被执行。 第12行：同理，if中括号内的表达式成立，{ }内的第13 ~ 14行被顺序执行。 相较于if语句，if else语句增加了当表达式/条件不成立时的选项。其通用语法格式为： 123456789101112131415if (表达式) 语句；else 语句； if (表达式) &#123; 语句； ... 语句；&#125;else &#123; 语句； ... 语句；&#125; 当if关键字后括号内的表达式/条件成立时，执行if语句的下层代码，否则执行else语句的下层代码。同样地，当下层代码多于1行时，需要用{ }包裹。 接下来我们借助闰年（leap year）判断问题来解释if else语句的使用方法。一般年份的2月只有28天，闰年的2月则多一天，为29天。公历里，闰年的判断口决如下：四年一闰，百年不闰，四百年再闰。具体地，年份满足下述条件之一，即为闰年： 能被4整除且不能被100整除； 能够400整除。 根据上述条件，我们书写了下述C++程序来进行闰年判断： 12345678910111213141516171819//Project - IfElseStatement#include &lt;iostream&gt;using namespace std;int main() &#123; int iYear &#123;&#125;; cout &lt;&lt; \"Please enter the year:\" &lt;&lt; endl; cin &gt;&gt; iYear; if ((iYear%4==0 &amp;&amp; iYear%100!=0) || (iYear%400==0))&#123; cout &lt;&lt; iYear &lt;&lt; \" is leap year.\" &lt;&lt; endl; cout &lt;&lt; \"There are 29 days in February of \" &lt;&lt; iYear &lt;&lt; \".\\n\"; &#125; else cout &lt;&lt; iYear &lt;&lt; \" is not leap year.\" &lt;&lt; endl; return 0;&#125; 上述代码的执行结果为（输入为2021）： 123Please enter the year:20212021 is not leap year. 上述代码的执行结果为（输入2020）： 1234Please enter the year:20202020 is leap year.There are 29 days in February of 2020. 可以看出，当if语句后的表达式成立时，if的下层代码第12 ~ 13行被执行；当if语句后的表达式不成立时，else的下层代码第16行被执行。下图解释了if语句之后的表达式的结构。 图4- 闰年判定表达式 下图称为流程图（flow chart），它解释了上述代码的执行过程。其中，菱形框表示条件判断，箭头表明程序执行的顺序。根据条件判断的结果不同，程序走向两个不同的分支。 图4- 闰年判断流程图 4.2 多分支选择else if语句可以帮助我们实现程序的多分支结构。我们通过下述示例来解释多分支结构的实现。 为鼓励节约用电，某地制定了如下的阶梯电价政策：以家庭为计价单位，每位家庭成员享有50度/月的基准用电量。 人均月用电量 ≤ 50度，电价按0.7元/度执行； 50度 &lt; 人均月用电量 ≤ 100度，基准用电量部分按0.7元/度执行， 超出部分按1.0元/度执行； 100度 &lt; 人均月用电量 ≤ 200度，基准用电量部分按0.7元/度执行， 超出部分按1.5元/度执行； 人均月用电量 &gt; 200度，基准用电量部分按0.7元/度执行， 超出部分按2.0元/度执行； 显然，上述计价规则涉及多个分支。下述C语言程序给出了解决方案： 12345678910111213141516171819202122232425262728//Project - ElseIfStatement#include &lt;stdio.h&gt;float feeCompute(float fAmount, int iPersonCount)&#123; float fAverage = fAmount / iPersonCount; //人均用电量 float fFamilyBaseAmt = iPersonCount * 50.0F; //家庭基准用电量 float fFee = 0; //家庭电费 if (fAverage &lt;=50.0F) fFee = fAmount * 0.7F; else if (fAverage &lt;= 100.0F) fFee = (fAmount - fFamilyBaseAmt) * 1.0F + fFamilyBaseAmt * 0.7F; else if (fAverage &lt;= 200.0F) &#123; printf(\"Inside function feeCompute: 100 &lt; Average &lt;= 200.\\n\"); fFee = (fAmount - fFamilyBaseAmt) * 1.5F + fFamilyBaseAmt * 0.7F; &#125; else fFee = (fAmount - fFamilyBaseAmt) * 2.0F + fFamilyBaseAmt * 0.7F; return fFee;&#125;int main()&#123; float fFee =feeCompute(768.1F, 4); printf(\"Energed used: %.2f kWh, Person count: %d, Electricity bill: %.2f\\n\", 768.1F,4,fFee); return 0;&#125; 上述代码的执行结果为： 12Inside function feeCompute: 100 &lt; Average &lt;&#x3D; 200.Energed used: 768.10 kWh, Person count: 4, Electricity bill: 992.15 为了简化代码的结构，我们定义了一个名为feeCompute的函数。该函数接受用电量（fAmout）及家庭人数（iPersonCount）两个参数，然后根据阶梯计费规则计算并返回该户的电费总额。 在该函数内部，使用了else if语句来实现多分支结构。如流程图4- 所示，如果第9行的条件成立，执行第10行（然后第20行）；如果第9行的条件不成立，则检查第11行的条件，如果成立，执行第12行（然后第20行）；如果第11行的条件不成立，则检查第13行的条件，如果成立，执行第14 ~ 15行（然后第20行），否则执行第18行（然后第20行）。 综上所述，流程图4- 中的4个方框（分别对应1个if语句的下层代码，2个else if语句的下层代码，1个else语句的下层代码），依据依次进行的条件检查，有且只有一个方框内的代码会被执行。 图4- 阶梯电费计算的多分支流程图 有必要重提一下上述代码的第7行： 1float fFee &#x3D; 0; fFee的初始值被设定为0。从程序逻辑上看，这个值在后续if else if else语句肯定会被覆盖（再次赋值），定义fFee变量时如果不赋初值，也不会有什么影响。但从软件工程的角度看，一个变量如果定义时不赋初值，其值是不确定的，有带来软件缺陷的风险。我们的建议是：总是在变量定义时给其赋一个确定的初始值。初学者在当前阶段很难理解这是为什么，所谓老马识途，请照做即可。 4.3 for循环天下武功，唯快不破。相对于人脑，计算机最大的优势是速度快而且几乎不犯错。 工作与生活中，经常要进行一些重复的工作，比如生产口罩的口罩机需要不停地将无纺布分段切割，群发垃圾邮件的“机器人”将邮件一封一封地发往一个又一个的收件人邮箱。从事这些重复的工作，是计算机的优势，而计算机做这些重复工作的方法，就是循环。C/C++里有for循环、while循环及do while循环语句。本节讨论for循环。 4.3.1 传统for循环for循环的基本语法格式为： 12345678for (初始化；测试；更新) 语句; for (初始化；测试；更新) &#123; 语句; ... 语句;&#125; for关键字后面的括号里包括三个部分，依次是： 初始化语句（initialization）： 初始化用于循环控制的变量； 测试表达式（test expression）：进行循环测试，一般为一个逻辑判断表达式； 更新表达式（update expression）: 修改用于循环测试的变量。注意该表达式尾部没有分号。 for语句的下层语句称为循环体（loop body），当构成循环体的语句多于1行时，需要使用{ }括起来。如上述语法格式的第4 ~ 8行所示。 请阅读下述用C语言编写的for循环示例： 1234567891011121314//Project - SimplestFor#include &lt;stdio.h&gt;int main() &#123; int iSum = 0; for (int i=0;i&lt;3;i++)&#123; printf(\"loop i = %d\\n\",i); iSum += i; &#125; printf(\"sum = %d\",iSum); return 0;&#125; 上述代码的执行结果为： 1234loop i &#x3D; 0loop i &#x3D; 1loop i &#x3D; 2sum &#x3D; 3 图4- for循环流程图1 我们借助于流程图4- 来说明上述程序main( )函数的执行过程及其用途。 步号 说明 1 执行第5行，iSum = 0。 2 执行循环的初始化语句，i = 0。 3 检查循环测试表达式i &lt; 3，此时i值为0，故该表达式为真，允许执行循环体。 4 顺序执行循环体，即第8 ~ 9行：打印当前i值（0），把当前i值累加进iSum。 5 执行循环更新表达式i++，i值变为1。 6 检查循环测试表达式i &lt; 3，此时i值为1，故该表达式为真，允许执行循环体。 7 顺序执行循环体，即第8 ~ 9行：打印当前i值（1），把当前i值累加进iSum。 8 执行循环更新表达式i++，i值变为2。 9 检查循环测试表达式i &lt; 3，此时i值为2，故该表达式为真，允许执行循环体。 10 顺序执行循环体，即第8 ~ 9行：打印当前i值（2），把当前i值累加进iSum。 11 执行循环更新表达式i++，i值变为3。 12 检查循环测试表达式i &lt; 3，此时i值为3，故该表达式为假，结束并跳出循环。 13 执行第12行，打印iSum的值; 接下来继续执行其它后续代码。 1234for (int i=0;i&lt;3;i++)&#123; printf(\"loop i = %d\\n\",i); iSum += i;&#125; 第7 ~ 10行：变量i是在for关键字后面的括号内定义的，这提示i是该for循环内部的局部变量（local variable）▲，它只能在for循环内部被使用，也就是上述程序的第 7 ~ 10行。 请读者务必按照上述流程图4- 人工模拟一遍程序的执行。流程图4- 更简洁地描述了for循环的执行过程。 图4- for循环流程图2 程序调试：借助于程序调试可以帮助读者更好地理解上述for循环执行过程，请扫描阅读。 【? 缺链接】 下述C程序试图计算1 + 2 + … + 99 + 100的和： 1234567891011//Project - Sum100#include &lt;stdio.h&gt;int main()&#123; int iSum = 0, i = 0; for (i=1;i&lt;100;i++) iSum += i; printf(\"sum = %d, i = %d.\",iSum,i); return 0;&#125; 上述代码的执行结果为： 1sum &#x3D; 4950, i &#x3D; 100. 从输出结果看，它失败了，1加到100的和应为5050，而答案是4950，差了100。原因在于该for循环的测试表达式为 i &lt; 100，当i因为更新表达式i++的执行变成100后，for循环要先测试，后执行循环体，显然，100 &lt; 100不成立，第100次的循环未能执行。第9行的输出结果证实，循环结束后，i值确为100。 如果希望上述循环能从1到100（包含100）执行100次，其测试表达式应改为i &lt;= 100或者i &lt; 101。 请注意，上述程序中的变量i是在for循环之外，即第5行中定义的，这说明i是main( )函数内的局部变量▲，这使得我们可以在整个main( )函数内部使用变量i（第9行）。 实践中，上述for循环的初始化语句、测试及更新表达式可以是任意合法的语句/表达式，甚至可以空缺。当初始化语句及测试表达式空缺时，需要用一个分号占位。灵活运行上述特性，可以写出很”复杂“的for循环。请阅读下述C语言程序： 123456789101112131415//Project - ASCII#include &lt;stdio.h&gt;#include &lt;conio.h&gt;int main() &#123; char c = 0; for (; c = getch(), c!=13 &amp;&amp; c!=10;) &#123; //初始化语句为空，更新表达式空缺 putch(c); printf(\" %d \",c); &#125; printf(\"\\nProgram exited!\\n\"); return 0;&#125; 上述程序的执行结果为（在英文输入法下依次输入字符a, b, A, B, 1, 2以及回车）： 12a 97 b 98 A 65 B 66 1 49 2 50Program exited! conio.h头文件是C语言中控制台输入输出（console input &amp; output）头文件，在本程序中，它引入了getch( )及putch( )函数。其中，getch( )负责从控制台读入一个输入字符，返回表示该字符对应ASCII码的int整数；putch( )函数预期接收一个int整数，然后向控制台输出该整数按ASCII码表对应的字符。 第8行：for循环中，初始化语句为空（分号占位），更新表达式空缺，仅提供了循环测试表达式。该for循环执行过程中， 初始化和更新两步将被省略。测试表达式如下： 1c = getch(), c!=13 &amp;&amp; c!=10; 这个测试表达式以逗号为界，分成了两个表达式。这个逗号（comma）其实是一个操作符，它保证了如下两点： 逗号左边的表达式c = getch( )比逗号右边的表达式先执行；这样，当逗号右边的表达式c!=13 &amp;&amp; c!=10执行时，c已经取得了从getch( )读取的新字符。 将逗号右方表达式的值作为整个测试表达式的结果。本例中，左表达式c = getch( )在赋值后返回c作为表达式的值，右表达式也会返回布尔运算的结果，但逗号表达式确保将右表达式，即c!=13 &amp;&amp; c!=10的结果作为整个循环测试表达式的结果。 本程序中，作者期望把按下回车键作为程序停止执行的条件，但在不同的操作系统及执行环境下，按下回车键后，getch( )得到的字符却不尽相同，有的是’\\r’，即”返回行首“符，对应ASCII码13，有的是’\\n’，即”换行符“，对应ASCII码10，甚至有的系统13和10会顺序返回。为了兼容上述不同情况，循环的测试表达式同时检查了13和10两个值。 1234for (; c = getch(), c!=13 &amp;&amp; c!=10;) &#123; //初始化语句为空，更新表达式空缺 putch(c); printf(\" %d \",c);&#125; 第8 ~ 11行：上述for循环借助于测试表达式，不断从控制台读取字符，如果是普通字符，执行循环体：输出该字符（第9行），输出该字符的ASCII码值（第10行）；如果读入的字符等于13或10，即是由回车键导致的“返回行首”符或”换行“符，测试表达式为假，结束循环，打印“Program exited!”信息（第13行）。 上述程序的输出结果证实：a的ASCII码为97， b为98，A为65，B为66 … 它们是连续的。 关于逗号操作符（comma operator），有必要进行更进一步的讨论。请读者考虑下述C语言程序的执行结果： 1234567891011//Project - Comma#include &lt;stdio.h&gt;int main() &#123; int a = 0, b = 0; a = b++, 3; printf(\"a = %d, b = %d\",a,b); return 0;&#125; 按照本节中提及的逗号操作符的语法含义，读者可能会对第7行代码进行如下解读： 逗号左表达式b++先执行，b值由0变1； 逗号右表式的值3作为整个表达式的结果返回，然后赋值给a，a值变为3； 执行结果为： a = 3, b = 1。 但真实的执行结果是： 1a &#x3D; 0, b &#x3D; 1 1a = b++, 3; 第7行：编译器的真正解读如下。 逗号操作符的优先级低于赋值操作符，所以a = b++被视为逗号的左表达式。逗号左表达式a = b++先执行，b++先取值，后递增，故a被赋值为b之前的初始值0； 逗号右表达式3后执行，其返回值3作为整个逗号表达式的值返回。由于返回后没有”人“需要它，所以直接被舍弃。 本例中，如果期望a被赋值为3，第7行应修改为： 1a = (b++,3); 4.3.2 基于范围的for循环基于范围的for循环【C++ 11】比传统的for循环语法简单得多。 假设某商量有4种商品，其2月18日的价格依次为1030.23f, 2828.12f, 76.0f, 992.0f，2月19日统一加价10%。现要求使用表格打印显示上述商品在2月18、19日的价格变化。C++程序如下： 123456789101112131415//Project - RangeFor#include &lt;iostream&gt;using namespace std;int main() &#123; float fPrices[] &#123;1030.23f, 2828.12f, 76.0f, 992.0f&#125;; //2月18日的商品价格 int idx = 0; cout &lt;&lt; \"idx\\t2/18\\t2/19\\n\"; cout &lt;&lt; \"----------------------------\\n\"; for (auto x:fPrices) cout &lt;&lt; ++idx &lt;&lt; \"\\t\" &lt;&lt; x &lt;&lt; \"\\t\" &lt;&lt; x*1.1f &lt;&lt; endl; return 0;&#125; 上述代码的执行结果为： 123456idx 2&#x2F;18 2&#x2F;19----------------------------1 1030.23 1133.252 2828.12 3110.933 76 83.64 992 1091.2 1float fPrices[] &#123;1030.23f, 2828.12f, 76.0f, 992.0f&#125;; //2月18日的商品价格 第6行：fPrices变量名后增加了一个方括号，这表明fPrices不是float类型的变量，而是一个数组▲，这个数组可以存储多个float类型的值。{ }包裹的部分称为初始化列表（initializer list）【C++ 11】，编译器会自动统计其中的元素个数以便为fPrices数组分配恰当的存储空间。 12for (auto x:fPrices) cout &lt;&lt; ++idx &lt;&lt; \"\\t\" &lt;&lt; x &lt;&lt; \"\\t\" &lt;&lt; x*1.1f &lt;&lt; endl; 第11 ~ 12行：auto x:fPrices以冒号为界面，分为两部分。冒号之后为被遍历的数据集，此处为fPrices数组，它表明了循环的范围。冒号之前为循环取值变量。由于C/C++的数组只能存储同一类型的值，即fPrices数组内部元素全部为float类型，所以此处，我们使用auto进行类型推断，编译器会推断确定x变量的类型，结果为float。被遍历的数据集有多少个元素，循环体代码（第12行）就会执行多少次，每次循环开始前，x会自动从fPrices数组中按顺序取值。 ++idx是第3章中讨论过的递增操作符，它先递增，后取值。在循环过程中，idx表示输出数据的行号。每执行一次循环体，idx值都会增加1。 程序的执行结果证实，for循环遍历了fPrices数组，依次打印了其中的原价格及加价后的价格。 此外，C++ 也允许直接把初始化列表放在基于范围for循环的冒号后面，示例如下： 12for (int x:&#123;1,3,5,7,9&#125;) cout &lt;&lt; x &lt;&lt; \" \"; 微实践 - 质数判定质数是指在大于1的自然数中，除了1和它本身以外不再有其他因数的自然数。根据这一数学定义，我们用C语言设计了isPrime( )函数及其测试代码如下： 12345678910111213141516171819202122232425//Project - IsPrime#include &lt;stdio.h&gt;#include &lt;stdbool.h&gt;bool isPrime(int); //函数的声明int main()&#123; printf(\"sizeof(bool) = %lld.\\n\",sizeof(bool)); printf(\"isPrime(-2):\\t%s.\\n\", isPrime(-2)?\"Yes\":\"No\"); printf(\"isPrime(3):\\t%s.\\n\", isPrime(3)?\"Yes\":\"No\"); printf(\"isPrime(4):\\t%s.\\n\", isPrime(4)?\"Yes\":\"No\"); printf(\"isPrime(117):\\t%s.\\n\", isPrime(117)?\"Yes\":\"No\"); return 0;&#125;bool isPrime(int n) &#123; //函数的定义 if (n&lt;=1) return false; for (int i=2;i&lt;n;i++) if (n % i == 0) return false; return true;&#125; 上述代码的执行结果为： 12345sizeof(bool) &#x3D; 1.isPrime(-2): No.isPrime(3): Yes.isPrime(4): No.isPrime(117): No. 本书第2章曾经提及C语言没有bool类型，那么上述C语言代码中的bool类型从何而来？第3行引入了stdbool.h头文件，在该头文件中，我们可以找到如下内容： 123#define bool _Bool#define true 1#define false 0 由于上述#define预处理指令▲的存在，源代码经过预处理器▲处理后，其中的bool全部被文本替换为_Bool，其中的true和false则被替换为1和0。 在C++语言中，bool，true，false均为关键字。而上述代码中，bool，true，false只是头文件引入的代号，分别对应_Bool，1和0。_Bool是C99引入的“布尔类型”，在某些编译器中，它可以只占1个比特。C99并没有定义关键字true及false，因此stdbool.h通过#define对其进行了“定义”。 第17 ~ 25行定义了函数isPrime( )，请注意，这个定义位于main( )函数之后。为了在main( )函数中使用isPrime( )函数，第5行代码给出了isPrime( )函数的声明： 1bool isPrime(int); //函数的声明 该声明提供了如下的信息给编译器：函数的名称，函数的返回值类型，函数的参数个数及类型。对于编译器而言，上述信息已经足以判定第10行的函数调用 isPrime(-2) 在形上是合法的，所以编译器会愉快地通过对第10行代码的审查。请读者注意上述函数声明中参数列表省略了形式参数的名称，这是允许的。 1printf(\"sizeof(bool) = %lld.\\n\",sizeof(bool)); 第8行：从输出结果看，sizeof(bool)，也就是sizeof(_Bool)的返回值为1。这可能提示在作者的开发环境里，_Bool类型占据1个字节。之所以说是可能，因为sizeof操作符以字节为单位，1个比特显然不等于0字节。由于sizeof操作符返回值类型为unsigned long long，该行printf( )中的占位符如果是%d，编译器可能会给出警告。因为%d通常与int类型对应，从unsigned long long到int类型的转换存在超储值范围的可能。将该占位符修改为%lld可以消除上述警告。 第17 ~ 25行：isPrime(n)函数用于判定n是否是质数，是的话返回true，否则返回false。 12if (n&lt;=1) return false; 第18 ~ 19行：排除n小于等于1的情况，如果成立，返回假。 123for (int i=2;i&lt;n;i++) if (n % i == 0) return false; 第20 ~ 22行：通过for循环逐一考查2 ~ n-1（不包含n）的整数i，如果n能被i整除，说明n不是质数，返回假。请注意，第21 ~ 22行的循环体虽书写成两行，但可以认为第22行是第21行if语句的下层代码。在逻辑上，第21 ~ 22行是一条语句，所以该for循环中，作为循环体的第21 ~ 22行没有用{ }包裹。 1return true; 第24行：如果在前述for循环中没有发现除1及n自身外的其它因数，说明n为质数，返回真。 在isPrime( )函数定义中有3个return语句，这意味着根据n值的不同，isPrime( )函数可能从这3个return语句中的其中1个返回。由于这3个return语句所返回的都是bool类型（实为_Bool类型），故合法。 4.4 break语句为了理解break语句的作用，我们试图完成下述任务。 任务：找出大于等于10000的第1个质数。 分析：在得到结果之前，我们并不知道大于等于10000的第1个质数是什么，因此，我们从10000开始，逐一交给微实践 - 质数判定中定义的isPrime( )函数进行判定。当发现第1个质数后，任务达成，后续的检查没有继续进行的必要，程序应停止。 基于上述分析，我们使用C语言实现了下述程序： 1234567891011121314151617181920212223//Project - BreakExample#include &lt;stdio.h&gt;#include &lt;stdbool.h&gt;bool isPrime(int n) &#123; //函数的定义 ... //详见微实践 - 质数判定&#125;int main()&#123; printf(\"Try to find first prime number(&gt;=10000):\\n\"); int iPrime = -1; for (int i=10000;;i++)&#123; if (isPrime(i))&#123; iPrime = i; break; &#125; printf(\"%d checked, not prime number.\\n\",i); &#125; printf(\"First prime number(&gt;=10000) is: %d.\",iPrime); return 0;&#125; 上述代码的执行结果为： 123456789Try to find first prime number(&gt;&#x3D;10000):10000 checked, not prime number.10001 checked, not prime number.10002 checked, not prime number.10003 checked, not prime number.10004 checked, not prime number.10005 checked, not prime number.10006 checked, not prime number.First prime number(&gt;&#x3D;10000) is: 10007. 1int iPrime = -1; 第12行：iPrime变量用于保存找到的质数，初始值定为-1。初值定为-1的理由是负数明显不是质数，当程序编写错误导致错误结果时，容易通过该变量的-1初值发现错误。 1for (int i=10000;;i++)&#123; 第13行：for关键字后面的括号内给出了初始化语句和更新表达式，但测试表达式空缺。这说明for循环没办法通过测试表达式终止。 1234if (isPrime(i))&#123; iPrime = i; break;&#125; 第14 ~ 17：将循环变量i交给isPrime( )函数进行判定，如果是质数，首先将i赋值给iPrime保存，然后使用break语句终止将跳出循环。本程序中，当break语句执行后，程序的执行点将由第16行直接跳至循环外的第21行。 1printf(\"First prime number(&gt;=10000) is: %d.\",iPrime); 第21行：输出找到的质数iPrime。 上述for循环中，我们之所以敢于放弃测试表达式，是基于我们的数学知识：10000之后一定会有质数，即第16行的break语句一定会执行并导致循环终止。当因为程序编写错误导致循环无法终止，这种情况我们称之为“死循环”。 从执行结果可以看出，上述程序依次检查了10000 ~ 10006，均不是质数。在检查10007时，isPrime( )返回真，执行break语句结束了循环。 图4- break跳转示意 图4- 展示了本程序中当break语句执行时的执行点跳转。可以看到，break语句跳出循环，程序执行点跳转到循环后语句。 【？缺：双重循环内内层循环中的break语句执行时的效果，适补】 4.5 continue语句为了理解continue语句的作用，我们试图完成下述任务。 任务：找出并打印100以内的全部质数。 分析：将整数2 ~ 100逐一交给isPrime( )函数进行判定，如果是，打印出来。 基于上述分析，我们用C语言实现了下述程序： 12345678910111213141516171819202122//Project - ContinueExample#include &lt;stdio.h&gt;#include &lt;stdbool.h&gt;bool isPrime(int n) &#123; //函数的定义 ... //详见微实践 - 质数判定&#125;int main()&#123; printf(\"Try to find all prime number(&lt;=100):\\n\"); int iFound = 0; //发现的质数个数 for (int i=2;i&lt;=100;i++)&#123; if (!isPrime(i)) continue; iFound++; printf(\"%d, \",i); &#125; printf(\"\\n%d prime numbers been found.\",iFound); return 0;&#125; 上述程序的执行结果为： 123Try to find all prime number(&lt;&#x3D;100):2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97,25 prime numbers been found. 1int iFound = 0; //发现的质数个数 第12行：iFound变量存储发现的质数个数。 12if (!isPrime(i)) continue; 第14 ~ 15行：在循环体内，对i进行质数判定，如果不是（注意逻辑非操作符！），执行continue语句，该语句的执行放导致本次循环的剩余代码，即第16 ~ 17被跳过，直接尝试下一轮循环。当然，按照for循环自身的流程，会先执行更新表达式（i++），然后再测试（i&lt;=100），测试通过则再次执行循环体。 12iFound++;printf(\"%d, \",i); 第16 ~ 17行：由于前述if判断及continue语句的存在，程序执行点到达第16行即意味着当前轮循环中的i是一个质数。这两行代码将iFound递增1，并将质数i打印出来。 1printf(\"\\n%d prime numbers been found.\",iFound); 第20行：当for循环因测试（i&lt;=100)测试失败终止后，程序执行点到达第20行，该行负责打印发现的质数的总个数（iFound）。 图4- continue跳转示意 图4- 展示了本程序中当continue语句执行时的执行点跳转。可以看到，continue的执行并不会结束整个循环，它只是略过本轮循环体的剩余代码，直接跳转至下一轮循环。本例中，按照for循环自身的机制，continue执行后，下一条被执行的语句应该是更新表达式（i++)，然后再根据测试表达式（i&lt;=100）的结果来决定是否再次执行循环体。 微实践 - 程序的断点调试https://codelearn.club/2020/02/qtdebug/ 4.6 while循环while循环的基本语法格式为： 12345678while (测试表达式) 语句;while (测试表达式) &#123; 语句; ... 语句;&#125; while关键字之后的括号内包含一个测试表达式。当循环体的构成语句多于1行时，循环体部分需要用{ }包裹。 while循环先检查测试表达式的值，如果为真，执行循环体；如果为假，结束循环。每执行完一轮循环体代码，会再次检查测试表达式，为真继续，为假结束。 为便于解释，我们编写了下述C++程序： 1234567891011121314151617//Project - Parrot1#include &lt;iostream&gt;#include &lt;string&gt;int main()&#123; using namespace std; cout &lt;&lt; \"I am a parrot, say something to me.\" &lt;&lt; endl; string s = \"\"; while (s!=\"q\")&#123; getline(cin,s); cout &lt;&lt; s &lt;&lt; endl; &#125; cout &lt;&lt; \"Bye, see you later.\" &lt;&lt; endl; return 0;&#125; 上述程序的执行结果为： 12345678I am a parrot, say something to me.Good morning.Good morning.Run Forrest!Run Forrest!qqBye, see you later. 说明：第2、4、6行为操作者的输入。 我们对照图4- 来解释上述程序的执行过程及其功能。 步号 说明 1 第6行引入了std名字空间。作者故意将该行移至此处，以便告知读者，该行代码并不是必须出现在文件的开头处。 2 第8行输出了一行文字：我是鹦鹉，请跟我说话。第9号定义了一个string类型的变量s，并初始化其值为一个字空符串。 3 检查测试表达式s != “q”，此时s的为空，表达式为真，准备执行循环体。 4 循环体执行：第11行getline( )函数从cin读取一行输入”Good morning.”，存入s对象。第12行将s输出给cout，控制台输出”Good morning.”。 5 检查测试表达式s != “q”，此时s的值为”Good morning.”，表达式为真，准备执行循环体。 6 循环体执行：第11行getline( )函数从cin读取一行输入”Run Forrest!”，存入s对象。第12行将s输出给cout，控制台输出”Run Forrest!”。 7 检查测试表达式s != “q”，此时s的值为”Run Forrest!”，表达式为真，准备执行循环体。 8 循环体执行：第11行getline( )函数从cin读取一行输入”q”，存入s对象。第12行将s输出给cout，控制台输出”q”。 9 检查测试表达式s != “q”，此时s的值为”q”，表达式为假，退出循环。 10 第15行，输出道别字符串。 图4- while循环的结构 综上， 上述程序通过while循环不断读取输入，并将得到的输入字符串输出给控制台，就像鹦鹉重复主人的话一样。如果操作者输入q，则循环测试失败，程序结束退出。 请读者注意观察图4- 的流程，while循环先检查（测试表达式），后执行（循环体），在极端情况下，循环体有可能执行0次。 对上述程序略作修改，可以避免在“鹦鹉”重复主人的命令q，代码如下： 12345678910111213141516171819//Project - Parrot2#include &lt;iostream&gt;#include &lt;string&gt;int main()&#123; using namespace std; cout &lt;&lt; \"I am a parrot, say something to me.\" &lt;&lt; endl; string s = \"\"; while (true)&#123; getline(cin,s); if (s==\"q\") break; cout &lt;&lt; s &lt;&lt; endl; &#125; cout &lt;&lt; \"Bye, see you later.\" &lt;&lt; endl; return 0;&#125; 1while (true)&#123; 第10行：测试表达式恒为真，这意味着放弃了循环测试表达式的检查。 12if (s==\"q\") break; 第12 ~ 13行：当输入字符串为”q”时，执行break语句结束并跳出循环。这同时意味着第14行的代码只有当s不为”q”时才有机会执行。 事实上，while循环只是for循环的一个简化版本。上述鹦鹉程序（Parrot1），也可以用for循环实现： 123for (; s!=\"q\"; )&#123; ...&#125; 这个for循环，没有初始化语句，也没有更新表达式，只有测试表达式。它的执行过程与Parrot1中的while循环完全相同。 微实践 - 九层之台，起于累土＂九层之台，起于累土＂出自春秋·楚·李耳《老子》第64章：＂合抱之木，生于毫末；九层之台，起于累土；千里之行，始于足下＂。不论起点有多低，只要不断成长，假以时日，终有所成。 一张厚度为0.1毫米的足够大的纸，每对折一次，厚度翻倍。问： 这张纸对折多少次以后将达到世界最高峰珠穆朗玛峰的高度？如果凭直觉，作者觉得再怎样也要上千次对折才行。 我们用C语言编写了下述程序： 1234567891011121314151617181920//Project - Everest#include &lt;stdio.h&gt;int main() &#123; int iCounter = 0; //对折次数 float fThickness = 0.0001F; //纸厚，单位米 while (1) &#123; if (fThickness &gt; 8844.43F) //超过珠峰高度就停止循环 break; else&#123; fThickness *= 2; //对折一次厚度翻倍 iCounter++; //对折次数加1 &#125; &#125; printf(\"Thickness = %.2f after %d folds, exceeding Everest.\", fThickness,iCounter); return 0;&#125; 执行结果 1Thickness &#x3D; 13421.77 after 27 folds, exceeding Everest. 12int iCounter = 0; //对折次数float fThickness = 0.0001F; //纸厚，单位米 第5 ~ 6行：iCounter记录纸的对折次数；fThickness记录对折后的纸厚。 第8 ~ 15行：通过一个while循环确定超过珠峰高度所需要的最小对折次数。 while (1)将整数1视为布尔值，按非零即真原则，总是真，执行一个“死”循环。 循环内对对折后的纸厚与珠峰高度比较，如果大于珠峰高度，break跳出循环。 每次对折纸厚翻倍，iCounter记数器加1。 输出结果显示所需对折次数为27次。你没有看错，作者也没有算错，就是27次！上面的代码使用循环，完全出于教学目的。显然，求超过珠峰高度的最小对折次数，下述C语言代码更直接： 1234567891011//Project - EverestSimple#include &lt;stdio.h&gt;#include &lt;math.h&gt; //引入log2()函数int main()&#123; double t = log2(8844.43/0.0001); printf(\"%f\",t); printf(\"\\n%f\",0.0001 * pow(2,27)); return 0;&#125; 上述代码的执行结果为： 126.398266 log2(x)函数计算并返回x的以2为底的对数。如果要验证27次对折后纸的厚度，可用下述C语言代码，直接求0.0001 * 227。 1printf(\"%f\",0.0001 * pow(2,27)); 将上述代码置入一个main( )函数中执行，其执行结果应为： 113421.772800 1万3千多米，这就是0.1mm厚的纸对折27次之后的厚度。实践中，这个不太可能做到，对折半个珠峰高度厚的纸，人类的体力或者机械都办不到，奥特曼估计也不行。 4.7 do while循环我们通过do while版本的鹦鹉程序也说明do while与while循环的异同。C++代码如下： 12345678910111213141516171819//Project - Parrot3#include &lt;iostream&gt;#include &lt;string&gt;int main()&#123; using namespace std; cout &lt;&lt; \"I am a parrot, say something to me.\" &lt;&lt; endl; string s = \"\"; do &#123; getline(cin,s); cout &lt;&lt; s &lt;&lt; endl; &#125; while (s!=\"q\"); cout &lt;&lt; \"Bye, see you later.\" &lt;&lt; endl; return 0;&#125; 上述代码的执行结果为： 12345678I am a parrot, say something to me.Good morning.Good morning.Run Forrest!Run Forrest!qqBye, see you later. 说明：第2、4、6行为操作者的输入。 如下图4- 所示，do while循环与while循环的主要区别是先执行（循环体），后检查（测试表达式）。也就是说，无论测试表达式真假，循环体至少会被执行一次。 上述程序的执行过程请读者参照流程图，自行模拟。 图4- do while循环的结构 对于程序设计而言，do while循环并不是必须使用的技术。其相关功能，完全可以通过while或者for循环来实现。坦率地讲，作者上一次使用do while循环，大概是作为学生参加C语言考试的时候。 4.8 switch分支除了else if语句外，switch语句也可以实现多分支程序结构。switch语句的基本语法形式如下： 12345678910111213switch (整数表达式) &#123;case 标签1: ...case 标签k: 语句(一条或多条); break;... case 标签n： 语句(一条或多条); break;default: 语句(一条或多条); &#125; 在switch关键字之后的括号内包含一个整数表达式（integer-expression）。所谓整数表达式，是指该表达式的值必须是整数或者可以转换成整数的类型，包括但不限于char，int， short，long long以及以后要讨论的枚举型▲。 接下来的{ }内包裹了1个到多个以冒号结尾的case子句，子句中的标签也必须是整数或者可以转换成整数的字符或者枚举类型。程序执行时，将从上到下将整数表达式的值与case后面的标签进行比较，如果相等，则执行后续代码，直至遇到break语句跳出switch结构或者遇到反花括号 } 为止。如果检查完所有的标签，都不相等，则执行default子句之后的代码。 在上述语法格式中，default子句是可选的（optional）。 为了消解读者的疑惑，我们用C语言编写了下述程序，它要求操作者输入表示月份的整数（1 ~ 12），然后输出该月的天数。 123456789101112131415161718192021222324252627282930313233//Month#include &lt;stdio.h&gt;int main() &#123; int iMonth = 1; printf(\"Please input month number(1~12):\"); scanf(\"%d\",&amp;iMonth); switch (iMonth)&#123; case 1: case 3: case 5: case 7: case 8: case 10: case 12: printf(\"There are 31 days in %dth month.\\n\",iMonth); break; case 2: printf(\"There are 28 or 29 days in %dth month.\\n\",iMonth); //break; //break缺失 case 4: case 6: case 9: case 11: printf(\"There are 30 days in %dth month.\\n\",iMonth); break; default: printf(\"Wrong month number.\\n\"); &#125; return 0;&#125; 显然，不同的输入值将导致不同的执行结果。 当输入为7时，上述程序的执行结果如下： 12Please input month number(1~12):7There are 31 days in 7th month. 执行过程：switch语句从上到下检查case标签，在第13行（case 7）成功匹配，执行后续代码第17行，第18行（break）。break语句的执行使用程序跳出switch结构至第32行（return 0）。 当输入为2时，上述程序的执行结果如下： 123Please input month number(1~12):2There are 28 or 29 days in 2th month.There are 30 days in 2th month. 执行过程：switch语句从上到下检查case标签，在第19行（case 2）成功匹配，执行后续代码第20行，第26行，第27行（break）。break语句的执行使用程序跳出switch结构至第32行（return 0）。显然，第26行的执行（表示该月有30天）是多余而且错误的。作者有意构造了这一错误，请读者注意，第21行的break语句被注释掉了。 当输入19时，上述程序的执行结果如下： 12Please input month number(1~12):19Wrong month number. 执行过程：19无法匹配所有的case子句，程序执行default子句后的第29行。 建议读者执行并尝试输入其它值，如1，6，12等，体会switch语句的程序分支功能。 4.9 goto语句 C语言从更早期的 Fortran语言继承了goto语句，其基本语法格式如下： 123456标签: 语句; ... 语句; goto 标签; 当goto语句被执行时，程序将直接跳转到对应标签所在的代码行。上述格式中，第1行的标签后面有一个冒号，这是语法要求。此外，标签定义（第1行）既可位于对应的goto语句前，也可位于goto语句后，也就是说，goto语句既可以实现往前跳转，也可以实现往后跳转。 为了解读goto语句的用法，我们构造了下述C++程序： 1234567891011121314151617//Project - GotoExample#include &lt;iostream&gt;using namespace std;int main()&#123; int i &#123;1&#125;; int sum &#123;0&#125;; loop: sum += i; i++; if (i&lt;=100) goto loop; cout &lt;&lt; \"sum = \" &lt;&lt; sum &lt;&lt; endl; return 0;&#125; 上述代码的执行结果为： 1sum &#x3D; 5050 上述程序使用goto语句构造了一个循环，计算1 + 2 + … + 100的和。读者可以把上述代码的第10 ~ 11行视作循环体。 1loop: 第9行：定义了标签loop。 12if (i&lt;=100) goto loop; 第12 ~ 13行： 当i&lt;=100时，使用goto语句跳转至loop标签，即第9行。 图4- 中的箭头展示了当上述程序中第13行的goto语句执行时，程序的跳转方向。 图4- goto跳转示意图 goto语句的执行效率很高，但对初学者非常不友好，容易导致程序逻辑混乱、资源泄露等方面的问题。事实上，通过组合使用if else，for/while循环，break，continue等可以避免goto语句的使用。我们给初学者的建议是：不要使用goto语句。 对于那些有丰富经验的程序员而言，goto语句的恰当使用，除了获得较高的执行效率之外，有时还可以简化程序的结构。在Linux操作系统的内核代码中，我们可以看到大量的goto语句。当前最流行的手机操作系统之一的Android，基于Linux内核。 5. 数组及字符串本讲义系重庆大学C/C++课程的教学笔记。 作者： 陈波 chenbo@cqu.edu.cn， All rights reserved. 未经作者许可，不允许经由互联网展示或提供下载。 不允许以纸质出版为目的进行摘抄或改编。 5.1 一维数组数组（array）可以在连续的空间里存储相同类型的多个对象。当定义一个数组时，需要提供下述信息： 数组内元素（element）的数据类型； 数组的名称； 数组内的元素个数。 定义一个数组的通用语法格式如下： 1元素类型 数组名[元素个数]; 我们通过下述C语言示例来初步理解一维数组的定义和使用方法： 123456789101112131415161718192021//Project - Scores#include &lt;stdio.h&gt;int main() &#123; float scores[5] = &#123;77,92.5,68,99,100&#125;; scores[0] = 88; printf(\"sizeof(scores) = %lld\\n\", sizeof(scores)); printf(\"scores = %p\\n\",scores); printf(\"%p - %p - %p - %p - %p\\n\", &amp;scores[0], &amp;scores[1], &amp;scores[2], &amp;scores[3], &amp;scores[4]); float fSum = 0; for (int i=0;i&lt;5;i++) fSum += scores[i]; float fAverage = fSum / 5; printf(\"Average score = %.2f\",fAverage); return 0;&#125; 上述代码的执行结果为： 1234sizeof(scores) &#x3D; 20scores &#x3D; 000000000061FE00000000000061FE00 - 000000000061FE04 - 000000000061FE08 - 000000000061FE0C - 000000000061FE10Average score &#x3D; 89.50 说明：读者在自己计算机上的运行结果中的第2 ~ 3行很可能与本书不同。 1float scores[5] = &#123;77,92.5,68,99,100&#125;; 第5行：定义了一个名为scores的数组，该数组有5个元素，元素的类型为float。等号之后的初始化列表给出了5个元素的初始值。本例中，我们假设scores数组存储了某位同学某学期所修的5门课程的成绩。 图5- 数组的内存布局 说明：数组的内存地址是在运行时刻由操作系统分配的，所以读者在自己计算机上获得的scores数组的内存地址很可能与图5- 不同。图中的每个单元格表示4个字节的内存空间，每4个字节正好可以存入一个float类型的对象。 图5- 给出了scores数组在内存中的布局图。从该图中可以看到，数组由5个float对象构成，每个float对象占据4个字节，从内存低地址往内存高地址依次排列。整个数组占据4 x 5 = 20个字节的内存空间。我们给数组的5个元素依次编号为0，1，2，3，4，这个编号称之为数组元素的下标（subscript）或索引（index）。请读者注意，同大多数程序设计语言一样，C/C++中对数组元素的计数从0开始。 1scores[0] = 88 第6行：使用[ ]操作符访问scores数组下标为0的元素，通过赋值操作符将其值修改为88。 1printf(\"sizeof(scores) = %lld\\n\", sizeof(scores)); 第8行：打印通过sizeof操作符获取的scores数组的大小，输出证实，其值为20个字节。刚好等于单个元素尺寸 x 元素个数，即4 x 5。 1printf(\"scores = %p\\n\",scores); 第9行：将数组名scores视为一个地址（指针），输出其值。 12printf(\"%p - %p - %p - %p - %p\\n\", &amp;scores[0], &amp;scores[1], &amp;scores[2], &amp;scores[3], &amp;scores[4]); 第10 ~ 11行：通过&amp;scores[0]取得数组第0个元素的地址并打印出来， 类似地，其余4个元素的地址也被打印出来。 从输出结果第2~3行可以看到，数组名scores与&amp;scores[0]的输出值都是0x000000000061FE00。请读者记住下述规则：数组名 == 数组中首元素的地址。输出结果的第3行同时印证了图5- 中的内存布局，scores数组的5个元素是从低地址到高地址依次连续存储的。 123456float fSum = 0;for (int i=0;i&lt;5;i++) fSum += scores[i];float fAverage = fSum / 5;printf(\"Average score = %.2f\",fAverage); 第13 ~ 18行：通过for循环对scores全部数组元素求和，再除以5，得到平均分数并打印出来。其中，scores[i]获取scores数组下标为i的元素值。 5.2 元素的下标访问通过a[i]可以访问a数组的第i个元素。当计算机试图访问一个存储在内存中的对象时，必须先知晓该对象的存储地址。那么，计算机是如何获得a数组第i个元素的存储地址的呢？请见下述公式：$$\\begin{aligned}a[i]的地址 &amp;= 首元素的地址 + i \\times 单个元素的尺寸 \\&amp;= a + i \\times sizeof(ElementType)\\end{aligned}$$为了解读方便，我们准备了如下的C语言程序： 123456789101112131415//Project - Subscript#include &lt;stdio.h&gt;int main() &#123; int a1[5] = &#123;11,11,11,11,11&#125;; int a2[5] = &#123;0,1,2,3,4&#125;; int a3[5] = &#123;33,33,33,33,33&#125;; printf(\"%p - %p - %p\\n\",a1,a2,a3); printf(\"%d,%d,%d,%d,%d\\n\",a2[0],a2[1],a2[2],a2[3],a2[4]); printf(\"a2[-4] = %d\\n\",a2[-4]); printf(\"a2[8] = %d\\n\",a2[8]); return 0;&#125; 上述程序在作者计算机上的执行结果为： 1234000000000061FE00 - 000000000061FDE0 - 000000000061FDC00,1,2,3,4a2[-4] &#x3D; 33a2[8] &#x3D; 11 说明：每种类型的编译器在局部变量及数组的内存布局上会有异差，这些差异会导致在读者的计算机上，输出结果很可能与本书不同。 图5- 3个数组的内存布局 说明：图中的每个单元格代表4个字节的存储空间，每4个字节正好可以存入一个int类型的对象。 根据上述程序的输出，我们绘制了a1、a2、a3三个数组的内存布局图，请见图5- 。上述三个数组均包含5个int类型的元素，1个int占4个字节，故三个数组的大小均为5 x 4 = 20字节。如图所示，a3占据了从0x0061FDC0开始的连续20个字节的空间，a2占据了从0x0061FDE0开始的连续20个字节的空间，a1占据了从0x0061FE00开始的连续20个字节的空间。编译器出于某些特殊的理由（比如内存对齐或调试需要），在a3、a2和a1三个数组间空出了12个字节的空间，对应图中数组间的灰色单元。上图中，每个单元代表4个字节，一个单元正好可以存入一个int。此外，图中还可以看到，定义在先的对象a1位于较高的内存地址段，定义在后的对象a3位于较低的内存地址段，a2夹在中间。 123int a1[5] = &#123;11,11,11,11,11&#125;;int a2[5] = &#123;0,1,2,3,4&#125;;int a3[5] = &#123;33,33,33,33,33&#125;; 第5 ~ 7行：定义并初始化了a1、a2和a3三个数组，每个数组都包含5个int类型的元素。 1printf(\"%p - %p - %p\\n\",a1,a2,a3); 第9行：将三个数组名按地址输出，根据前节所述，数组名即数组首元素的地址。该行的输出结果已反应在图5- 当中。 1printf(\"%d,%d,%d,%d,%d\\n\",a2[0],a2[1],a2[2],a2[3],a2[4]); 第10行：依次打印a2[0] ~ a2[4]的值。从数组元素取值过程中，应用到了本节开头处给出的元素地址计算公式计算相应元素的内存地址。可以看到，当给出合法的下标0 ~ 4时，程序正确输出了a2的全部元素。 1printf(\"a2[-4] = %d\\n\",a2[-4]); 第11行：打印a2[-4]的值，根据元素地址计算公式，相应元素地址为：$$a2 + (-4)\\times sizeof(int) = 0x0061FDE0 - 16 = 0x0061FDD0$$该地址正好对应a3[4]，其值为33。输出结果中的第3行证实了这一判断。 1printf(\"a2[8] = %d\\n\",a2[8]); 第12行：打印a2[8]的值，根据元素地址计算公式，相应元素地址为：$$a2 + 8 \\times sizeof(int) = 0x0061FDE0 + 32 = 0x0061FE00$$该地址正好对应a1[0]，其值为11。输出结果中的第4行证实了这一判断。 警告🚩 出于执行效率的考虑，C/C++不会对数组下标进行越界检查，而只是机械地使用本节介绍的元素地址计算公式计算出元素地址，然后访问。本例中，a2[-4]和a2[8]事实上已经超出了a2数组的存储范围，但编译器最多给一个警告，不会拒绝。如果我们对a2[-4]或a2[8]进行赋值，则事实上修改了a2数组之外的对象，这十分危险！ 用C/C++编程，就象是闪电侠快速地奔跑在布满地雷的雷区，又快又危险。 再次说明，不同的编译器会对上述a1~a3数组的内存布局作出不同安排。在读者的计算机上，运行结果很可能会与本书不同。读者可能需要研究调整a2[-4]和a2[8]当中的下标值，才能观察到与本书类似的结果。 5.3 数组初始化当数组的初始化列表中给出的初始值个数N少于元素个数时，则数组的前N个元素会被赋以指定值，其余元素则被初始化为0。对于下述dummy数组，其前2个元素的值分别被初始化为1和2，其余8个元素则被初始化为0。 1short dummy[10] = &#123;1,2&#125;; //前两个元素初始化为1和2，其余元素初始化为0 事实上，下述两种写法都可以导致dummy数组的全部元素被初始化为0： 12short dummy[10] = &#123;&#125;; //元素值全部初始化为0short dummy[10] = &#123;0&#125;; //元素值全部初始化为0 如果数组定义时不对数组进行初始化， 则数组的元素值是不确定的。下述dummy数组的元素值取决于数组分配前相应内存单元的当前状态。 1double dummy[1000]; //元素值不确定 数组定义时，如果将[ ]内的元素个数留空，编译器会通过初始化列表中的元素个数来确定数组的大小。下述示例中，dummy数组的元素个数将为4。 12double d[] = &#123;1.2,3.2,888,99.12&#125;;printf(\"%d\",sizeof d / sizeof(double)); //元素个数 = 数组尺寸 / 元素尺寸 上述代码第2行的sizeof d等价于sizeof(d)。当对一个不是数据类型的对象/变量应用sizeof操作符时，括号可以省略。对于数组，有下述等式成立：$$元素个数 = 数组尺寸（字节数） / 元素尺寸（字节数）$$在C++ 11中，初始化数组时，初始化列表前的等号可以省略，如下述代码所示： 12char d1[5] &#123;'a',120,'K',',','?'&#125;;char d[] &#123;12.0,'L',250&#125;; //报错：250超出储值范围，12.0类型收窄 上述代码的第2行会被编译器拒绝。C++ 11会对初始化列表中的值进行检查，其中，250超出了char的储值范围，12.0属于double类型的字面量，将其转换成char类型存在类型收窄（narrowing）。 算法 - 折半查找【未完成】 算法 - 冒泡排序当水里有气泡时，气泡的密度比水小，水的浮力大于气泡的重力，上浮。而水面的石头则注定下沉。冒泡排序(bubble sort)即得名于此。请注意，这里的所谓浮、沉、轻和重只是形象化的描述，不要机械理解。 如下图中的9个整数所构成的序列。现在我们要进行非递减，也就是递增排序。我们从前（下标0）往后两两比较，如果左边的元素大于右边的元素，则两两交换。如下例，9与3比较，9&gt;3，交换；9与1比较, 9&gt;1，交换；9与4比较, 9 &gt; 4，交换 … 最后9与5比较，9 &gt; 5，交换。经过这一轮共8次的两两比较以及次数不确定的交换，我们发现，序列中最大的那个元素9到了序列的尾部，即下标8的位置。而这个位置正好是元素9在排序后的目标位置。 图5- 第1轮冒泡排序过程（前3次比较/交换） 经过一轮冒泡，9来到了序列最右端的目标位置： 图5- 第1轮冒泡后的序列 此时，我们可以认为9个元素中的前8个是无序的，而最后一个元素无需参与后续的排序。所以我们把前8个元素构成的子序列再来一轮从左至右的冒泡。在这一轮里，我们总共进行7次两两比较。最后，子序列中最大的元素8也到达了目标位置，即子序列的最后端。 图5- 第2轮冒泡后的序列 同样，我们可以把前7个元素构成的子序列再来一轮冒泡；… 把前2个元素构成的子序列再来一轮冒泡。最后，全部元素都达到了目标位置，排序完成，如下图： 图5- 完成冒泡排序后的序列 总结：对于由n个元素组成的序列，如果进行冒泡排序，总共要进行n-1轮的冒泡。第一轮的冒泡执行n-1次比较，第二轮冒泡执行n-2次比较，… 最后一轮冒泡执行1次比较。故，比较运算的总次数为：n-1 + n-2 + n-3 + … + 2 + 1 ，这是一个等差数列， 其和等于n(n-1)/2。如果以后读者学习算法或者数据结构课程，会进一步地将该式简化成仅评估n的阶，用符号表达为Θ(n2)。在算法分析的术语里，我们称冒泡排序的计算复杂性为Θ(n2)。 下面是冒泡排序的C语言示例代码： 123456789101112131415161718192021222324//Project - BubbleSort#include &lt;stdio.h&gt;void bubbleSort(int a[], const int n)&#123; for (int i=n-1;i&gt;0;i--) for (int j=0;j&lt;i;j++)&#123; if (a[j] &gt; a[j+1])&#123; int t = a[j]; a[j] = a[j+1]; a[j+1] = t; &#125; &#125;&#125;int main() &#123; int data[] = &#123;3,9,1,4,7,6,5,8,2&#125;; bubbleSort(data,9); printf(\"Sorted array: \"); for (int i=0;i&lt;9;i++) printf(\"%d,\",data[i]); return 0;&#125; 上述程序的执行结果为： 1Sorted array: 1,2,3,4,5,6,7,8,9, 第4 ~ 13行：定义了一个名为bubbleSort的函数。该函数接受一个整数数组a，以及一个整数n作为参数。其中，n代表参数数组a内的元素个数。该函数对a数组内的元素进行冒泡非递减排序。 形式参数a的后面打了一个方括号[ ]，这种形式表示参数a实际为一个整数数组。请注意，当第17行将实参data传递给bubbleSort( )的形参a时，并不是将整个数组传递过来，实际被传递的是数组名，即data数组首元素的地址。由于数组名a所关联的地址值与data相同，所以，bubbleSort( )函数内对a数组元素的修改，事实上就是对外部的data数组的修改。 形式参数n的类型为const int，系常量型整数。相较于变量，除了初始化赋值之外，常量型对象是不可以被修改的。将形参n设定为常量型是有好处的：按照程序逻辑，bubbleSort( )函数预期不应修改代表数组元素个数的对象n，如果不小心在bubbleSort( )函数内错误修改n的值，编译器会报错。 bubbleSort( )函数内进行了双重循环。其中，外层循环中的i表示进行本轮冒泡排序的元素范围为a[0] ~ a[i]，本例中，取值依次为 8、7、6、5、4、3、2、1（不含0）。内层循环中的j表示从左到右两两比较的左元素的下标，右元素的下标为j+1。本例中，当i=8时,（j, j+1)依次取(0,1)、(1,2)、(2,3)、(3,4)、(4,5)、(5,6)、(6,7)、(7,8)。 当进行非递减排序时，if子句中使用&gt;，否则使用&lt;。 第8 ~ 10行交换a[j]和a[j+1]的值，引入了一个临时变量t。t负责保存a[j]在被覆盖赋值之前的值，以便在稍后传递给a[j+1]。 1int data[] = &#123;3,9,1,4,7,6,5,8,2&#125;; 第16行：定义并初始化了data数组。 1bubbleSort(data,9); 第17行：调用执行bubbleSort( )函数对data数组进行了非递减冒泡排序。再次强调，data实参传递给bubbleSort( )函数的形参a时，只传递了函数名，即数组的首元素地址。 123printf(\"Sorted array: \");for (int i=0;i&lt;9;i++) printf(\"%d,\",data[i]); 第19 ~ 21行：打印输出排序后的data数组的全部元素。输出结果证实，排序正确无误。 如果读者还是不太明白，那么拿出一支笔，一张纸， 把自己当成一台计算机，来一次上述程序的模拟执行，或许有用。 5.4 C风格字符串5.4.1 字符数组在前述章节中，我们已经无数次使用过用双引号包裹的字符串字面量，比如”Hello World”。下述C语言程序有助于我们理解字符串的本质，即元素类型为字符的一维数组。 12345678910111213141516171819//Project - CStyleString#include &lt;stdio.h&gt;int main() &#123; char s1[] = \"hello\"; printf(\"s1 = %s, addr = %p, sizeof s1: %lld\\n\", s1, s1, sizeof s1); printf(\"s1 = %d %d %d %d %d %d\\n\",s1[0],s1[1],s1[2],s1[3],s1[4],s1[5]); char s2[256] = \"forrest\"; int i = 0; while (s2[i]!=0)&#123; s2[i] = s2[i] + ('A' - 'a'); i++; &#125; printf(\"s2 = %s, addr = %p, sizeof s2: %lld\\n\", s2, s2, sizeof s2); printf(\"'A' = %d, 'a' = %d\",'A','a'); return 0;&#125; 上述程序的执行结果为： 1234s1 &#x3D; hello, addr &#x3D; 000000000061FE06, sizeof s1: 6s1 &#x3D; 104 101 108 108 111 0s2 &#x3D; FORREST, addr &#x3D; 000000000061FD00, sizeof s2: 256&#39;A&#39; &#x3D; 65, &#39;a&#39; &#x3D; 97 说明：在读者计算机上，输出结果中的地址很可能与本书不同。 图5- s1的存储结构 我们结合图5- 来解读上述程序中关于字符串s1的部分。如执行结果的第1行所示，在作者的计算机上，由5个字符构成的”hello”占据了从地址0x0061FE06开始的连续6个字节的内存空间。其中，每个字节存储一个字符。多出来的一个字节是由编译器主动添加的，其值为整数0，用于表示字符串的终止。 如第2章所述，char类型的实质是单字节的有符号整数。图5- 的第2行显示了s1的6个字节的整数值，第1行则显示了这些整数值对应的ASCII码字符。需要注意的是，最后1个字节存储的是整数0，其对应的转义字符为’\\0’，它并不是字符‘0’，字符‘0’的ASCII码值为48。 1char s1[] = \"hello\"; 第5行：定义了字符数组s1，元素个数从字符串字面量统计而得，编译会主动添加1个字节并将其赋值为整数0，以表示字符串的终止。 1printf(\"s1 = %s, addr = %p, sizeof s1: %lld\\n\", s1, s1, sizeof s1); 第6行：占位符%s按字符串方式输出s1，可以想象，printf( )在执行占位符替换的过程中，会逐一考察构成s1数组的每一个元素，如果其值不为0，则转换输出其对应的ASCII字符，如果等于0，则终止。占位符%p按地址/指针形式输出s1，按本章稍早的讨论，数组名s1即为该数组首元素的地址。sizeof s1取得s1数组的内存空间大小，为6个字节。 1printf(\"s1 = %d %d %d %d %d %d\\n\",s1[0],s1[1],s1[2],s1[3],s1[4],s1[5]); 第7行：使用下标获得s1每个元素的值，并按照整数输出。所得即为s1存储空间内6个字节的整数值。其结果与图5- 的第2行相符。 图5- s2的存储结构 我们结合图5- 来解读上述程序中关于字符串s2的部分。如执行结果的第3行所示，在作者的计算机上，s2占据了从地址0x0061FD00开始的连续256个字节的内存空间。其中，前7个字节存储了7个字符，剩余的字节全部被初始化为整数0，用于表示字符串的终止。 1char s2[256] = \"forrest\"; 第9行：定义并初始化了字符数组s2，除了前7个字符，后续的256 - 7个字节的空间都被初始化为整数0值。 12345int i = 0;while (s2[i]!=0)&#123; s2[i] = s2[i] + ('A' - 'a'); i++;&#125; 第10 ~ 14行：通过while循环从头开始逐一遍历s2的每一个字节，如果其值不为0，则将其值减去32。上述过程一直持续到遇到0为止。直观上，该while循环将字符串内的全部小写字符转换成对应的大写字符。读者如果翻看ASCII码表，即可发现小写字母与其对应的大写字母的码值正好差32。但作者在编写上述代码时，并不记得小写字母与大写字母的码差为32，就顺手通过’A’ - ‘a’来获得上述码差。 1printf(\"s2 = %s, addr = %p, sizeof s2: %lld\\n\", s2, s2, sizeof s2); 第15行：输出s2字符串，s2的地址，以及s2的大小。 1printf(\"'A' = %d, 'a' = %d\",'A','a'); 第17行：通过%d占位符输出字符’A’及’a’的ASCII码值，从输出结果看，’A’ - ‘a’ = 65 - 97 = -32。 区别于C++标准模板库中的string类型，上述以字符数组形式实现的字符串称为C风格的字符串（C-style string）。 需要注意的是，C/C++用单引号包裹单个字符，用双引号包裹字符串，不可混淆使用。请见下述代码及其注释。 1234char c = 'c'; //正确：单引号包裹单个字符char d = \"d\"; //错误：双引号包裹字符串char e[] = \"e\"; //正确char f[] = 'f'; //错误 5.4.2 字符串运算string.h头文件引入了一些与C风格字符串相关的函数，通过这些函数，可以对字符串进行比较、拼接等运算。请见下述C语言示例： 12345678910111213141516171819//Project - StringOperation#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main() &#123; char s1[256] = \"Hello\"; printf(\"s1 = %s, len = %lld\\n\",s1, strlen(s1)); char s2[512] = \"World\"; printf(\"strcmp(s1,s2) = %d\\n\",strcmp(s1,s2)); char s3[512]; strcat(s1,\" \"); //给s1附加一个空格 strcat(s1,s2); strcpy(s3,s1); printf(\"s1 = %s, s2 = %s, s3 = %s\",s1,s2,s3); return 0;&#125; 上述代码的执行结果为： 123s1 &#x3D; Hello, len &#x3D; 5strcmp(s1,s2) &#x3D; -1s1 &#x3D; Hello World, s2 &#x3D; World, s3 &#x3D; Hello World 1printf(\"s1 = %s, len = %lld\\n\",s1, strlen(s1)); 第7行：strlen(s1)函数返回s1字符串包含的字符个数，其返回类型为size_t，在作者的计算机上，size_t即unsigned long long类型。其输出结果可知，该函数返回的是实际字符个数，而不是s1数组的内存大小。strlen的函数名来自英文string length。 1printf(\"strcmp(s1,s2) = %d\\n\",strcmp(s1,s2)); 第10行：strcmp(s1,s2)函数将字符串s1和s2作比较，其返回类型为int。如果s1 &gt; s2，返回&gt;0的整数，如果s1 &lt; s2，返回&lt;0的整数，如果两者相等，返回0。所谓字符串比较，事实上是从前到后进行字符的逐一比较，而字符的比较，即比较字符的ASCII码值。由于’H’的ASCII码值 &lt; ‘W’，所以s1 &lt; s2，本例中该函数返回了-1，见执行结果的第2行。strcmp的函数名来自英文string comparison。 12strcat(s1,\" \"); //给s1附加一个空格strcat(s1,s2); 第13 ~ 14行：strcat(s1,s2)函数将s2字符串附加在s1字符串的后面。同样基于执行速度的考虑，该函数不会对s1数组的空间进行越界检查，保证s1数组的剩余空间足够容纳s2的内容，是程序员的职责。C语言中的数组，其存储空间的大小是在定义时确定的，无法在执行过程中被改变。strcat的函数名来自英文string concatenation。 1strcpy(s3,s1); 第15行：strcpy(s3,s1)函数将字符串s1的内容复制到字符串s3。复制过程中，s3的原内容会被覆盖。同样，程序员需要自行确保s3的空间足够大。strcpy的函数名来自英文string copy。 参考文档：C/C++的标准库里有数量众多的函数、类型、算法等内容，了解其用法的最佳途径是查询C/C++的参考文档。互联网上有诸多网站提供上述内容，在搜索引擎中以关键字C++ Reference或者C Reference搜索可得。 5.5 C++字符串C风格字符串本质上是字符类型的一维数组，而数组的长度是在定义时就确定且在程序运行过程中无法修改的。如果试图往字符数组中复制超过其容量的字符串，会导致越界访问问题。C++引入了新的string类型，该类型的对象的“大小”可以根据需要自动变化。 下述C++程序可以帮助我们理解string类型的使用方法： 1234567891011121314151617181920212223242526272829//Project - CppString1#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() &#123; string s1 &#123;\"hello\"&#125;; for (unsigned int i=0;i&lt;s1.size();i++) s1[i] += ('A' - 'a'); cout &lt;&lt; \"s1 = \" &lt;&lt; s1 &lt;&lt; \", size = \" &lt;&lt; s1.size() &lt;&lt; \", sizeof(s1) = \" &lt;&lt; sizeof(s1) &lt;&lt; endl; string s2 = \" World!\"; string s3 = s1 + s2; s1 += s2; s2 = \"Hello\" + s2; cout &lt;&lt; \"s1 = \" &lt;&lt; s1 &lt;&lt; \" s2 = \" &lt;&lt; s2 &lt;&lt; \" s3 = \" &lt;&lt; s3 &lt;&lt; endl; string s4 = \"Life is a box of chocolates, you...\"; cout &lt;&lt; \"s4.substr(17,10) = \" &lt;&lt; s4.substr(17,10) &lt;&lt; endl; auto iPos = s4.find(\"chocolates\"); cout &lt;&lt; \"s4.find(\\\"chocolates\\\") = \" &lt;&lt; iPos &lt;&lt; endl; s4.replace(iPos,10,\"CHOCOLATES\"); cout &lt;&lt; \"s4 after replace = \" &lt;&lt; s4 &lt;&lt; endl; return 0;&#125; 上述代码的执行结果为： 12345s1 &#x3D; HELLO, size &#x3D; 5, sizeof(s1) &#x3D; 32s1 &#x3D; HELLO World! s2 &#x3D; Hello World! s3 &#x3D; HELLO World!s4.substr(17,10) &#x3D; chocolatess4.find(&quot;chocolates&quot;) &#x3D; 17s4 after replace &#x3D; Life is a box of CHOCOLATES, you... 说明：在不同开发环境下，第一行sizeof(s1)的输出结果可能与本书不同。 1#include &lt;string&gt; 第3行：string头文件引入了string类型。同int, float这些内置类型一样，string也属于一种数据类型。区别在于，int, float是C++原生的，而string是由string头文件定义并介绍给编译器的。 1string s1 &#123;\"hello\"&#125;; 第7行：定义了string类型的对象s1，并使用一个C风格的字符串初始化了s1。 12for (unsigned int i=0;i&lt;s1.size();i++) s1[i] += ('A' - 'a'); 第8 ~ 9行：通过for循环遍历并修改了s1内的每个字符，将其由小写变为大写。 s1.size( )是s1对象的成员函数（member function），它返回s1对象内包含的字符个数。该函数的返回类型为size_t，即unsigned long long，与之匹配，循环变量i的类型设定为unsigned int。如果按照常规将i的类型定义为int，即有符号整数，编译器可能会给出“有符号整数与无符号整数比较”的警告。使用一个对象的成员函数的语法是：对象名.函数名(&lt;实参列表&gt;)。 s1[i]用于访问s1字符串内的第i个字符。与C风格的字符串数组不同，s1[i]在语法上类似于访问数组元素，但实质上是一次“操作符函数调用”▲。 12cout &lt;&lt; \"s1 = \" &lt;&lt; s1 &lt;&lt; \", size = \" &lt;&lt; s1.size() &lt;&lt; \", sizeof(s1) = \" &lt;&lt; sizeof(s1) &lt;&lt; endl; 第10 ~ 11行：从输出结果的第1行可见，s1被成功转换成了大写形式。size( )函数返回值为5，与实际情况相符。sizeof(s1)返回值为32，这表示s1对象的内存尺寸。 12345string s2 = \" World!\";string s3 = s1 + s2;s1 += s2;s2 = \"Hello\" + s2;cout &lt;&lt; \"s1 = \" &lt;&lt; s1 &lt;&lt; \" s2 = \" &lt;&lt; s2 &lt;&lt; \" s3 = \" &lt;&lt; s3 &lt;&lt; endl; 第13 ~ 17行：通过+操作符可以实现string字符串的拼接，其作用类似于C风格字符串的strcat( )函数。同时，还应注意到，+操作符即可以拼接两个string对象，也可以将一个string对象与一个C风格字符数组相加，均返回拼接好的新的string对象。在第15行，我们还看到了+=操作符的使用。上述+，+=的功用与strcat( )函数类似，但用起来要简单和直观很多。以后我们会学到，这里的+以及+=并不是普通的操作符，其实质是重载的操作符函数▲。请结合输出结果的第2行理解上述代码。 12string s4 = \"Life is a box of chocolates, you...\";cout &lt;&lt; \"s4.substr(17,10) = \" &lt;&lt; s4.substr(17,10) &lt;&lt; endl; 第19 ~ 20行：s4.substr(17,10）截取s4字符串中从第17个字符开始的连续10个字符，并返回截取的子串，类型为string。请注意，所谓第17个字符，是从0开始计数的。输出结果的第3行可见截取出来的子串为”chocolates”。 12auto iPos = s4.find(\"chocolates\");cout &lt;&lt; \"s4.find(\\\"chocolates\\\") = \" &lt;&lt; iPos &lt;&lt; endl; 第22 ~ 23行：s4.find(“chocolates”)函数返回”chocolates”子串在s4中出现的位置（下标）。输出结果的第4行证实，其位置下标为17。 12s4.replace(iPos,10,\"CHOCOLATES\");cout &lt;&lt; \"s4 after replace = \" &lt;&lt; s4 &lt;&lt; endl; 第25 ~ 26行：s4.replace(iPos,10,”CHOCOLATES”)将s4中从iPos下标（即17）开始的连续10个字符替换成”CHOCOLATES”，输出结果的第5行证实了上述操作成功完成。 当使用string类型的对象来存储字符串时，我们完全不用担心容量问题。在现代计算机上，往一个string类型的对象s内往入一本莎士比亚全集毫无压力。事实上，无论我们给string对象s装入多大长度的字符串，sizeof(s)为固定值，即s对象的内存尺寸不会变大。那么？ 字符串存在哪里了？string类型的对象是如何管理字符串的存储空间的？这些问题需要到本书稍后部分才能解释清楚。 char类型只包含1个字节的存储空间，而1个字节最多最能表达256种不同的值。如果只表达英文字符及其符号，1个字节足够。但其它文字，比如中文，其“字符”有数万之多。在编码其它语言文字时，可能会使用到不同的多字节编码方案。 详情请阅读下述扩展。 扩展：【？未完成】 UTF-8编码及非英文字符的处理与显示 为了便于处理不同的文字编码方案，C++引入了wstring及wchar_t类型，C++ 11引入了u16string、u32string、char16_t以及char32_t类型。下述示例中，L, u, U前缀分别表明对应的字符串字面量属于wchar_t、char16_t以及char32_t类型。 12345678wstring s1 = L\"Run, Forrest.\"; //wchar_t 字符串wchar_t s2[] = L\"Run, Forrest.\";u16string s3 = u\"Run, Forrest.\";char16_t s4[] = u\"Run, Forrest.\";u32string s5 = U\"Run, Forrest.\";char32_t s6[] = U\"Run, Forrest.\"; 一些第三方的开发包，提供了比C++标准库中的string更优秀的字符串解决方案。比如，Qt中的QString类型，MFC中的CString类型。 5.6 二维数组在日常工作生活中，经常会遇到二维的数据表格。比如，某学业导师指导了4位学生，每位学生都在2020年春季学期选修了相同的5门课。到期末时，导师可能会汇总出下述成绩单： 表5- 成绩单 课程0 课程1 课程2 课程3 学生0 67 98 77 80 学生1 56 89 45 76 学生2 78 69 96 67 学生3 88 19 78 55 在5.1节中，我们使用一维数组float scores[5]来表示一个学生的5门课程的成绩。 那么要表示上述4位同学的成绩，应该如何表达呢？ 其中一种解决方案是使用4个一维数组： 1234float scores0[5] = &#123;67, 98.5, 77, 100, 86&#125;; //学生0的成绩float scores1[5] = &#123;56, 89, 45, 76, 63&#125;; //学生1的成绩float scores2[5] = &#123;78, 69, 96, 67, 99&#125;; //学生2的成绩float scores3[5] = &#123;88, 19, 78, 55, 68&#125;; //学生3的成绩 如果只有4个学生，使用上述方法或许是可行的，那如果有5万学生呢？ 使用5万行代码定义5万个一维数组？ 这显然不是个好主意。 既然平面表格可以是二维（行+列两个维度）的，那么计算机内的数组也可以是二维的。下述C语言程序演示了二维数组的定义和使用方法： 12345678910111213141516171819202122232425//Project - TwoDim#include &lt;stdio.h&gt;int main() &#123; float scores[4][5] = &#123; &#123;67, 98, 77, 80, 86&#125;, &#123;56, 89, 45, 76, 63&#125;, &#123;78, 69, 96, 67, 99&#125;, &#123;88, 19, 78, 55, 68&#125; &#125;; scores[1][2] = 100; printf(\"scores = %p, sizeof(scores) = %lld\\n\",scores, sizeof(scores)); printf(\"scores[0~3] = %p %p %p %p\\n\",scores[0],scores[1],scores[2],scores[3]); printf(\"&amp;scores[1][0~2] = %p %p %p\\n\",&amp;scores[1][0],&amp;scores[1][1],&amp;scores[1][2]); printf(\"&amp;scores[1~2][1] = %p %p\\n\",&amp;scores[1][1], &amp;scores[2][1]); float fSum = 0; for (unsigned int j=0;j&lt;5;j++) fSum += scores[1][j]; float fAverage = fSum / 5; printf(\"Average of scores[1][0~4] = %.2f\",fAverage); return 0;&#125; 在作者的计算机上，上述程序的执行结果为： 12345scores &#x3D; 000000000061FDC0, sizeof(scores) &#x3D; 80scores[0~3] &#x3D; 000000000061FDC0 000000000061FDD4 000000000061FDE8 000000000061FDFC&amp;scores[1][0~2] &#x3D; 000000000061FDD4 000000000061FDD8 000000000061FDDC&amp;scores[1~2][1] &#x3D; 000000000061FDD8 000000000061FDECAverage of scores[1][0~4] &#x3D; 76.80 说明：在读者的计算机上，输出结果中的地址很可能与本书不同，但其分布规律应与本书相同。 123456float scores[4][5] = &#123; &#123;67, 98, 77, 80, 86&#125;, &#123;56, 89, 45, 76, 63&#125;, &#123;78, 69, 96, 67, 99&#125;, &#123;88, 19, 78, 55, 68&#125;&#125;; 第5 ~ 10行：定义了名为scores的二维数组，元素类型为float，分4行5列。第5行的float scores[4][5]可以简写为float scores[ ][5]，让编译器自动从初始化列表中统计行数。但是，编译器不允许列数5空缺。因为是二维数组，scores的初始列表使用了两层{ }来包裹。 图5- 二维数组的内存布局 说明：数组的内存地址是在运行时刻由操作系统分配的，所以读者在自己计算机上获得的scores二维数组的内存地址很可能与图5- 不同。图中的每个单元格代表4个字节的存储空间，每4个字节的存储空间正好可以存入一个float类型的对象。 从逻辑上看，数组是二维的，但计算机的内存是一维的。图5- 展示了二维数组scores是如何布局在一维的计算机内存中的。scores数组4行5列，共20个float，每个float占4个字节， 20 x 4 = 80字节。图中可见，scores数组占据了从地址0x0061FDC0开始的连续80个字节的空间，所有的元素，按照先行后列的顺序逐一排列。其中，第1行scores[0]占据了从地址0x0061FDC0开始的边续20个字节的空间，第2行scores[1]则占据了从地址0x0061FDD4开始的边续20个字节的空间，然后是第3和第4行。二维数组的每一行可以视为一个一维数组，在这些一维数组的内部，其元素排列与普通的一维数组完全相同。 1scores[1][2] = 100; 第11行：scores[1][2]代表了数组第1行，第2列的元素，即表5- 中学生1的课程2成绩。通过赋值，程序将该值由45改为100。 1printf(\"scores = %p, sizeof(scores) = %lld\\n\",scores, sizeof(scores)); 第13行：将二维数组名scores按照地址/指针格式打印，从输出结果的第1行可见，数组名scores的值仍为数组首元素，即第0行第0列元素的地址。sizeof(scores)返回该二维数组的空间大小，为80个字节。 1printf(\"scores[0~3] = %p %p %p %p\\n\",scores[0],scores[1],scores[2],scores[3]); 第14行：scores[i]指二维数组的第i行，它可以视为一个一维数组。我们将scores[0 ~ 3]以地址/指针格式打印，从输出结果的第2行可见，scores[i]的值为该一维数组的首元素地址。实践中，我们可以将scores[i]视为该一维数组的数组名。 1printf(\"&amp;scores[1][0~2] = %p %p %p\\n\",&amp;scores[1][0],&amp;scores[1][1],&amp;scores[1][2]); 第15行： 通过&amp;操作符，我们获得了scores[1][0]、scores[1][1]、scores[1][2]的地址并打印，输出结果的第3行证实，在一维数组scores[1]中，其内部元素是依次排列的。 1printf(\"&amp;scores[1~2][1] = %p %p\\n\",&amp;scores[1][1], &amp;scores[2][1]); 第16行：我们打印输出了元素scores[1][1]和scores[2][1]的内存地址，见输出结果的第4行。如果读者将两个地址相减，其值应为20。这说明，二维数组中，相邻行的同列元素之间地址差正好等于一行元素的空间大小。 12345float fSum = 0;for (unsigned int j=0;j&lt;5;j++) fSum += scores[1][j];float fAverage = fSum / 5;printf(\"Average of scores[1][0~4] = %.2f\",fAverage); 第18 ~ 22行：统计并打印了学生1，即scores数组第1行的平均值。 同一维数组一样，当我们通过a[i][j]去访问二维数组a第i行第j列的元素时，计算机也必须先求得该元素在内存中的地址。计算公式如下：$$\\begin{aligned}a[i][j]的地址 &amp;= 首元素的地址 + i \\times 单行元素的尺寸 + j \\times 单个元素的尺寸 \\&amp;= a + i \\times (单个元素的尺寸 \\times 单行元素个数 ) + j \\times 单个元素的尺寸 \\&amp;= a + i \\times (sizeof(ElementType) \\times 列数) + j \\times sizeof(ElementType)\\end{aligned}$$以上述公式为基础，我们尝试计算scores[2][1]的地址：$$\\begin{aligned}scores[2][1]的地址 &amp;= 首元素的地址 + i \\times 单行元素的尺寸 + j \\times 单个元素的尺寸 \\&amp;= scores + i \\times (sizeof(float)\\times5) + j\\times sizeof(float)\\&amp;= 0x0061FDC0 + 2\\times(4\\times5) + 1\\times4 \\&amp;= 0x0061FDC0 + 40 + 4 \\&amp;= 0x0061FDEC\\end{aligned}$$计算结果与上例输出结果的第4行一致。从计算过程可知，计算机依赖于每行的元素个数，即列数来计算单个元素的存储位置，这就是二维数组scores[4][5]被定义时，行数4可以省略，但列数5不能被省略的理由。 同样地，C/C++不会对二维数组的越界访问进行检查，保证只访问”属于“该数组的元素，是程序员的职责。 算法 - 矩阵乘积的计算【?缺】 5.7 多维数组*多维数组与二维数组本质相同，只是维度更多而已。下述C语言代码定义并使用了数组名为a的三维数组： 12345678910111213141516171819//Project - ThreeDim#include &lt;stdio.h&gt;int main()&#123; short a[2][2][3] = &#123; &#123; &#123;0,1,2&#125;, &#123;10,11,12&#125; &#125;, &#123; &#123;100,101,102&#125;, &#123;110,111,112&#125; &#125; &#125;; printf(\"a = %p, sizeof(a) = %lld\\n\",a,sizeof(a)); printf(\"a[1][1][1] = %d\",a[1][1][1]); return 0;&#125; 上述代码的执行结果为： 12a &#x3D; 000000000061FE00, sizeof(a) &#x3D; 24a[1][1][1] &#x3D; 111 第5 ~ 14行：定义了一个2x2x3的三维数组，该数组包含两个2行3列的二维数组。上述代码中可见，a数组的初始化列表用了三层{ }包裹。同样地，该数组被定义时，程序员可以省略0维的元素个数（本例中为2），让编译器从初始化列表中统计，但1维和2维的元素个数（本例中为2和3）不可以省略。 a数组是三维数组的数组名，其维度信息可以表示为（2，3，3）；a[0]、a[1]则可视为二维数组的数组名，其维度为（2，3）；a[1][1]则可视为一维数组的数组名，它包含3个元素。 1printf(\"a = %p, sizeof(a) = %lld\\n\",a,sizeof(a)); 第16行：将数组名a以地址/指针格式输出，结果可见，数组名a为a数组中首元素，即a[0][0][0]的地址。数组a中有2 x 2 x 3 = 12个元素，每个short占2两个字节，故sizeof(a)的返回值为24。 1printf(\"a[1][1][1] = %d\",a[1][1][1]); 第17行：输出了元素a[1][1][1]的值。该元素的内存地址计算公式与上节所述的二维数组类似。 6. 指针及引用本讲义系重庆大学C/C++课程的教学笔记。 作者： 陈波 chenbo@cqu.edu.cn， All rights reserved. 未经作者许可，不允许经由互联网展示或提供下载。 不允许以纸质出版为目的进行摘抄或改编。 C/C++中的指针（pointer）是无数初学者的噩梦，也是造成C/C++难学难用的原因之一。很多其它的程序设计语言，包括著名的Java，都避免引入指针，以简化语法。 6.1 指针指针是一个值为内存地址的对象，它既可以是变量，也可以是常量。请先阅读下述C语言程序： 1234567891011121314151617//Project - PointerBasic#include &lt;stdio.h&gt;int main()&#123; int a = 9999, *p; p = &amp;a; printf(\"before: a = %d, *p = %d\\n\", a, *p); a++; *p = *p + 100; printf(\"after: a = %d, *p = %d\\n\", a, *p); printf(\"&amp;a = %p, p = %p, sizeof(p) = %lld\\n\", &amp;a, p, sizeof(p)); printf(\"&amp;p = %p\", &amp;p); return 0;&#125; 上述代码的执行结果为： 1234before: a &#x3D; 9999, *p &#x3D; 9999after: a &#x3D; 10100, *p &#x3D; 10100&amp;a &#x3D; 000000000061FE1C, p &#x3D; 000000000061FE1C, sizeof(p) &#x3D; 8&amp;p &#x3D; 000000000061FE10 说明：在读者计算机上，第3 ~ 4行的地址及sizeof(p)可能与本书不同。 1int a = 9999, *p; 第5行：定义了类型为int的变量a，初始化其值为9999；变量名p前加了一个*号，该星号表明，变量p是一个指向int类型对象的指针，它预期用于存储一个int类型对象的内存地址，其数据类型简写为int*。 1p = &amp;a; 第6行：取变量a的地址，赋值给指针变量p。对一个int类型的变量a使用&amp;操作符，其返回的地址为一个int对象的地址，简写为int*。同时，变量p的类型也为int*，第6行赋值操作符两端操作数（operand）的类型相同。下表列出了本例中第6行执行完成后变量a与p的状态。 表6- a与p的状态 变量名 类型 值 内存地址 a int 9999 0x0061FE1C p int* 0x0061FE1C 0x0061FE10 从表中可见，p的值即为a的地址。同时，p作为一个变量，也有自己的内存空间以及地址。 图6- a与p的内存布局 借助于本程序的输出结果，我们绘制了变量a与p的内存布局图6- 。图中可见，a变量占据了从地址0x0061FE1C开始的连续4个字节的空间，p变量则占据了从地址0x0061FE10开始的连续8个字节的空间。在64位编译器下，指针/地址占据8个字节，共64个比特的空间。编译器出于某些考虑（比如内存对齐），在p和a的内存之前留下了一些空白内存，请见图中两者之间的灰色单元格。 1printf(\"before: a = %d, *p = %d\\n\", a, *p); 第8行：在int类型的指针变量p前打上一个\\号，*p，其含义为取指针p所指向的对象，也可称为取p所存地址处的对象。本例中，*p即为对象a，其类型为int。此处的*号与作为乘法运算符的星号是不同的操作符，它称为间接操作符（indirection operator），也可称作解引用操作符（dereferencing operator）。从输出结果的第1行可见，a和*p的值均为9999，它们事实上关联同一个值。 12a++;*p = *p + 100; 第9 ~ 10行：先通过a++把a的值增加了1，然后通过*p把a值增加了100。这两行代码执行后，a值预期应为9999 + 1 + 100 = 10100。 1printf(\"after: a = %d, *p = %d\\n\", a, *p); 第11行：再次输出了a和*p的值，同为10100。如前所述，*p事实上就是a。 1printf(\"&amp;a = %p, p = %p, sizeof(p) = %lld\\n\", &amp;a, p, sizeof(p)); 第13行：输出变量a的地址&amp;a，以及指针p的值，还有sizeof(p)。从执行结果的第3行可见，指什p的值即为变量a的地址；在作者的计算机上，p对象占据8字节内存。 1printf(\"&amp;p = %p\", &amp;p); 第14行：既然指针变量p也是一个变量，那么它也有内存空间，而内存空间，一定有地址。通过&amp;p取得p的地址并输出，得执行结果的第4行。 6.2 空指针当一个指针对象的值为0时，该指针事实上不能指向任何对象，我们称该指针为空指针（null pointer）。请阅读下述C语言程序： 12345678910111213//Project - NullPointer#include &lt;stdio.h&gt;int main() &#123; double d = 3.14; double* p = NULL; //等价于double *p = (double*)0; printf(\"p = NULL = %p\\n\", p); //*p = 3.14 + 1; //对一个空指针应用间接操作符会引发执行错误 p = &amp;d; printf(\"p = &amp;d = %p, *p = d = %f\", p, *p); return 0;&#125; 上述代码的执行结果为： 12p &#x3D; NULL &#x3D; 0000000000000000p &#x3D; &amp;d &#x3D; 000000000061FE10, *p &#x3D; d &#x3D; 3.140000 说明：在读者的计算机上，执行结果第2行中的地址很可能与本书不同。 1double* p = NULL; //等价于double *p = (double*)0; 第6行：该行中，double* p与double p两种写法等价，编译器并不在意\\号在double和p之间的位置。在Qt Creator环境中，用鼠标右键单击第6行的NULL，然后选择Find References to Symble Under Cursor。如图6- 。 图6- 查找NULL的引用 接下来，可在Qt Creator的下方窗口中看到本项目中有两个文件引用/使用了NULL。 图6- NULL的引用文件 双击打开stdio.h，可以关于NULL的下述定义： 123#define NULL 0LL...#define NULL ((void *)0) 根据不同的编译器设置，NULL的定义将是上述二者之一： 0LL，即为long long类型的字面量0； ((void)0)，整数0，经显式类型转换为void\\。这里的void*表示一种特殊的指针类型，它表示对象是一个指针，但这个指针所指向的对象类型不确定。 无论NULL的定义是上述哪一种，指针p = NULL执行后，p的值将为整数0，这表示一个非法的地址。 1printf(\"p = NULL = %p\\n\", p); 第7行：将p值按地址格式输出，执行结果的第1行可见，p值为0。 1//*p = 3.14 + 1; //对一个空指针应用间接操作符会引发执行错误 第8行：当p为一个空指针时，不可以对其使用间接操作符*，否则会引发执行错误。 1p = &amp;d; 第10行：将d的地址赋值给指针p，赋值完成后，p指向d，不再是空指针。 1printf(\"p = &amp;d = %p, *p = d = %f\", p, *p); 第11行：打印p以及*p，执行结果的第2行可见，p有一个合法的地址值，*p即为d值3.14。 上述讨论中，我们知道，当NULL是由编译器预处理指令定义的，其值为0。而字面量0，既可以视作整数，也可以视作void类型的指针，其类型具有不确定性。这种类型不确定性在C++里会带来其他问题。*【C++ 11】引入了一个新的关键字nullptr**来表示空指针，虽然事实上nullptr也是0值，但其有确定的类型，即std::nullptr_t。 我们建议读者在编写C++ 11及其之后版本的C++程序时，永远使用nullptr，不要使用NULL或整数0来代表空指针。关于nullptr的使用，请阅读下述C++程序： 123456789101112131415//Project - NullPtr#include &lt;iostream&gt;#include &lt;stdio.h&gt;using namespace std;int main() &#123; char c &#123;'c'&#125;; char* p &#123;nullptr&#125;; printf(\"p = nullptr = %p\\n\", p); p = &amp;c; printf(\"p = &amp;c = %p, c = %c, *p = %c\", p, c, *p); return 0;&#125; 上述程序的执行结果为： 12p &#x3D; nullptr &#x3D; 0000000000000000p &#x3D; &amp;c &#x3D; 000000000061fe17, c &#x3D; c, *p &#x3D; c 说明：在读者计算机上，执行结果第2行中的地址很可能与本书不同。 因为cout输出指针对象时，其行为不太符合我们的需要，故上述程序仍然使用C语言的printf( )函数来输出指针。从执行结果可以看到，nullptr赋值给p后，p的值事实上就是0。 读者可能仍然对nullptr到底是什么感到疑惑，对nullptr的解读需要建立在对C++语言的良好理解之上。作者的下述解释可能会让初学者更加糊涂：C++ 11中的nullptr可以转换为任意指针类型的对象，其值为0，它既可以赋值给int，也可赋值给char\\, 还可以赋值给unsigned long long*类型的对象▲。 6.3 指针的简单应用下述C语言程序演示了指针的最基本用途： 1234567891011121314151617181920212223242526//Project - Swap#include &lt;stdio.h&gt;void swap1(int a, int b)&#123; int t = a; a = b; b = t;&#125;void swap2(int* a, int* b)&#123; int t = *a; *a = *b; *b = t;&#125;int main() &#123; int m = 2, n = 7; swap1(m,n); printf(\"after swap1: m = %d, n = %d\\n\", m, n); swap2(&amp;m, &amp;n); printf(\"after swap2: m = %d, n = %d\\n\", m, n); return 0;&#125; 上述程序的执行结果为： 12after swap1: m &#x3D; 2, n &#x3D; 7after swap2: m &#x3D; 7, n &#x3D; 2 上述程序中的swap1( )及swap2( )试图完成相同的功能：交换两个整数对象的值。 12345void swap1(int a, int b)&#123; int t = a; a = b; b = t;&#125; 第4 ~ 8行：swap1( )函数接受int类型的形参a和b，函数体内借助于临时变量t，变换了形式参数a，b的值。 12345void swap2(int* a, int* b)&#123; int t = *a; *a = *b; *b = t;&#125; 第10 ~ 14行：swap2( )函数接受int*类型的形参a和b，函数体内借助于临时变量t，交换了a，b指针指向的整数对象的值。 12swap1(m,n);printf(\"after swap1: m = %d, n = %d\\n\", m, n); 第19 ~ 20行：将m，n作为实参调用执行swap1( )函数，执行完后再打印m，n的值，从执行结果的第1行可见，m，n的值没有因swap1( )函数的执行而交换。 12swap2(&amp;m, &amp;n);printf(\"after swap2: m = %d, n = %d\\n\", m, n); 第22 ~ 23行：取m和n的地址，并将地址作为实参调用执行swap2( )函数。对于swap2( )函数而言，a，b形参的值即为m，n变量的地址，函数体内对*a，*b的修改即是对外部变量m，n的修改。从执行结果的第2行可见，借助于指针，swap2( )函数成功交换了变量m，n的值。这用传递指针调用函数的方式，称为传指针调用（call by pointer）。 接下来解释为什么swap1( )函数未能达成目标。请阅读下述C语言程序： 12345678910111213141516171819202122//Project - CallByValue#include &lt;stdio.h&gt;void swap1(int a, int b)&#123; printf(\"before swap in swap1: \"); printf(\"&amp;a = %p, &amp;b = %p, a = %d, b = %d\\n\", &amp;a, &amp;b, a, b); int t = a; a = b; b = t; printf(\"after swap in swap1: \"); printf(\"&amp;a = %p, &amp;b = %p, a = %d, b = %d\\n\", &amp;a, &amp;b, a, b);&#125;int main() &#123; int m = 2, n = 7; printf(\"before function call: \"); printf(\"&amp;m = %p, &amp;n = %p, m = %d, n = %d\\n\", &amp;m, &amp;n, m, n); swap1(m,n); printf(\"after function call: \"); printf(\"&amp;m = %p, &amp;n = %p, m = %d, n = %d\\n\", &amp;m, &amp;n, m, n); return 0;&#125; 上述程序的执行结果为： 1234before function call: &amp;m &#x3D; 000000000061FE1C, &amp;n &#x3D; 000000000061FE18, m &#x3D; 2, n &#x3D; 7before swap in swap1: &amp;a &#x3D; 000000000061FDE0, &amp;b &#x3D; 000000000061FDE8, a &#x3D; 2, b &#x3D; 7after swap in swap1: &amp;a &#x3D; 000000000061FDE0, &amp;b &#x3D; 000000000061FDE8, a &#x3D; 7, b &#x3D; 2after function call: &amp;m &#x3D; 000000000061FE1C, &amp;n &#x3D; 000000000061FE18, m &#x3D; 2, n &#x3D; 7 在main( )函数中，我们分别打印了变量m，n在swap1( )函数执行前后的地址和值；在swap1( )函数中，我们打印了形参a，b在数据交换前的地址和值。从执行结果可以看到，按照顺序，实参m的值2传递给了形参a，实参n的值传递给了实参b，但传递完成后，a与m，b与n完全独立，它们只是m，n的复制品而已。在执行结果中，我们可以看到，a，b与m，n拥有不同的内存地址。 从执行结果的第2 ~ 3行可以看到，在swap1( )函数内部，我们成功地交换了形参a，b的值：2，7变成了7，2。但对形参a，b的变换并不会影响外部变量m，n，它们的值在函数执行前后完全没有变，请见执行结果的第1行，第4行。 在swap1(m, n)的调用过程中，m, n的值传递给了形参a，b，这种传递参数的值调用函数的方式，称为传值调用（call by value）。 6.4 指针与数组在第5章，我们已经知道数组名即为数组首元素的地址，而指针变量的值也是地址。事实上，数组名与指针可以相互转换。请见下述C语言程序： 123456789101112131415161718192021222324//Project - ArrayPointer1#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; float scores[5] = &#123;55,66,77,88,99&#125;; float* p1 = scores; //把数组名赋值给指针 printf(\"sizeof(scores) = %lld, sizeof(p1) = %lld\\n\",sizeof(scores),sizeof(p1)); float* p2 = (float*)malloc(sizeof(float)*5); //申请分配20字节的内存 if (p2==NULL) exit(EXIT_FAILURE); float fSum = 0; for (unsigned int i=0;i&lt;5;i++)&#123; p2[i] = p1[i]; //指针当成数组用 fSum += p2[i]; &#125; printf(\"Average = %f\",fSum/5); free(p2); //释放申请的内存 return 0;&#125; 上述程序的执行结果为： 12sizeof(scores) &#x3D; 20, sizeof(p1) &#x3D; 8Average &#x3D; 77.000000 1#include &lt;stdlib.h&gt; 第3行：stdlib.h头文件引入函数malloc( )以及free( )。 12float* p1 = scores; //把数组名赋值给指针printf(\"sizeof(scores) = %lld, sizeof(p1) = %lld\\n\",sizeof(scores),sizeof(p1)); 第7 ~ 8行：将数组名scores赋值给float*类型的指针p1。虽然同为指针，但将数组名赋值给指针是有信息丢失的。在Qt Creator或者其它IDE环境中，将鼠标悬停在scores数组名上方，系统会提示该名称的类型为float[5]，意即包含5个float的数组。如图6- 所示。 图6- 数组名的类型提示 p1的类型为float*，在把scores赋值给p1后，虽然p1事实上指向了一个包含5个float元素的数组，但对于编译器而言，它就是指向一个float对象的指针。从执行结果的第1行可见，sizeof(scores)的结果为20，因为编译器知道scores的类型为float[5]，sizeof(p1)的结果为8，它就是一个平凡的指针。 123float* p2 = (float*)malloc(sizeof(float)*5); //申请分配20字节的内存if (p2==NULL) exit(EXIT_FAILURE); 第10 ~ 12行：C语言标准库函数malloc( n )用于向操作系统申请n个字节的存储空间，返回申请到的内存的地址，其类型为void*。按稍早的讨论，void*表示一种特殊的指针类型，该类型指针所指向的对象类型不确定。在第10行中，由于p2是float*，而malloc( )的返回值为void*，两者类型不一致，所以通过(float*)进行显式类型转换。向操作系统的内存申请并不总是能获得批准，在资源紧张的情况下，操作系统可能会拒绝。这时，malloc( )函数将返回一个空指针。第11行检查p2的值，如果是空指针，则调用exit( )函数退出程序的执行，其参数EXIT_FAILURE系值为1为常量，该参数将被exit( )传递给操作系统，提示程序的执行过程中发生了异常。本例中， sizeof(float) * 5 = 20， 我们申请了20字节的空间。此外，malloc( )函数不会对申请的内存进行初始化，p2所指向的5个float的值是不确定的。 1234567float fSum = 0;for (unsigned int i=0;i&lt;5;i++)&#123; p2[i] = p1[i]; //指针当成数组用 fSum += p2[i];&#125;printf(\"Average = %f\",fSum/5); 第14 ~ 20行：float*类型的指针p1和p2可以当成数组用。逻辑上，可以把p1和p2视为元素类型为float的一维数组的数组名，p1[i]和p2[i]计算元素地址的方式与数组完全相同。上述程序中，通过for循环把p1数组的值逐一拷贝到p2数组，顺便把数组元素求和，再平均，再打印出来。 1free(p2); //释放申请的内存 第22行：scores数组，p1指针，p2指针都是所谓自动变量（automatic variable），它们的内存分配与回收由编译器负责生成机器指令自动处理。但是，p2指针所指向的由malloc( )函数申请的20个字节不属于自动变量，负要由程序员主动释放。free(p2)函数将p2指针指向的内存释放给操作系统，使用操作系统可以在恰当地时候将这片内存另作他用。 对于编译器而言，p1和p2指针就是平凡的指向一个float对象的指针。将把指针当成数组名来使用时，确保下标不越界是程序员的职责。 注意：程序员必须确保申请的内存资源得到恰当的释放。未能妥善释放内存会造成系统可用内存资源的减少，影响计算机性能。这种情况称之为内存泄漏（memory leakage）。 6.5 指针运算指针对象可以与整数进行加减运算，但其执行结果与多数读者的期待不一致。请阅读下述C语言程序： 1234567891011121314151617181920//Project - PointerOperation1#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; float* p = (float*)calloc(10,sizeof(float)); if (p==NULL) exit(1); printf(\"p = %p, p + 1 = %p, p + 3 = %p\\n\", p, p+1, p+3); for (int i=0;i&lt;10;i++) *(p++) = i; //*p1++结果相同 p-=10; printf(\"p[0] = %f, p[3] = %f, p[9] = %f\\n\", *p, *(p+3), *(p+9)); free(p); return 0;&#125; 上述程序的执行结果为： 12p &#x3D; 00000000009D14A0, p + 1 &#x3D; 00000000009D14A4, p + 3 &#x3D; 00000000009D14ACp[0] &#x3D; 0.000000, p[3] &#x3D; 3.000000, p[9] &#x3D; 9.000000 说明：在读者的计算机上，执行结果第1行中的地址很可能与本书不同。 第3行：stdlib.h头文件引入函数calloc( )及free( )。 1float* p = (float*)calloc(10,sizeof(float)); 第6行：与malloc(n)函数直接指定要申请空间的字节数不同，calloc(n, size)函数提供了两个参数，n表示期望存储的元素个数，size则表示每个元素的字节数。本例中，10 * sizeof(float) = 10 * 4 = 40，calloc( )将申请40个字节的内存，然后返回void*。与malloc( )函数保存申请内存的原始状态不同，calloc( )函数会自动将所申请的内存全部设置为0值。 1printf(\"p = %p, p + 1 = %p, p + 3 = %p\\n\", p, p+1, p+3); 第10行：将指针p，p+1，p+3按地址格式输出。从执行结果的第1行可见，p+1的结果并不是p值加上整数1，而是p值加上4（0x09D14A0到0x09D14A4）， 即sizeof(float)；类似地，p+3的结果在数值上等于p值加12，即3*sizeof(float)（0x09D14A0到0x09D14AC）。当ElementType*类型的指针p加上整数i时，其结果仍是一个ElementType类型的指针，该指针的值为：$$p + i \\times sizeof(ElementType)$$直观地，可以认为指针p向高地址方向滑动了i个ElementType。本例中，p+3得到的新指针相对于p，住高地址方向移动了3个float。类似地，ElementType\\类型的指针p减去整数i，相当于指针p往低地址方向移动了i个ElementType； p++相当于指针p往高地址方向移动了一个ElementType，p–则是往低地址方向移动了一个ElementType。 12for (int i=0;i&lt;10;i++) *(p++) = i; //*p1++结果相同 第12 ~ 13行：将第6行calloc( )返回的内存空间视为包含10个float的数组，通过for循环将数组内的元素依次设置为0 ~ 9。请注意，对于循环体内的代码*(p++)，p++是先取值，后递增，所以，(p++)返回的是递增之前的指针p，这个返回的指针再打上*号（间接操作符），即为数组的第i个元素。事实上，如第13行的注释所述，这里的*(p++)也可以写成*p++，结果完全相同。作者在这里有意加上的括号有助于改善代码的可读性。 1p-=10; 第14行：第12 ~ 13行的循环共执行了10次p++，指针p的位置已指向数组外部元素。p -= 10将指针p移回至数组的首元素。 1printf(\"p[0] = %f, p[3] = %f, p[9] = %f\\n\", *p, *(p+3), *(p+9)); 第15行：打印*p、*(p+3)和*(p+9)的值。执行结果的第2行说明，*p的值即为p[0]、*(p+i)的值即为p[i]。 图6- 指针在数组上的移动 图6- 展示了上述代码循环内十次执行p++，以及p -= 10时指针p在数组上的移动过程。该图中，每个单元格代表４个字节，每个单元格正好存入一个float。 每执行一次p++，p指向往高地址方向移动至下一个元素；p -= 10时，p往低地址方向移动10个元素，重新指向数组的首元素。 综上所述，指针p加减一个整数后所得到的新指针的值，与该指针的类型有关。当指针是p是一个float*时，p+1事实上将相关地址增加了4。推而广之，当指针p是一个char*时，p+1则只将地址值加1。借助于指针在数组内的移动，下述C语言程序将一个C风格字符串中的小写英文字母全部改为大写，同时保持其它字符不变。 1234567891011121314151617//Project - PointerOperation2#include &lt;stdio.h&gt;#include &lt;ctype.h&gt;int main() &#123; char s[] = \"Mary has 3 lambs.\"; char* p = s; while (*p!=0)&#123; //*p!=0 等价于 (*p)!=0 if (islower(*p)) *p = *p + ('A' - 'a'); p++; &#125; printf(\"s = %s\",s); return 0;&#125; 上述程序的执行结果为： 1s &#x3D; MARY HAS 3 LAMBS. 1#include &lt;ctype.h&gt; 第3行：ctype.h头文件引入了islower( )函数，该函数接受一个字符作为参数，判断该字符是否是小写英文字母。类似的函数还有isalpha( )、isblank( )、isupper( )、isdigit( )等，读者很容易从这些函数的函数名推断其功能。 12345while (*p!=0)&#123; //*p!=0 等价于 (*p)!=0 if (islower(*p)) *p = *p + ('A' - 'a'); p++;&#125; 第9 ~ 13行：while循环将*p不为0作为循环条件遍历整个字符数组，因为字符数组会以0值表示终止。在循环体内，先判断p所指向的字符*p是否是小写字母，如果是，修改其值，将其转换成大写字母。在处理完当前字符后，p++将p移动至下一个字符。由于指针p的类型为char*，所以p++只会导致p的值增加1，因为sizeof(char)等于1。 输出结果证实，上述转换获得了成功，所有的小写字母变成了大写，而字符串中原有的大写字母、空格及数字没有改变。 6.6 指向指针的指针*如果一个指针指向一个int类型的对象，那么该指针的类型为int*。如果一个指针指向的对象不是一个平凡的对象，而是另外一个指针，那么这个指针就成为“指向指针的指针”。请见下述C语言示例： 1234567891011121314151617181920//Project - Pointer2Pointer#include &lt;stdio.h&gt;int main()&#123; int a = 100; int *p = &amp;a; int **pp = &amp;p; printf(\"&amp;a = %p, p = %p\\n\", &amp;a, p); //p的值为a的地址 printf(\"&amp;p = %p, pp = %p\\n\", &amp;p, pp); //pp的值为p的地址 printf(\"&amp;pp = %p\\n\", &amp;pp); printf(\"before: a = %d, *p = %d, **pp = %d\\n\", a, *p, **pp); a++; (*p)++; **pp = **pp + 1; printf(\"after: a = %d, *p = %d, **pp = %d\\n\", a, *p, **pp); return 0;&#125; 上述程序的执行结果为： 12345&amp;a &#x3D; 000000000061FE1C, p &#x3D; 000000000061FE1C&amp;p &#x3D; 000000000061FE10, pp &#x3D; 000000000061FE10&amp;pp &#x3D; 000000000061FE08before: a &#x3D; 100, *p &#x3D; 100, **pp &#x3D; 100after: a &#x3D; 103, *p &#x3D; 103, **pp &#x3D; 103 说明：在读者的计算机上，执行结果前3行中的地址很可能与本书不同。 123int a = 100;int *p = &amp;a;int **pp = &amp;p; 第5 ~ 7行：定义了三个变量a、p以及pp。根据程序的输出值，我们画出了下述示意图。 图6- a、p及pp之间的关系 从图6- 中可以看出，a、p、pp都是变量，只是类型各不相同，它们都有自己的存储地址和空间。p是指向a的指针，p的值即为a的地址；pp则是指向p的指针，pp的值即为p的地址。 1printf(\"&amp;a = %p, p = %p\\n\", &amp;a, p); //p的值为a的地址 第9行：输出a的地址及p的值，从执行结果的第1行可见，p值即为a的地址，指针p指向a。 1printf(\"&amp;p = %p, pp = %p\\n\", &amp;p, pp); //pp的值为p的地址 第10行：输出p的地址及pp的值，从执行结果的第2行可见，pp的值即为p的地址，指向指针的指针pp指向指针p。 1printf(\"&amp;pp = %p\\n\", &amp;pp); 第11行：输出pp的地址。从执行结果的第3行可见，pp也是一个对象，拥有自己的内存及地址。 1printf(\"before: a = %d, *p = %d, **pp = %d\\n\", a, *p, **pp); 第12行：输出a，*p以及**pp的值。pp是一个指向指针的指针，*pp即为p，**pp等价于*p，即为a。执行结果的第4行可见，三种途径都输出了相同的值，即a的值100。 123a++;(*p)++;**pp = **pp + 1; 第14 ~ 16行：通过a、*p以及**pp三种方式修改a的值，执行完后，a值预期应为103。 1printf(\"after: a = %d, *p = %d, **pp = %d\\n\", a, *p, **pp); 第18行：再次输出a，*p以及**pp的值。执行结果的第5行可见，三种途径都事实上输出了a值，为103。 6.7 main函数的参数读者如果有使用Linux终端或者Windows命令行的的经验，便知道操作系统是可以向应用程序传递参数的。比如，下述Linux终端命令将为当前目录下的文件file1制作一份拷贝，其文件名为file2。 1cp file1 file2 这行命令里的字符串”file1”、”file2”即为cp命令的参数。读者自行创建并构建（build）▲完成的可执行程序也是应用程序，我们也可以通过操作系统为自己的应用程序提供参数，影响该应用程序的行为。 请读者在Qt Creator中新建一个名为add的Plain C Application，然后将其中的main.c内容修改如下： 123456789101112131415//Project - add#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(int argc, char **argv)&#123; //char *argv[] for (int i=0;i&lt;argc;i++) printf(\"%d: %s, %p\\n\", i, argv[i], argv[i]); int iSum = 0; for (int i=1;i&lt;argc;i++) iSum += atoi(argv[i]); printf(\"sum = %d\",iSum); return 0;&#125; 在编译并运行程序前，我们还需要在Qt Creator中做一些设置，以便指定程序运行的参数。在Qt Creator中选择“项目“页，在”运行设置“中将Command line arguments设置为33 777 103，这相当于给应用程序提了以空格分隔的三个参数，分别为33、777和103，如图6- 所示。请注意图中箭头以及黑色方框标识的内容。 图6- 运行参数设置 接下来运行程序，结果如下： 123450: C:\\C2Cpp\\C6_Pointer_Reference\\build-add-Desktop_Qt_5_14_1_MinGW_64_bit-Debug\\add.exe, 00000000001E14A01: 33, 00000000001E14202: 777, 00000000001E14403: 103, 00000000001E1500sum &#x3D; 913 说明：在读者的计算机上，执行结果中的地址很可能与本书不同。 要解释这段程序及其执行结果，需要从main( )函数的参数说起。 12int main(int argc, char **argv)&#123; //char *argv[]... argc及argv都是通过操作系统传递给应用程序的： argc为int类型，表示操作系统传递给应用程序的参数个数。argc应该源自英文arguments count，意即参数总数。 argv为char**，它是一个指向指针的指针。事实上，argv指向的内存块中存储了argc个地址，每个地址均指向一个以0结尾的字符数组，这些字符数组即为参数字符串。实践中，可以把指针argv视为一个一维数组的数组名，该数组中有argc个元素，每个元素是一个类型为char*的指针。所以，有的教科书中会将main( )函数中的argv描述成char* argv[ ]，意即元素类型为char*的一维数组。argv这个名字源自英文arguments vector，意即参数向量。 1#include &lt;stdlib.h&gt; 第3行：stdlib.h头文件引入函数atoi( const char* str)，该函数将参数字符串转换成对应的整数。如果希望将字符串转换成浮点数，应使用函数atof( )。提醒读者注意，提供给atoi( )函数的参数字符串需要是合法的整数格式，否则可能会引发错误。 12for (int i=0;i&lt;argc;i++) printf(\"%d: %s, %p\\n\", i, argv[i], argv[i]); 第6 ~ 7行：通过循环，将argc个argv[i]分别按字符串以及地址形式输出。本例中，执行结果的前4行为相关输出。可以看出，argc的值为4，其中，第0个参数字符串即为被运行的可执行文件的路径，后面3个就是我们在”运行设置“中填入的Command line arguments。 123int iSum = 0;for (int i=1;i&lt;argc;i++) iSum += atoi(argv[i]); 第9 ~ 11行：通过循环将除去第0个之外的全部参数字符串转换为整数，并求和。从字符串到整数的转换是通过atoi( )函数完成的。 1printf(\"sum = %d\",iSum); 第13行：打印求得的和。 直观上，本例中的应用程序add.exe将参数中列出的全部整数相加，并输出和值。 为了进一步让读者体会参数字符串的使用， 作者在自己的Windows 10计算机上，进行了如下操作： 进入Windows命令行； 通过cd命令进入到了可执行文件add.exe所在的目录，路径可在本例执行结果的第1行找到； 执行命令add.exe 11 22 33 44，应用程序add.exe脱离Qt Creator运行，输出了和110。 相关过程如图6- 所示。 图6- 应用程序的命令行执行方法 6.8 指针与常量如第3章所述，常量（constant）是只读的对象。指针作为对象，既可以是变量，也可以是常量。 12const int a = 10;//int* p1 = &amp;a; //错误：a的地址为const int*，而p1是int* 第2行代码错误，a的类型为const int，&amp;a的类型为const int*，而p1的类型为int*。如果将a的地址赋值给p1，则意味着通过*p1可以修改对象a，a的常量特性被破坏。如果试图把一个指向常量对象的指针（&amp;a）赋值给一个指向非常量对象的指针（p1），编译器会拒绝。 123int b = 10;const int* p2 = &amp;b;//*p2 = *p2 * 2; //错误：p2指向const int，不可以修改*p2 第2行代码正确无误。b为int，&amp;b的类型为int*，p2为const int*，将&amp;b赋值给p2，只是不允许通过p2修改b，赋值完成后，b仍然是变量。 第3行代码错误，p2是指向const int的指针，不允许修改*p2。 1234int c = 10, d = 11;const int* const p3 = &amp;c;//*p3 = 101; //错误：p3指向const int，不可修改*p3//p3 = &amp;d; //错误：p3自身是常量，不可修改其值改变其指向 第2行代码里出现了两个const，对于指针p3而言，这两个const具有不同的意义：前者用于修饰p3指向的对象，意即p3所指向的对象为常量；后者用于修饰p3，意即p3是常量，除初始化赋值外，不可以修改p3的值改变其指向。如图6- 所示。 图6- 指向常量的常量型指针 所以，第3行代码错误，*p3，即p3所指向的对象不可以修改；第4行也错误，不可以修改常量p3。 6.9 引用C语言的指针实在是太难以理解和使用了，很多试图入门的初学者放弃于“指针”。但对于编程语言而言，指针并非必须，Python、Java等语言都没有指针。为了降低语言的难度，【C++】引入了引用（reference），可以实现与指针类似的用途。请阅读下述C++程序： 12345678910111213141516//Project - BasicRef#include &lt;iostream&gt;#include &lt;stdio.h&gt;using namespace std;int main() &#123; int iRabbits = 100; int&amp; iBunnies = iRabbits; printf(\"&amp;iRabbits = %p, &amp;iBunnies = %p\\n\", &amp;iRabbits, &amp;iBunnies); iRabbits += 10; iBunnies += 5; cout &lt;&lt; \"iRabbits = \" &lt;&lt; iRabbits &lt;&lt; \", iBunnies = \" &lt;&lt; iBunnies &lt;&lt; endl; return 0;&#125; 上述代码的执行结果为： 12&amp;iRabbits &#x3D; 000000000061fe14, &amp;iBunnies &#x3D; 000000000061fe14iRabbits &#x3D; 115, iBunnies &#x3D; 115 说明：在读者的计算机上，执行结果第1行中的地址很可能与本书不同。 1int&amp; iBunnies = iRabbits; 第8行：行中的&amp;符号不是取地址操作符，而是iBunnies的类型的一部分。iBunnies的类型为int&amp;，它是iRabbits对象的别名（alias）。我们称iBunnies是对iRabbits的引用（reference）。引用关系建立起来以后，iBunnies与iRabbits可以等效使用，两个名字关联了同一个对象。这就好比杜甫又称杜子美，两个名字都指的是同一个人。杜甫是本尊（被引用对象），杜子美是别名（引用）。 1printf(\"&amp;iRabbits = %p, &amp;iBunnies = %p\\n\", &amp;iRabbits, &amp;iBunnies); 第9行：分别对iRabbits和iBunnies取地址并输出。执行结果的第1行证实，两者事实上指同一个对象，因为地址相同。 12iRabbits += 10;iBunnies += 5; 第11 ~ 12行：给iRabbits变量加10， 通过iBunnies引用给iRabbits变量加5。以上累计，iRabbits变量加了15，其值变为115。 1cout &lt;&lt; \"iRabbits = \" &lt;&lt; iRabbits &lt;&lt; \", iBunnies = \" &lt;&lt; iBunnies &lt;&lt; endl; 第14行：打印iRabbits及iBunnies的值。执行结果第2行可见，均为115，印证了两者事实是同一个对象的结论。 引用的实质是自解析的指针。本例中，我们可以想像引用iBunnies内部有一个指针/地址，当然第8行代码定义iBunnies并将iBunnies引用到iRabbits时，程序会取得iRabbits对象的地址，并赋值给iBunnies内部的指针。 1int&amp; iBunnies = iRabbits; 对第8行代码可以做出下述“形象理解”： 1iBunnies的内部指针 = &amp;iRabbits; 在后续代码中如果使用到iBunnies，由于编译器知道iBunnies是一个引用，它会自动解析iBunnies内部保存的指针/地址。所以对iBunnies的操作即是对iRabbits的操作。 1iBunnies += 5; 对第12行代码可以做出下述“形象理解”： 1*iBunnies的内部指针 += 5; //iBunnies的内部指针即为iRabbits的地址 虽然引用的实质是自解析的指针，但引用与指针存在诸多差异。 123int a = 3, b = 4;int* p = &amp;a;p = &amp;b; 指针可以通过赋值修改其指向，比如，上述程序中的p在第2行被初始化为指向变量a，然后第3行又修改了p的值，让其指向变量b。 1234int c = 3, d = 4;int&amp; r = c; //必须在定义时初始化r，将其与特定的对象相绑定r = d; //不是将r的指向改向d，而是把d赋值给r引用的变量ccout &lt;&lt; \"c = \" &lt;&lt; c &lt;&lt; \", d = \" &lt;&lt; d &lt;&lt;\", r = \" &lt;&lt; r; 引用必须在定义时与其它对象绑定，且不可能通过赋值改变绑定关系。上述代码中第2行将r与c绑定，如果定义引用时不给予初始化，编译器会报错。第3行并不能将r的绑定对象从c迁移至d，而是把d赋值给r的绑定对象c。所以第3行执行完成后，c、d以及r的值都应该是4。 要点🎯 引用一旦定义并初始化与其他对象的绑定关系，这种绑定关系便不可修改。从这个角度，我们可以认为引用内部的指针是一个常量。 我们也可以定义和使用常量型引用，如下述代码： 12345float e = 3.14f;const float&amp; f = e;e += 1.0;//f += 1.0; //不可以修改常量型引用cout &lt;&lt; \"e = \" &lt;&lt; e &lt;&lt; \", f = \" &lt;&lt; f; 第2行的f是关于浮点数e的常量型引用，这意味着不能修改f，或者说不能通过f修改e。但直接修改e依然是合法的，如上述代码中的第3行。当第3行给e加上1.0使得e变成4.14后，第5行中输出的f值也会是4.14。 当我们使用auto类型推断【C++ 11】时，变量的类型默认是非引用的。比如，下述代码中的循环变量x，其类型将被推断为float，在循环过程中，x将是prices数组中元素的复制品。第3行对x的修改，并不会导致prices数组元素的改变。 123float prices[] &#123;56.12f, 99.0f, 1.7f, 14.47f&#125;;for (auto x:prices) x *= 1.2f; 如果在auto关键字后加上&amp;符号，变量将被推断为引用类型。比如，下例中的循环变量f，将被推断为float&amp;类型，在循环中对f的修改，即是对prices数组元素的修改。 12for (auto&amp; f:prices) f *= 1.2f; 6.10 引用与函数由于引用的实质就是自解析的指针，所以，当一个函数的形参类型定义为引用时，真正被传入函数的将是实参的地址。请见下述C++程序： 12345678910111213141516171819202122//Project - RefFunc#include &lt;iostream&gt;#include &lt;stdio.h&gt;using namespace std;void swap1(float&amp; a, float&amp; b)&#123; printf(\"&amp;a = %p, &amp;b = %p\\n\", &amp;a, &amp;b); float t = a; a = b; b = t;&#125;int main() &#123; float m = 1.1f, n = 9.9f; printf(\"&amp;m = %p, &amp;n = %p\\n\", &amp;m, &amp;n); swap1(m,n); cout &lt;&lt; \"after swap1: m = \" &lt;&lt; m &lt;&lt; \", n = \" &lt;&lt; n; return 0;&#125; 上述程序的执行结果为： 123&amp;m &#x3D; 000000000061fe1c, &amp;n &#x3D; 000000000061fe18&amp;a &#x3D; 000000000061fe1c, &amp;b &#x3D; 000000000061fe18after swap1: m &#x3D; 9.9, n &#x3D; 1.1 说明：在读者的计算机上，执行结果第1 ~ 2行中的地址很可能与本书不同。 1void swap1(float&amp; a, float&amp; b)&#123; 第6 ~ 12行：定义了swap1( )函数，用于交换两个形参的值。请注意，形参a及b的类型为引用 - float&amp;。 1printf(\"&amp;a = %p, &amp;b = %p\\n\", &amp;a, &amp;b); 第7行：在swap1( )函数内部，打印形参a，b的地址。 1float m = 1.1f, n = 9.9f; 第15行：定义了两个浮点数对象m及n，初始值分别为1.1和9.9。 1printf(\"&amp;m = %p, &amp;n = %p\\n\", &amp;m, &amp;n); 第17行：打印了m，n的地址。从执行结果的第1 ~ 2行可见，实参m的地址与形参a相同，实参n的地址与形参b相同。证明a是m的引用，b是n的引用。 1swap1(m,n); 第18行：以m，n为实参调用执行函数swap1( )，由于swap1( )的形参为引用类型，所以实际参数传递的不是m，n的值，而是m，n的地址。其中，m的地址递给了引用a”内部的指针“，n的地址传递给了引用b”内部的指针“。在这行代码里，我们并没有应用&amp;操作符取m和n的地址，这种取地址的操作是编译器根据swap1( )所要求的形参类型float&amp;自动添加的。由于形参a，b是实参m，n的引用，所以swap1( )函数内对形参a，b的操作事实上就是对实参m，n的操作，函数执行过程中将实际交换外部变量m，n的值。 1cout &lt;&lt; \"after swap1: m = \" &lt;&lt; m &lt;&lt; \", n = \" &lt;&lt; n; 第20行：在swap1( )函数执行完毕后打印m，n的值。从执行结果的第3行可见，m、n的值被成功交换。 另请读者注意，本例中的函数名为swap1，而不是swap。在C++的标准库中，已经存在一个名为swap的模板函数▲，为了避免与其重名，本例中的函数名定为swap1。 综上所述，通过引用可以达成与指针类似的目的。但相较于指针，引用更容易理解和使用，在使用C++编程时，作者本人坚持能用引用解决就尽量不用指针的原则。这种传递引用调用函数的方法，称为传引用调用（call by reference）。 当函数的形参是引用类型时，编译器对实参的类型匹配提出了更高要求。下述C++程序中第9行，第11行都会被编译器拒绝（早期比较宽松的编译器可能只给出警告）。 12345678910111213void swap1(float&amp; a, float&amp; b)&#123; auto t = a; a = b; b = t;&#125;int main()&#123; double m = 3.0, n = 4.0; //swap1(m,n); //错误：无法将double类型引用为float&amp; float c = 3.0f; //swap1(c, c+1.2f); //错误：c+1.2f为临时对象，无确定的内存实体，无法传递引用 return 0;&#125; 第9行：m，n均为double类型，而swap1( )函数要求传递float类型的引用。 第11行：c + 1.2f对于编译器而言，是一个临时对象，没有确定的内存实体，无法为其生成引用。 上述第9、11行被编译器拒绝的真正理由是：函数的形参是非常量型引用，这意味着在函数内部，可能会通过修改引用型形参来事实上改变外部对象。事实上，对于代码的第9行，早期的不严格的编译器会通过隐式类型转换生成两个float类型的m，n复制品，然后以临时复制品变量为基础，生成形参a、b的引用。这样，函数对形参的修改事实上成了对用完即弃的”临时对象“的修改，这通常不是程序员本意，常常会导致程序缺陷。所以，新的C++标准不允许这样做。 12345678double getCircleArea(const double&amp; r)&#123; return 3.1415926 * r * r;&#125;int main() &#123; double dArea = getCircleArea(7.6f); //正确 return 0;&#125; 上述代码的第6行则完全没有问题。虽然，7.6f是一个float类型的字面量，这意味着： 类型不符，getCircleArea要求的是double类型的引用。 字面量不是一个有内存实体的对象，无法取地址。 但是，编译器会接受第6行的编译。原因在于getCircleArea( )的形参是一个常量型引用，在函数内，不能修改形参，函数只是使用到形参的值而已。此时，编译器会为7.6f临时生成一个double类型的复制品，然后传递复制品对象的常量型引用给形参r。既然函数只是需要这个值，那编译器想尽一切办法向它提供这个值，没什么不对。 【？缺： 常量型引用参数， 要等到讲完结构或者类再讲】 【？缺：C++11的右值引用】 7. 函数与抽象懒是人类进步的阶梯。 — 亚历山大·陈 这是个玩笑，没有哪位先贤，更没有哪位姓陈的名人说过这句话。这是作者本人自创的（作者英文名为alex)。人们为了省心省力，事半功倍，努力研究工作中交叉与独立、变与不变的哲学，并将通用部分抽象出来。这种抽象反应在程序设计上，其中一个成果就是函数。 本讲义系重庆大学C/C++课程的教学笔记。 作者： 陈波 chenbo@cqu.edu.cn， All rights reserved. 未经作者许可，不允许经由互联网展示或提供下载。 不允许以纸质出版为目的进行摘抄或改编。 7.1 抽象的威力作为一个司机，你只知道，把油门踏板往下踩，车就会加速。至于汽车是如何做到加速的，你几乎不用关心。如果只有了解汽车发动机、悬挂系统、控制系统全部细节的人才可以开车，那北京的三环路一定修得太宽了。 12345678910while (true) &#123; auto cmd = fectchCommandFromQueque(); if (cmd)&#123; auto resp = executeCommand(cmd); sendResponse(resp); &#125; else sleep(0.01); readAndParseCommands();&#125; 一个有经验的程序员，看到这些代码，就能够猜出来这段程序大概是在做什么：看起来，这是某个监听服务程序，程序不断地读取并分析来自网络或者其它信源的命令，如果拿到一个命令，就执行之，并且将执行结果发回。如果本轮循环没有拿到命令，还“小睡”一会儿，估计是避免不必要地过多占用CPU时间或者网络带宽。 之所以能在没有任何文档的情况下让程序具备一定的可读性，其中一个原因就是抽象。我们把那些需要重复执行或者多处调用的功能，如发送执行结果，抽象并封装成了函数sendResponse( )。而这些函数和变量的命名，很好地描述了其使命。作为函数的使用者，我们只需要知道执行executeCommand( )函数，把符合格式要求的命令cmd作为参数传递给它，它就会执行相应命令，并返回结果。至于，函数内部实现这些命令的细节，我们可以不了解。 想象一下，如果不抽象并将重复子功能封装成函数，上述程序的主体代码可能长达几千行。要了解代码的梗概，估计就要读个好几天，还不一定读得懂。如果程序员做任何事都要搞清楚全部细节，那Windows操作系统根本就不可能诞生。因为，没有任何正常人类可以读完并全部了解数千万行代码的细节。 本章主要讨论函数的定义与使用。而函数，是结构化编程的核心，同时也是面向对象编程的基础。 7.2 函数的定义说到函数，大家可能会想到的数学中的二次函数，例如:f(x)=x2+3x+1，它对应二维平面中的一条曲线。 图7- 二次函数曲线 当取某个指定的x值，都会对应一个函数值f(x)。例如f(0)=1,f(2)=11,f(-4)=5等等。 相对应，我们可以把这样一个一元二次函数定义为一个C语言的函数f。在这里，我们可以认为一个函数由输入、处理、输出三部分组成。函数接受的参数即是输入，例如x，函数返回的结果是输出，例如return y，中间的执行代码是处理过程。请阅读下述C语言程序： 1234567891011121314//Project - Quadratic#include &lt;stdio.h&gt;float f(float); //函数的声明(declaration)或者原型(prototype)int main()&#123; printf(\"f(0) = %f, f(2) = %f, f(-4) = %f\", f(0),f(2),f(-4)); return 0;&#125;float f(float x)&#123; //函数的定义(definition) float y = x*x + 3*x + 1; return y;&#125; 上述代码的执行结果为： 1f(0) &#x3D; 1.000000, f(2) &#x3D; 11.000000, f(-4) &#x3D; 5.000000 1float f(float); //函数的声明(declaration)或者原型(prototype) 第4行：f( )函数的声明（declaration)或者原型(prototype)。该函数原型描述了函数的名称、函数的形式参数的个数及类型、函数的返回值类型。对于编译而言，这些信息足够判定第7行的函数调用代码是合法的。 1printf(\"f(0) = %f, f(2) = %f, f(-4) = %f\", f(0),f(2),f(-4)); 第7行：以不同参数3次调用执行了f( )函数。在调用执行一个函数之前，必须满足下述条件之一： 调用点之前已经给出了函数的原型，且在调用点之后存在函数的定义。 函数的定义位于调用点之前。 1234float f(float x)&#123; //函数的定义(definition) float y = x*x + 3*x + 1; return y;&#125; 第11 ~ 14行：f( )函数的定义。 在C/C++语言中，定义一个函数的通用语法格式为： 123456返回值类型 函数名(形参0类型 形参0名称，形式参数1类型 形参1名称， ... 形参n类型 形参n名称) &#123; 语句； ... return 返回值；&#125; 其中，{ }包裹的部分称为函数体（function body）。函数名后括号内的部分为形式参数列表，当函数接受0个形参时，括号内可以留空， 或者填上一个void代表零参数。如果函数有多个return语句，则每个return语句后的返回值类型均应与函数的返回值类型相同，或者能够通过隐式类型转换转换成返回值类型。当函数没有返回值时，返回值类型用void代替，此时，return语句后不应跟上返回值。 7.3 函数与一维数组在算法 - 冒泡排序一节中，我们曾经将一个数组的数组名，即首元素地址作为参数传递给bubbleSort( )函数进行排序。本节将此问题进一步展开讨论。请先阅读下述C语言代码： 12345678910111213141516171819202122//Project - AverageArray1#include &lt;stdio.h&gt;float average(const float a[], const unsigned int n)&#123; printf(\"a = %p\\n\",a); float fSum = 0; for (unsigned int i=0;i&lt;n;i++) fSum += a[i]; return fSum / n;&#125;int main() &#123; float scores[5] = &#123;50,60,70,80,90&#125;; printf(\"scores = %p\\n\",scores); float fAvg = average(scores,5); printf(\"average = %f\",fAvg); return 0;&#125; 上述程序的执行结果为： 123scores &#x3D; 000000000061FE00a &#x3D; 000000000061FE00average &#x3D; 70.000000 说明：在读者的计算机上，执行结果第1 ~ 2行的地址很可能与本书不同。 函数功能：average( )函数计算并返回参数数组内全部元素的平均值。 1float average(const float a[], const unsigned int n)&#123; 第4行：average( )函数定义。该函数有两个形式参数： a为需要进行平均值计算的参数数组，其类型为const float[ ]，意即元素类型为const float的数组的数组名。此处将a数组的元素类型指定为常量，是因为在计算平均值的过程中，并不需要也不应该修改参数数组。 n表示a数组内的元素个数， 类型为const unsigned int。由于元素个数不可能为负数，所以n设定为无符号整数；由于元素个数n不应该在函数体内修改，所以n设定为常量。 1printf(\"a = %p\\n\",a); 第5行：在函数体内将参数数组名a，即数组首元素的地址输出。 1float scores[5] = &#123;50,60,70,80,90&#125;; 第15行：定义并初始化了scores数组，容易看出，数组内元素的均值应为70。 1printf(\"scores = %p\\n\",scores); 第16行：将数组名scores，即数组首元素的地址输出。从执行结果的第1 ~ 2可见，scores与a的值，即数组的首元素地址相同。这说明，当函数调用时，实参scores向形参a的传递，事实上只传递了数组名，也就是scores数组首元素的地址。在函数内部对a数据元素的操作，事实上操作的是外部的scores数组。 1float fAvg = average(scores,5); 第18行：调用执行average( )函数，返回的平均值复制给fAvg变量。 综上所述，当函数的形参定义为数组时，该形参实际获得的是外部数组的首元素地址。本例中，无论外部scores数组有多少个元素，传递给形参a的只是scores数组的数组名，也就是首元素地址，传参效率很高。同时，作为一个单纯的数组名，average( )函数无法通过参数a确定数组的元素个数，所以，需要一个额外的n参数指明数组的元素个数。 按第6章的讨论，一维数组的数组名可以认为是一个指针，而指针也可以当成数组名使用。average( )函数也可以把形参a定义为指向const float的指针： 1float average(const float *a, const unsigned int n)&#123; ... &#125; 其执行效果完全相同。当average(scores, 5)被执行时，scores数组名作为地址被传递给了作为形参的指针a，然后，在函数体内部，把指针a当成数组名使用。 7.4 函数与二维数组考虑将下述二维数组作为参数传递给average( )函数计算全部元素的均值： 1234float scores[2][3] = &#123; &#123;50,60,70&#125;, &#123;80,90,100&#125; &#125;; 则average( )函数的形参可按如下格式定义： 123456789//Project - AverageArray2float average(const float a[][3], const unsigned int n)&#123; float fSum = 0; for (unsigned int i=0;i&lt;n;i++) for (unsigned int j=0;j&lt;3;j++) fSum += a[i][j]; return fSum / (n*3);&#125; 该函数有两个形参： 参数a的类型为const float [ ][3]，意即：a是一个二维数组的数组名，这个数组的列数为3，行数未指定。这个奇怪的类型定义是有原因的，回顾第5章可知，当函数体内访问元素a[ i ][ j ]时，需要通过数组名a计算该元素的存储地址，而地址的计算，必须知道每行有多少个元素，即必须知道列数。所以，形参a定义时，必须给出列数3。至于a数组的总行数，上述地址计算过程中用不到，不必给出。 参数n指二维数组a内的行数。 1float fAvg = average(scores,2); 当上述函数调用发生时，scores数组名传递给形参a，被传递的只是数组的首元素地址。函数体内部依赖于下述信息计算a[ i ][ j ]的元素地址，具体的计算方法请回顾第5章。 数组名a，即二维数组scores的首地址； 数组的元素类型，const float，这意味着单个元素占4个字节； 数组的列数，依定义为3，这意味着数组内的每行有3个元素，每行占3 x 4 = 12个字节； 下标i, j。 综上， 当向一个函数传递二维数组时，形参数组定义时必须给出列数。进一步，当向一个函数传递n维数组时，形参数组定义时，必须给出除0维外的所有维度，比如const int a[ ][10][8][6]。 此外，C语言的设计者还给我们准备了难以理解的另一种语法格式，以便让我们知难而退： 1234float average2(const float (*a)[3], const unsigned int n)&#123; ... return fSum / (n*3);&#125; 形参中的const float (*a)[3]可以按照如下方式理解： a是一个指针； a所指向的对象为包含3个const float的一维数组。 如果把a视为数组名，则数组的元素是也是数组，每个元素数组包含3个const float。换言之，a事实上是列数为3的二维数组。 上述形参a的定义中的括号是必须的，如果去掉括号成为const float* a[3]，编译器会做出完全不同的解读： a是一个包含3个元素的数组； 数组的元素类型为指向const float的指针，即const float*。 考虑到const float (*a)[3]这种形式的二维数组形参太具有迷惑性，作者建议使用const float a[ ][3]这种语法。 7.5 变量的作用域变量的作用域（scope）描述了变量在文件的多大范围内可见。程序中大多数的变量都是所谓局部变量（local variable），它们具有块作用域（block scope）。所谓块作用域，就是指该变量的可见范围为从定义处开始直至包含该变量的块的末尾。一般地，块（block）指一对花括号{ }括起来的区域。我们通过下述C语言程序来解释局部变量的块作用域。 12345678910111213141516171819202122//Project - BlockScope#include &lt;stdio.h&gt;int main(int argc, char **argv)&#123; int a = 5; int b = 6; &#123; int a = 9; int c = 10; printf(\"a = %d, &amp;a = %p\\n\", a, &amp;a); //第9行的内层a printf(\"b = %d, &amp;b = %p\\n\", b, &amp;b); //第6行的外层b printf(\"c = %d, &amp;c = %p\\n\", c, &amp;c); //第10行的内层c &#125; printf(\"a = %d, &amp;a = %p\\n\", a, &amp;a); //第5行的外层a //b = c; //错误：b可见，但c不可见 printf(\"b = %d, &amp;b = %p\\n\", b, &amp;b); //第6行的外层b printf(\"argc = %d\", argc); //main()函数的形参 return 0;&#125; 上述程序的执行结果为： 123456a &#x3D; 9, &amp;a &#x3D; 000000000061FE14b &#x3D; 6, &amp;b &#x3D; 000000000061FE18c &#x3D; 10, &amp;c &#x3D; 000000000061FE10a &#x3D; 5, &amp;a &#x3D; 000000000061FE1Cb &#x3D; 6, &amp;b &#x3D; 000000000061FE18argc &#x3D; 1 说明：在读者的计算机上，上述执行结果中的地址很可能与本书不同。 在上述程序中，存在两个块： main( )函数块，第4 ~ 22行。在这个块内，我们定义了第5行的a，第6行的b两个局部变量。此外，main( )的形参argc、argv也被编译器视为该块内的局部变量。本例中，main( )函数块处于外层，简称外层块。 第8 ~ 15行花括号内的区域也是一个块，由于它处于main( )函数块的内层，本例简称为内层块。在内层块中，我们定义了第9行的a，第10行的c局部变量。 为了描述方便，我们让这些局部变量的初始值等于该变量定义时的行号，比如，第5行的a赋初值为5。我们结合图7- 来解释上述代码及其执行结果。 图7- 局部变量的块作用域 1printf(\"a = %d, &amp;a = %p\\n\", a, &amp;a); //第9行的内层a 第12行：本行代码位于内层块。由于块内第9行有一个变量a，所以此处输出的是第9行的内层a值9及其地址。从执行结果的第1行和第4行可以看出，内层块中的a与外层块中的a具有不同的地址，它们是不同的对象，只是恰好同名。 规则：当内层代码引用的变量名同时存在于内层和外层时，使用内层变量。 1printf(\"b = %d, &amp;b = %p\\n\", b, &amp;b); //第6行的外层b 第13行：本行代码位于内层块。由于块内没有名为b的变量，所以此处输出的是第6行的外层b值6及其地址。见执行结果的第2行。 规则：当内层代码引用的变量名在内层中不存在时，编译器会尝试在外层中查找。 1printf(\"c = %d, &amp;c = %p\\n\", c, &amp;c); //第10行的内层c 第14行：本行代码位于内层块。由于块内第10行有一个变量c，所以此处输出的是第10行的内层c值10及其地址。见执行结果的第3行。 1printf(\"a = %d, &amp;a = %p\\n\", a, &amp;a); //第5行的外层a 第17行：本行代码位于外层块。内层块第9行的a已超作用域，不可使用。所以此处输出的是第5行的外层a值5及其地址。从执行结果的第4行可见，外层a的地址与内层a的地址（执行结果第1行）不同，它们是不同的对象，虽然同名，但互不干涉。 1//b = c; //错误：b可见，但c不可见 第18行：本行代码位于外层块。在此处，第6行的外层b是可用的，但第10行的内层c已超作用域，不可使用。故该行代码错误。 1printf(\"b = %d, &amp;b = %p\\n\", b, &amp;b); //第6行的外层b 第19行：本行代码位于外层块。此处输出的是第6行的外层b值6及其地址。见执行结果的第5行。对照执行结果的第2行还可以证实，本例中，无论是内层代码还是外层代码，访问的是同一个b对象。 1printf(\"argc = %d\", argc); //main()函数的形参 第20行：本行代码位于外层块。argc属于main( )函数的形参，编译器将其视为外层块的局部变量。 本例向我们证明，内层变量可与外层变量同名，两个或多个同名的变量事实上是独立的不同对象。在本例中，这个同名的变量为a，当在内层代码中使用a时，它指的是内层的a变量。正是基于这个理由，所以我们得以习惯性地在for循环中使用i作为循环变量名，而不用担心重名。 事实上，函数的实参和形参也可以重名且相互不干涉。请见下述C语言代码： 12345678910111213141516171819//Project - FuncParameter#include &lt;stdio.h&gt;float PI = 3.1415926F;float getCircleArea(float r)&#123; printf(\"getCircleArea: &amp;r = %p\\n\", &amp;r); return PI * r * r;&#125;int main() &#123; float r = 4; printf(\"main: &amp;r = %p\\n\", &amp;r); float fArea = getCircleArea(r); printf(\"fArea = %f\",fArea); return 0;&#125; 上述程序的执行结果为： 123main: &amp;r &#x3D; 000000000061FE18getCircleArea: &amp;r &#x3D; 000000000061FDF0fArea &#x3D; 50.265480 说明：在读者的计算机上，执行结果中的地址很可能与本书不同。 上述执行结果中的第1行、第2行证实，main( )函数内的局部变量r与getCircleArea( )函数的形参r具有不同的内存地址，虽然重名，但互不干涉。再次重申：函数的形参应视为函数块内的局部变量。 1float PI = 3.1415926F; 第4行：定义了一个不属于任何块的变量PI，该变量具备所谓文件作用域（file scope），该变量从定义行（第4行）开始一直到其所在文件main.c的结尾，都可见。 本节关于变量作用域的结论，同样适用于常量。 7.6 递归中学数学里我们学过阶乘：$$5! = 5\\times4\\times3\\times2\\times1 = 5 \\times (4\\times3\\times2\\times1) = 5 \\times 4!$$同理，$$n! = n \\times (n-1)!$$求4的阶乘同求5的阶乘是相同性质的问题，区别仅在于问题的规模不同（参数大小不一样）。如果我们定义了一个函数factorial(n)可以求出n的阶乘，那理论上，factorial(n)也可以求出n-1的阶乘。 数学上，通过函数自身来定义的函数称为递归函数。到程序设计领域，函数自己调用自己称为递归函数。请阅读下述C语言代码： 123456789101112131415//Project - Factorial#include &lt;stdio.h&gt;long long factorial(int n)&#123; printf(\"factorial(%d) is called, &amp;n = %p\\n\", n, &amp;n); if (n==1) return 1; long long r = n * factorial(n-1); return r;&#125;int main() &#123; printf(\"6! = %lld\", factorial(6)); return 0;&#125; 上述代码的执行结果为： 1234567factorial(6) is called, &amp;n &#x3D; 000000000061FE00factorial(5) is called, &amp;n &#x3D; 000000000061FDB0factorial(4) is called, &amp;n &#x3D; 000000000061FD60factorial(3) is called, &amp;n &#x3D; 000000000061FD10factorial(2) is called, &amp;n &#x3D; 000000000061FCC0factorial(1) is called, &amp;n &#x3D; 000000000061FC706! &#x3D; 720 说明：在读者的计算机上，执行结果中的地址很可能与本书不同。 1long long factorial(int n)&#123; 第4 ~ 10行：factorial( n )函数用于计算并返回n!。考虑到阶乘的值通常比较大，所以返回值定义为long long类型。 1printf(\"factorial(%d) is called, &amp;n = %p\\n\", n, &amp;n); 第5行：在函数体的开始部分打印形参n的值和地址。 12if (n==1) return 1; 第6 ~ 7行：如果n=1，此时，问题足够简单，直接返回结果1。此处，我们称n==1为递归的边界条件，这个边界条件保证了对于合法的n值，这个递归函数一定会运行结束。 12long long r = n * factorial(n-1);return r; 第8 ~ 9行：factorial(n)函数调用执行了factorial(n-1)。只有当factorial(n-1)函数执行完后并返回结果后，factorial(n)才能计算出结果r，然后返回。 factorial()函数内部调用了factorial()函数自身，它是一个递归函数。factorial(6)的执行过程可以这样理解：为了求6的阶乘，函数调用函数自身求5的阶乘，为了求5的阶乘，函数调用自身求4的阶乘， … ，函数调用自身求1的阶乘，1的阶乘满足边界条件，返回结果1。得到了1的阶乘，factorial(2)通过 r = 21 = 2得到了2的阶乘并返回。得到了2的阶乘，factorial(3)通过r = 3\\2 = 6得到了3的阶乘并返回。… 然后得到了5的阶乘为120，factorial(6)通过r = 6*5! = 6*120 = 720得到6的阶乘，并返回给外部调用者。 可以想象，在factorial(1)函数被执行时，整个解释器内实际上有6个factorial()函数正在执行，分别是factorial(6)、 factorial(5) 、factorial(4) 、factorial(3) 、factorial(2) 、factorial(1)。factorial(1)执行完毕，返回值到factorial(2)，factorial(2)得到factorial(1)的返回值，计算后返回factorial(3)，…， 最终factorial(6)在得到factorial(5)的返回值后，再行计算返回给外部调用者。这一过程可以用图7- 表示，读者可以顺着图中箭头的标号和指向，人工模拟一遍执行过程。 图7- 递归执行过程 通过在程序中设置断点，然后借助程序调试方法对上述程序进行调试观察，有助于读者更好地理解递归函数的执行过程以及其对内存资源的消耗。 我们无法在大规模问题中使用递归函数，理由如下： 本例中，形参n，变量r都是factorial( )函数块的局部变量。不难看出，当上述factorial(1)函数在执行时，事实上有6个factorial( )函数处于执行当中，在内存中，应该存在6个n对象，以及6个r对象。从执行结果第1 ~ 6行中的地址可以看出，这6个n具有不同的地址，是完全独立的对象。当n比较小时，计算机内存尚可应付，如果n很大，比如10000000000000，估计还没有运行到factorial(1)，数量众多的局部变量以及因函数调用而产生的额外内存消耗就会使栈▲空间枯竭，程序崩溃。 除了内存空间的占用，每次函数调用也会产生额外的运行代价：控制执行的跳转、参数传递、局部变量内存空间的准备和回收。海量次数的函数调用将产生海量的额外运算代价。 所以，实践中，递归只能解决规模很小的问题（本例中，即n不能太大）。大多数有实际价值的算法和程序，都是非递归的。即便刚开始设计成递归的，最终也要想尽办法转换成非递归的。 但递归自身在数学上又相当的优美。现实世界中的很多问题，天生就是递归的，比如100个数排序，先把100个数分成两堆，各50个。两堆数分别排序，然后再顺序合并成100个有序的数。50个数排序同100个数排序，都是排序，性质相同，区别仅在于问题的规模不同（100 比 50)。由于这种天然的递归属性，我们用递归函数来描述算法，用递归程序来实现递归算法非常的简便和易于理解。还有很多问题，简单的如折半/二分查找，复杂的如 01背包，都适合用递归来描述。但我们要牢记，描述算法和理解算法时可以用递归，但如果想得到实用的程序，要把递归给消去。消去递归的方法超出本书范围。 算法 - 一对兔兔与函数的增长【？缺】 算法 - 归并排序【？缺】 算法 - 汉诺塔法国数学家爱德华·卢卡斯曾转述过一个印度的古老传说：在世界中心贝拿勒斯（在印度北部）的圣庙里，一块黄铜板上插着三根金刚石柱。印度教的主神梵天在创造世界的时候，在其中一根石柱上从下到上的穿好了由大到小的64块金盘，这就是所谓的汉诺塔（Hanoi Tower）。 按照梵天的命令，不论白天黑夜，总有一个婆罗门僧侣在按照下面的规则移动这些金盘：一次只移动一个盘，不管在哪根柱上，小盘必须在大盘上面。僧侣们预言，当所有的金盘都从梵天穿好的那根柱上移到另外一根柱上时，世界就将在一声霹雳中消灭，而梵塔、庙宇和众生也都将同归于尽。 ​ 1). 求解如下图所示的5个盘的汉诺塔问题，其总任务是将A柱上的n = 5个盘移至C柱。要实现这个总任务并且保证移盘过程中小盘始终在大盘上面，整个过程分三步实现。第1步：我们必须先将n - 1 = 4个黑盘从A柱移至B柱。在第1步的执行过程当中，为了保证规则的贯彻，显然，必须借助于C柱作为中转柱才能完成。 第1步所做的工作可描述为：借助中转柱C， 将n-1=4个盘从A移至B。 ​ 现在，最大的白盘在A柱上，C柱是空的。可实施第2步：将A柱上的大盘取下，移至C柱。 接下来，我们要做的是第3步: 借助中转柱A，将B柱上的n - 1 = 4个盘移至C柱。此时，C柱上虽然已经有了一个盘，但由于此盘是最大的，所以只要移动过程中不搬动C柱上的原有大盘，可以忽略其存在。 ​ 现在，我们试图总结一下总任务及其三个子任务： 总任务: 将 n = 5个盘从A柱移至C柱，以B柱为中转柱 - 子任务1: 将 n - 1 = 4个盘从A柱移至B柱，以C柱为中转柱； - 子任务2: 将A柱上的大盘移至C柱； - 子作务3：将n - 1 = 4个盘从B柱移至C柱，以A柱为中转柱。 不难看出，除了柱子不同，子任务3同子任务1所做的工作是一样的，都是把 n - 1 个盘从一个柱移至另一个柱。同时，子任务1，3与总任务之间也极其相似，除了需要移动的盘子数量差异外。 我们称，将n - 1个盘子从A移至B的汉诺塔问题，与原问题 - 即“将n个盘子从A移至C的汉诺塔问题”的性质完全相同，区别仅在于问题的规模 - 需要移动的盘子数量稍小。我也称为前者是原问题的子问题。 如果我们能将n - 1 = 4个盘子从A移至B，从B移至Ｃ，那么n = 5个盘子的汉诺塔问题可解。那么如何求解4个盘子的汉诺塔问题呢？ 聪明的读者已经有了答案。 子问题: 将 n’ = 4个盘从A柱移至B柱，以C柱为中转柱 - 子子问题1: 将 n’ - 1 = 3个盘从A柱移至C柱，以B柱为中转柱； - 简单任务: 将A柱上的大盘移至B柱； - 子子问题2：将n’ - 1 = 3个盘从C柱移至B柱，以A柱为中转柱。 ​ 下面的图展示了这一过程： 上面的分析可以看出，5盘汉诺塔问题可以通过求解4盘汉诺塔问题来解决，4盘汉诺塔问题可以通过求解3盘汉诺塔问题来解决。同理，3盘汉诺塔问题可以通过求解2盘汉诺塔问题来解决，2盘汉诺塔问题可以通过求解一盘汉诺塔问题来解决。而一盘汉诺塔问题，由于问题的规模足够小，可直接解决：把盘从原柱搬至目标柱即可。所以在前表中，我们称其为“简单任务”。 2). 递归算法根据前一小节描述的算法思想，我们可以写出汉诺塔问题求解的递归算法。请见下述C++程序： 12345678910111213141516171819202122232425262728//Project - HanoiTower#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;vector&lt;string&gt; steps; //用于存放移盘序列的向量void hanoi(int n, const char* a, const char* b, const char* c) &#123; if (n==1) steps.push_back(string(a) + \" --&gt; \" + c); else &#123; hanoi(n-1, a, c, b); steps.push_back(string(a) + \" --&gt; \" + c); hanoi(n-1, b, a, c); &#125;&#125;int main() &#123; steps.clear(); hanoi(5,\"A\",\"B\",\"C\"); cout &lt;&lt; \"Steps count: \" &lt;&lt; steps.size() &lt;&lt; endl; cout &lt;&lt; \"First 3 steps are: \" &lt;&lt; steps[0] &lt;&lt; \", \" &lt;&lt; steps[1] &lt;&lt; \", \" &lt;&lt; steps[2]; return 0;&#125; 上述程序的执行结果为： 12Steps count: 31First 3 steps are: A --&gt; C, A --&gt; B, C --&gt; B 函数hanoi(n,a,b,c)用于生成以b为中转柱，将n个金盘从a移至c的移盘序列。可以看到，这个递归函数的执行过程跟前节的总任务-子任务分解完全一致。当n == 1时，只有一个盘子，简单任务，直接移盘。如果n &gt; 1，则分解为两个 n - 1 的汉诺塔子问题，以及一个简单移盘任务。子问题的求解以函数递归调用来解决。 上述结果表明，5盘汉诺塔问题共需要31次移盘。steps向量按顺序存储了全部的移盘动作。 1vector&lt;string&gt; steps; //用于存放移盘序列的向量 第7行：vector（向量）类型由vector头文件引入。当前阶段，读者可以把vector&lt;string&gt;当成是一个容量“无限大”的超级数组，尖括号里的string则约定了该数组内存储的元素类型。 1steps.push_back(string(a) + \" --&gt; \" + c); 第11、14行：push_back( )是steps向量的一个成员函数▲，它将参数字符串存入向量。string(a)是string类型的构造函数▲，它将char*类型的参数a转换成一个string类型的对象。由于steps是个容量“无限大”的超级数组，所以程序员可以放心地通过push_back( )函数将对象放入向量，而不必担心容量限制。 1cout &lt;&lt; \"Steps count: \" &lt;&lt; steps.size() &lt;&lt; endl; 第24行：size( )也是steps向量的成员函数，返回steps向量中存储的string对象的个数。此处表示n盘汉诺塔问题的移盘总次数。 12cout &lt;&lt; \"First 3 steps are: \" &lt;&lt; steps[0] &lt;&lt; \", \" &lt;&lt; steps[1] &lt;&lt; \", \" &lt;&lt; steps[2]; 第25 ~ 26行：既然向量就是“超级数组”，则[ ]操作符对向量同样适用，它用于取向量中指定下标的元素。 关于vector类型的使用方法及工作原理，我们将来后续章节中进一步讨论。 3). 计算复杂性使用前小节中的程序，作者尝试计算了n = 5 … 12汉诺塔问题的移盘过程，得到下述移盘次数。 盘数 所需移盘次数 评论 5 31 25-1 6 63 26-1 7 127 27-1 8 255 28-1 … 12 4095 212-1 看起来，似乎n个盘的汉诺塔问题的移盘次数为2n-1。事实上，对移盘次数的数学分析可以证明这个结论。n盘的汉诺塔求解可以拆分成两个n-1盘的汉诺塔求解再加上1次简单移盘。如果用T(n)来表示n盘汉诺塔的移盘次数的话，函数T(n)可使用下述递归定义。$$T(n) = \\begin{cases} 1 &amp; n=1\\2T(n-1) + 1 &amp;n&gt;1 \\end{cases}$$​ 我们试着把递归函数消解成非递归函数。$$\\begin{aligned} T(n) &amp;= 2T(n-1) + 1 \\ &amp;= 2(2T(n-2) + 1) + 1 = 4T(n-2)+2 +1 = 2^2T(n-2) + 2^1 + 2^0\\ &amp;= 2^2(2T(n-3)+1)+2^1+2^0 = 2^3T(n-3) + 2^2 + 2^1 + 2^0\\ &amp;= … \\ &amp;= 2^tT(n-t) + 2^{t-1}+2^{t-2}+…+2^1+2^0\\ \\end{aligned}$$令t = n - 1，有：$$\\begin{aligned} T(n) &amp;= 2^{n-1}T(1) + 2^{n-2} + 2^{n-3} + … + 2^1+2^0\\ &amp;= \\sum\\limits_{t=0}^{n-1}2^t \\&amp;= 2^n-1 \\end{aligned}$$故n盘汉诺塔共需移盘2n-1次。那么，如果梵天规定的是64个金盘的话，总移动次数则为264-1 = 18446744073709551615。如果婆罗门僧侣是个熟练工，1秒挪一个盘，那么1小时可以移3600个盘，1年可移3600 x 24 x 365 = 31536000个盘(忽略闰年误差）。那么，解64盘汉诺塔问题共需要(264-1)/31536000年，即大约5949亿年。看起来，按照当前的人类知识，印度的古老智慧好像高估了地球的预期寿命。 读者不要去尝试计算hanoi(64,”A”,”B”,”C”)，显然，在你有限的人生里，是无法完成这件接近“无限”的大事的。而且，因为递归所导致的内存消耗，你有限的计算机内存也排除了这种可能性。 作者是无神论者，上述探讨基于严谨的数学，作者不相信任何人格化的“上帝 ”。 7.7 函数指针指针可以指向变量/常量等对象，也可以指向函数。指向函数的指针称为函数指针（function pointer）。应用程序开始执行前，其二进制代码会被操作系统调入内存。作为程序的一部分，函数当然也占据内存并拥有内存地址，该地址可以被赋值给函数指针。请阅读下述C语言代码： 123456789101112131415161718192021//Project - FuncPointer#include &lt;stdio.h&gt;int add(int a, short b)&#123; return a + b;&#125;int main() &#123; float f = 3.3F; int c = 33; printf(\"add = %p, &amp;f = %p, &amp;c = %p\\n\", add, &amp;f, &amp;c); int (*pf)(int, short) = NULL; pf = add; printf(\"pf = %p, &amp;pf = %p\\n\", pf, &amp;pf); int d = pf(3,2); printf(\"3+2 = %d\", d); return 0;&#125; 上述程序的执行结果为： 123add &#x3D; 0000000000401560, &amp;f &#x3D; 000000000061FE18, &amp;c &#x3D; 000000000061FE14pf &#x3D; 0000000000401560, &amp;pf &#x3D; 000000000061FE083+2 &#x3D; 5 说明：在读者的计算机上，执行结果中的地址很可能与本书不同。 图7- 函数与数据的内布分区 根据上述程序的执行结果，我们画出了本例中相关对象在作者计算机上的内存分布局7- 。 从该图中，我们可以看到，操作系统对代码（程序）和数据进行了分区管理，分为代码存储区以及数据存储区。一般地，操作系统和计算机的安全机制会禁止在程序运行过程中修改代码存储区的内容，这块区域是只读的。 1printf(\"add = %p, &amp;f = %p, &amp;c = %p\\n\", add, &amp;f, &amp;c); 第11行：将函数名add按地址格式输出；输出局部变量f、c的地址。从执行结果的第1行可见，函数名add即为相关执行代码在“代码存储区”中的内存地址。add的地址与局部变量f，c的地址相差甚远，提示它们应该不在同一块内存区域。f和c的地址则相差不多，它们都位于数据存储区。 1int (*pf)(int, short) = NULL; 第13行：定义了指向函数的指针变量，变量名为pf，并将该指针初始化为空指针。下面给出了函数指针定义的一般格式。 1函数返回值类型 (*函数指针名)(形参0的类型,形参1的类型, ... ,形参n的类型) 从该格式可以看出，一个函数指针的定义需要包含如下信息： 所指向的函数的返回值类型； 函数指针变量的名称； 所指向函数的形参个数、顺序及类型。 在上述格式中，包裹”*函数指针名”的括号必不可少。第13行中的函数指针定义如果去掉括号，就变成了： 1int *pf(int, short) 这对于编译器而言，还可以解释为：一个名为pf的函数，该函数接受int, short两个形参，返回一个int*对象。为了确保编译器将pf理解为指向函数的指针，而不是函数名，上述括号是必不可少。 1pf = add; 第14行：将add( )函数的地址赋值给函数指针变量pf。赋值完成后，pf指针指向add( )函数。请读者注意，这个赋值操作能够进行的前提是pf与add拥有相同的类型。add是函数名，即函数的地址，add( )函数接受一个int和一个short形参，返回一个int对象，这些事项均与pf的定义一致。 1printf(\"pf = %p, &amp;pf = %p\\n\", pf, &amp;pf); 第15行：pf是个函数指针，同时也是一个局部变量，它存储在数据存储区并拥有地址。从执行结果的第2行可见，pf的值即为add( )函数的地址，pf对象自身存储在数据存储区，其地址与另外两个局部变量c，f很近。 12int d = pf(3,2);printf(\"3+2 = %d\", d); 第17 ~ 18行：以函数指针pf为基础，调用执行add( )函数，并将结果赋值给变量d，然后打印出来。执行结果的第3行可见，d值为5，通过函数指针pf，add( )函数正确执行。 比较令人烧脑的是，对于C/C++语言而言，下述两种通过函数指针pf调用add( )函数的方法正是正确的： 12int d = pf(3,2);int e = (*pf)(3,2); 前者认为，pf是一个函数地址，函数名add事实上也是函数地址，所以pf也可以视为函数名。后者认为，pf是一个指向函数的指针，*pf才代表它所指向的函数。两者都有道理，较新的C/C++标准同时接受两种用法。 为了简要演示函数指针的应用，我们“创造”了下述问题。在一个string类型的数组里，存储了多个国家的英文名称： 1string names[] &#123;\"China\", \"United States\", \"Russia\", \"Afghanistan\"&#125;; 现要求使用下述两种方法对这些国家名称进行非递减排序： 按字母表顺序； 按国名长度，即国名中包含的字符个数排序。 在微实践 - 冒泡排序里，我们设计了bubbleSort( )函数。要实现两种不同的排序策略，最直接的办法当然是设计两个版本的bubbleSort( )函数来完成，但这样做会增加工作量以及代码冗余。另外一种解决方案是把两种不种的排序策略设计为两个不同的比较函数，然后把比较函数作为函数指针传递给bubbleSort( )函数。在bubbleSort( )函数内部进行排序时，使用传入的函数指针来调用相应的比较函数来进行元素比较。相应的C++程序如下： 1234567891011121314151617181920212223242526272829303132333435363738//Project - FuncPointer2#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;void bubbleSort(string a[],const int n,bool (*bigger)(const string&amp;, const string&amp;))&#123; for (int i=n-1;i&gt;0;i--) for (int j=0;j&lt;i;j++)&#123; if (bigger(a[j],a[j+1]))&#123; auto t = a[j]; a[j] = a[j+1]; a[j+1] = t; &#125; &#125;&#125;bool biggerThan1(const string&amp; a, const string&amp; b)&#123; return a &gt; b;&#125;bool biggerThan2(const string&amp; a, const string&amp; b)&#123; return a.size() &gt; b.size();&#125;int main() &#123; string names[] &#123;\"China\", \"United States\", \"Russia\", \"Afghanistan\"&#125;; bubbleSort(names, 4, biggerThan1); cout &lt;&lt; \"sorted1: \" &lt;&lt; names[0] &lt;&lt; \", \" &lt;&lt; names[1] &lt;&lt; \", \" &lt;&lt; names[2] &lt;&lt; \", \" &lt;&lt; names[3] &lt;&lt; endl; auto pf = biggerThan2; bubbleSort(names, 4, pf); cout &lt;&lt; \"sorted2: \" &lt;&lt; names[0] &lt;&lt; \", \" &lt;&lt; names[1] &lt;&lt; \", \" &lt;&lt; names[2] &lt;&lt; \", \" &lt;&lt; names[3] &lt;&lt; endl; return 0;&#125; 上述程序的执行结果为： 12sorted1: Afghanistan, China, Russia, United Statessorted2: China, Russia, Afghanistan, United States 123bool biggerThan1(const string&amp; a, const string&amp; b)&#123; return a &gt; b;&#125; 第17 ~ 19行：biggerThan1( )函数返回表达式a &gt; b的值，a、b字符串的这种比较是以字母表顺序为依据的。按这种比较方式，“China” &gt; “Afghanistan”，因为在字母表中，C排在A之后。 123bool biggerThan2(const string&amp; a, const string&amp; b)&#123; return a.size() &gt; b.size();&#125; 第21 ~ 23行：biggerThan2( )函数返回表达式a.size( ) &gt; b.size( )的值。其中，size( )成员函数返回字符串内的字符个数。按照这种比较方式，”Afghanistan” &gt; “China”，因为前者有11个字符，后者只有5个。 1void bubbleSort(string a[], const int n, bool (*bigger)(const string&amp;, const string&amp;)) 第6行：改进后的bubbleSort( )函数多了一个形式参数bigger，其类型为函数指针，其指向的函数接受两个string作为参数，返回一个bool。显然，bigger的类型与biggerThan1( )、biggerThan2( )函数一致。 1if (bigger(a[j],a[j+1]))&#123; 第9行：冒泡排序循环中，通过函数指针bigger调用指定的比较函数对a[j]和a[j+1]进行比较。 123bubbleSort(names, 4, biggerThan1);cout &lt;&lt; \"sorted1: \" &lt;&lt; names[0] &lt;&lt; \", \" &lt;&lt; names[1] &lt;&lt; \", \" &lt;&lt; names[2] &lt;&lt; \", \" &lt;&lt; names[3] &lt;&lt; endl; 第28 ~ 30行：执行bubbleSort( )函数对names数组进行排序，将biggerThan1( )函数传入作为比较函数。从执行结果的第1行可见，names确实按照字母表顺序进行了排序，Afghanistan（阿富汗）排在China之前。 1auto pf = biggerThan2; 第32行：当把函数名赋值给一个函数指针时，必须确保函数指针的类型与函数相同。【C++ 11】的auto类型推导可以帮助我们省去描述函数指针类型的麻烦，在C++ 11及其以上版本的编译器下，pf的类型将被推断为： 1void (*)(string[ ], const int, bool (*)(const string&amp;, const string&amp;)) 123bubbleSort(names, 4, pf);cout &lt;&lt; \"sorted2: \" &lt;&lt; names[0] &lt;&lt; \", \" &lt;&lt; names[1] &lt;&lt; \", \" &lt;&lt; names[2] &lt;&lt; \", \" &lt;&lt; names[3] &lt;&lt; endl; 第33 ~ 35行：将pf函数指针传给bubbleSort( )进行排序。由于pf指向biggerThan2( )函数，所以bubbleSort( )函数内的元素比较事实上执行biggerThan2( )函数，即按字符串长度排序。从执行结果的第2行可见，names确实按照字符串长度进行了排序，Afghanistan字符数多，排在China和Russia之后。 作者在第32行引入pf指针完全是为了说明auto类型推断在函数指针定义中的作用。 1234bool (*pfarray[2])(const string&amp;, const string&amp;);pfarray[0] = biggerThan1;pfarray[1] = biggerThan2;pfarray[0](\"China\",\"India\"); 进一步，上述代码的第1行定义了一个函数指针数组pfarray，该数组有2个元素，元素类型为bool (*)(const string&amp;, const string&amp;)。第2行及第3行则将biggerThan1( )及biggerThan2( )函数名赋值给数组元素。第4行则通过pfarray[0]对biggerThan1( )函数进行调用。 1234typedef bool (*biggerFunc)(const string&amp;, const string&amp;);biggerFunc pfarray2[2];pfarray2[0] &#x3D; biggerThan1;pfarray2[1] &#x3D; biggerThan2; 通过typedef（类型定义）▲语句可以帮助我们简化函数指针的定义和使用过程。上述代码的第1行将biggerFunc定义为一个类型，该类型的具体内容为bool (*)(const string&amp;, const string&amp;)。第2行则使用biggerFunc类型来定义函数指针数组。这里的函数指针数组pfarray2跟前述pfarray完全等价。 提示：如果作者愿意，还可以花上几十页写出更加复杂的函数指针的语法和示例，但这不值得。在程序设计过程中，应该尽可能使用简单的语法和易于理解的算法，尽量避免诸如上述函数指针数组等复杂特性的使用。高质量代码的一个重要特性，就是简单和易于理解（代码可读性）。 7.8 默认值参数【C++】里，可以为函数的形式参数指定默认值。请阅读下述C++代码，并注意其中add( )函数的形式参数： 1234567891011121314//Project - DefaultParameter#include &lt;iostream&gt;using namespace std;int add(int a, int b, int c = 0, int d = 0)&#123; return a + b + c + d;&#125;int main() &#123; cout &lt;&lt; \"1+2 = \" &lt;&lt; add(1,2) &lt;&lt; endl; cout &lt;&lt; \"1+2+3 = \" &lt;&lt; add(1,2,3) &lt;&lt; endl; cout &lt;&lt; \"1+2+3+4 = \" &lt;&lt; add(1,2,3,4) &lt;&lt; endl; return 0;&#125; 上述代码执行结果为： 1231+2 &#x3D; 31+2+3 &#x3D; 61+2+3+4 &#x3D; 10 1int add(int a, int b, int c = 0, int d = 0)&#123; 第5行：区别于之前的函数定义，add( )函数的形参中，最后两个c和d给出了默认值0。这种方式给函数的使用者带来极大方便，当调用函数时，如果提供的实参数量不足，编译器会尝试对形参使用默认值。 1cout &lt;&lt; \"1+2 = \" &lt;&lt; add(1,2) &lt;&lt; endl; 第10行：add(1,2)只提供了两个实参，a取1，b取2，c和d取默认值0。在函数的使用者看来，这次函数调用是把1和2两个数相加，其结果为3。而在编译器看来，这次函数调用本质上是把1，2，0，0共4个数相加，结果为3。 1cout &lt;&lt; \"1+2+3 = \" &lt;&lt; add(1,2,3) &lt;&lt; endl; 第11行：add(1,2,3)只提供了3个实参，a取1、b取2、c取3、d取默认值0。在函数的使用者看来，这次函数调用是把1、2和3共3个数相加，其结果为6。而在编译器看来，这次函数调用本质上是把1，2，3，0共4个数相加，结果为6。 1cout &lt;&lt; \"1+2+3+4 = \" &lt;&lt; add(1,2,3,4) &lt;&lt; endl; 第12行：add(1,2,3,4)提供了4个实参，a取1、b取2、c取3、d取4。无论从使用者视角，还是编译器视角，都是把1，2，3，4共4个数相加，结果为10。 如果程序中既出现了函数的原型，又出现了函数的定义，则只允许在原型或者定义中提供形参的默认值。 12345int add(int a, int b, int c = 0, int d = 0); //函数原型int add(int a, int b, int c, int d = 0)&#123; //函数定义 return a + b + c + d;&#125; 上述程序会编译出错，因为add( )函数的原型和定义中同时给出了形参默认值。作者建议尽量在函数原型中给出形参默认值，因为对于使用者而言，原型是函数的接口（interface）▲，在接口中展示形参默认值有助于使用者更好地掌握函数的使用方法。 为函数提供的形参默认值只能提供给形参列表的最后N个。请看下述函数声明： 123void f1(int a, int b = -1, float c = 0); //合法double f2(float a, bool b = true, char c); //非法, b有默认值，则c也必须有bool f3(char a = 'k', int b = 22, bool c = false); //合法 之所以作出如上规定，是为了避免编译器在将实际参数分配给形式参数时产生歧义。 7.9 内联函数函数调用需要花费额外的CPU及内存资源： 为函数的形参分配内存空间，向函数传递参数； 跳转至函数体； 从函数体跳转回调用点； 获取函数的返回值。 图7- 非内联函数调用流程图 图7- 展示了一个非内联的普通函数average( )被多次调用时的执行流程： average( )函数编译后的二进制执行代码在可执行文件只有一个副本； main( )函数多次调用执行average( )函数，每次执行，都会在传参后跳转至average( )函数在内存中的唯一副本处执行，再返回。 每次函数调用，都意味着额外的CPU及内存开销。将函数内联（inline）是避免上述函数调用开销的办法之一。C99标准规定内联函数必须具有内部链接▲且其定义并必须与调用该函数的代码处于同一个文件中。因此，C语言中定义一个内联函数最简单方法是在函数头前加上inline static。inline关键字是内联的意思，static则表示存储类别▲。请阅读下述C语言程序： 123456789101112131415161718192021222324//Project - MultiCall#include &lt;stdio.h&gt;inline static float average(float* a, int n) &#123; float fSum = 0; for (int i=0;i&lt;n;i++) fSum += a[i]; return fSum/n;&#125;int main() &#123; float values[] = &#123;0,1,2,3,4,5,6,7,8,9&#125;; float v4 = average(values,4); printf(\"v4 = %f\\n\",v4); float v7 = average(values,7); printf(\"v7 = %f\\n\",v7); float v10 = average(values,10); printf(\"v10 = %f\\n\",v10); return 0;&#125; 上述程序的执行结果为： 123v4 &#x3D; 1.500000v7 &#x3D; 3.000000v10 &#x3D; 4.500000 上述代码中，main( )函数三次调用average( )函数，用于计算values数组前4个、前7个以及前10个元素的平均数。由于average( )函数被定义为内联函数（inline static function），所以编译器会在average( )函数的调用点将该函数就地展开，以空间换时间： 如图7- 所示，函数展开后，average( )的函数体代码将在最终的可执行文件中出现三个副本，增加了存储空间。 内联函数展开后，函数调用的跳转被消除，节省了执行时间。 图7- 内联函数的展开 说明：因为编译器优化的存在，实际函数展开结果会与图7- 有差异。 为了帮助读者理解在何种情况下应该使用内联函数，我们设计了如下C++程序： 123456789101112131415161718192021//Project - InlineExample#include &lt;iostream&gt;#include &lt;bitset&gt;using namespace std;//将无符号整数v的第bit位设置为1inline void setBit(unsigned int&amp; v, int bit)&#123; v |= (0x01 &lt;&lt; bit);&#125;int main() &#123; unsigned int v = 0x00000000; cout &lt;&lt; \"before setBit: \" &lt;&lt; bitset&lt;32&gt;(v) &lt;&lt; endl; setBit(v,0); setBit(v,31); v |= (0x01 &lt;&lt; 11); cout &lt;&lt; \"after setBit: \" &lt;&lt; bitset&lt;32&gt;(v) &lt;&lt; endl; return 0;&#125; 上述程序的执行结果为： 12before setBit: 00000000000000000000000000000000after setBit: 10000000000000000000100000000001 一个无符号整数由4个字节共32个比特构成。C/C++提供按位操作符允许我们直接对变量的比特位▲进行操作。setBit(v,bit)函数用于将无符号整数v的第bit位设置为1。 123inline void setBit(unsigned int&amp; v, int bit)&#123; v |= (0x01 &lt;&lt; bit);&#125; 第7 ~ 9行：定义了内联函数setBit( )。与C语言不同，C++中仅需在函数声明或者定义前加上inline关键字即可将函数设定为内联函数。第8行代码通过按位操作符将v的第bit位设置为1，按位操作的工作原理及语法细节在本书第x章中讨论。 12unsigned int v = 0x00000000;cout &lt;&lt; \"before setBit: \" &lt;&lt; bitset&lt;32&gt;(v) &lt;&lt; endl; 第12 ~ 13行：定义了初如值为0的无符号整数v，通过bitset类型将其按二进制格式输出。bitset类型由bitset头文件引入，其语法及工作原理在本书第x章中讨论。执行结果的第1行可见，setBit( )函数执行前，v的32个比特全为0（高位在前，低位在后）。 123setBit(v,0);setBit(v,31);v |= (0x01 &lt;&lt; 11); 第15 ~ 17行：调用setBit( )函数两次将v的第0位（最低位），第31位（最高位）设为1。第17行则直接使用按位操作符将v的第11位设置为1。 1cout &lt;&lt; \"after setBit: \" &lt;&lt; bitset&lt;32&gt;(v) &lt;&lt; endl; 第19行：按二进制格式输出第0位、第11位、第31位置1后的v值。执行结果的第2行可见，上述置1操作成功执行。 既然直接使用按位操作符（如第17行）可以达到目的，那为何要定义setBit( )函数呢？引用setBit( )函数这种似乎不必要的函数的唯一目的是增强代码的可读性。对于代码的阅读者而言，setBit( )函数更容易理解和使用。但如果setBit( )是个普通函数，其引入也带来了负面效应：函数参数传递、跳转的额外开销。通过将setBit( )设置为内联函数则可以兼得鱼和熊掌：既增加了代码的可读性，又避免了因函数引入开来的额外开销。 将一个函数定义为内联函数并不能保证编译器将函数内联。至少在下述两种情况下，编译器会选择忽视inline关键字，不内联函数： 函数过于冗长和复杂。这也通常意味着相对于函数体本身的执行代价，与函数调用有关的额外开销无足轻重，将函数内联的价值很小。 递归函数。递归函数调用是无法展开的，其中一个理由是递归函数的递归次数在编译时无法确定。 7.10 函数名重载在C语言里，同一个程序中的函数名必须互不相同。【C++】中的函数名重载（function overloading）允许多个函数使用相同的函数名，前提是每个函数的形参类型或顺序不同。 1234567891011void swapFloat(float&amp; a, float&amp; b)&#123; auto t = a; a = b; b = t;&#125;void swapDouble(double&amp; a, double&amp; b)&#123; auto t = a; a = b; b = t;&#125; 对计算机而言，“交换两个float对象的值”与“交换两个double对象的值”是不一样的操作，需要的机器指令也不相同。这意味着，我们需要设计两个函数，分别完成交换float对象和交换double对象的任务。在“函数名不可重复”的要求下，我们不得不为两个函数取不同的名称，本例中，分别取名为swapFloat和swapDouble。但从函数使用者的角度看，这会带来一些不便：根据不同的参数类型去选择“不同”的函数，带来额外的记忆与使用成本。 借助于C++的函数名重载，我们可以给多个函数取相同的函数名。下述C++程序使用了上述交换函数的函数名重载版本： 1234567891011121314151617181920212223242526272829//Project - FuncOverloading1#include &lt;iostream&gt;using namespace std;void swapObject(float&amp; a, float&amp; b)&#123; cout &lt;&lt; \"swapObject_float,a=\" &lt;&lt; a &lt;&lt; \",b=\" &lt;&lt; b &lt;&lt; endl; auto t = a; a = b; b = t;&#125;void swapObject(double&amp; a, double&amp; b)&#123; cout &lt;&lt; \"swapObject_double,a=\" &lt;&lt; a &lt;&lt; \",b=\" &lt;&lt; b &lt;&lt; endl; auto t = a; a = b; b = t;&#125;int main() &#123; double d1 &#123;1.1&#125;, d2&#123;9.9&#125;; swapObject(d1,d2); cout &lt;&lt; \"d1 = \" &lt;&lt; d1 &lt;&lt; \", d2 = \" &lt;&lt; d2 &lt;&lt; endl; float f1 &#123;2.2&#125;, f2 &#123;8.8&#125;; swapObject(f1,f2); cout &lt;&lt; \"f1 = \" &lt;&lt; f1 &lt;&lt; \", f2 = \" &lt;&lt; f2 &lt;&lt; endl; return 0;&#125; 上述程序的执行结果为： 1234swapObject_double,a&#x3D;1.1,b&#x3D;9.9d1 &#x3D; 9.9, d2 &#x3D; 1.1swapObject_float,a&#x3D;2.2,b&#x3D;8.8f1 &#x3D; 8.8, f2 &#x3D; 2.2 可以看到，两个交换函数现在具有完全相同的名称(swapObject)、返回值类型（void）、形参的名称和个数（a，b），唯一的区别是形参的类型不同，一个是double&amp;，一个是float&amp;。 123double d1 &#123;1.1&#125;, d2&#123;9.9&#125;;swapObject(d1,d2);cout &lt;&lt; \"d1 = \" &lt;&lt; d1 &lt;&lt; \", d2 = \" &lt;&lt; d2 &lt;&lt; endl; 第20 ~ 22行：将double类型的d1和d2作为实参调用执行swapObject( )函数，从执行结果的第1，2行可见，编译器依据实参d1，d2的类型选择执行了函数swapObject(double&amp;, double&amp;)，d1和d2成功交换。 123float f1 &#123;2.2&#125;, f2 &#123;8.8&#125;;swapObject(f1,f2);cout &lt;&lt; \"f1 = \" &lt;&lt; f1 &lt;&lt; \", f2 = \" &lt;&lt; f2 &lt;&lt; endl; 第24 ~ 26行：将float类型的f1和f2作为实参调用执行swapObject( )函数，从执行结果的第3，4行可见，编译器依据实参f1，f2的类型选择执行了函数swapObject(float&amp;, float&amp;)，f1和f2成功交换。 从本例可知：当函数调用时，如果存在多于一个的同名函数，C++编译器会试图通过实参的类型去匹配并选择正确的函数。在函数使用者的视角，可以认为只有一个名为swapObject的函数，它既可以交换float，也可以交换double。在编译器看来，事实上有两个交换函数，一个用于交换float，一个用于交换double，只是这两个函数恰好同名而已。 名字装饰：编译器通过一种叫做名字装饰（name decoration）的技术来区分两个同名的swapObject函数。该技术通过把形参的类型附加在函数名的后面来得到不同的内部函数名。比如，本例中的函数名可能被修饰为swapObject_Rf_Rf和swapObject_Rd_Rd，其中的Rf和Rd分别表示float的引用（Reference of float）及double的引用。不同的编译器会使用不同的符号来对函数名进行装饰，装饰后的函数名事实上仅用于编译器内部，程序员通常不用关心具体的装饰名是什么。 函数名重载只能依赖于形参的个数、类型及顺序，不能依赖于返回值类型。因为函数调用时，使用者可以选择不接收函数的返回值，这种情况下，编译器无法区分仅返回值类型不同的同名函数。 1234int f1(int a, float b, char c);int f1(float a, int b, char c);char f1(char a, int b);//void f1(int a, float b, char c); //错误：函数名重载不能依赖于返回值类型 上述名为f1的函数中，第2行的f1形参的类型顺序与其它f1函数不同，合法。第3行的f1形参的个数与其它f1函数不同，也合法。第4行的f1其形参个数、类型及顺序与第1行的f1函数相同，仅返回值类型不同，不合法。 7.11 模板函数还是考虑用于交换两个同类型对象的swapObject( )函数，我们已经为double和float两种类型设计了两个版本的同名函数，还有char、string、long long、int等多种类型的版本等待我们的实现。这显然是个坏主意！ 借助于函数模板，我们可以设计一个通用的swapObject( )函数，适用于“所有“的数据类型。请阅读下述C++程序： 1234567891011121314151617181920212223242526//Project - TemplateSwap#include &lt;iostream&gt;using namespace std;template &lt;typename T&gt;void swapObject(T&amp; a, T&amp; b)&#123; auto t = a; a = b; b = t;&#125;int main() &#123; char c1 &#123;'a'&#125;, c2 &#123;'z'&#125;; swapObject(c1,c2); cout &lt;&lt; \"c1 = \" &lt;&lt; c1 &lt;&lt; \", c2 = \" &lt;&lt; c2 &lt;&lt; endl; double d1&#123;1.1&#125;, d2&#123;9.9&#125;; swapObject(d1,d2); cout &lt;&lt; \"d1 = \" &lt;&lt; d1 &lt;&lt; \", d2 = \" &lt;&lt; d2 &lt;&lt; endl; short s1&#123;-22&#125;, s2&#123;22&#125;; swapObject&lt;short&gt;(s1,s2); cout &lt;&lt; \"s1 = \" &lt;&lt; s1 &lt;&lt; \", s2 = \" &lt;&lt; s2 &lt;&lt; endl; return 0;&#125; 上述代码的执行结果为： 123c1 &#x3D; z, c2 &#x3D; ad1 &#x3D; 9.9, d2 &#x3D; 1.1s1 &#x3D; 22, s2 &#x3D; -22 第5 ~ 10行：swapObject( )函数的定义过程中，将形参的引用类型T抽象为一个模板参数。 12char c1 &#123;'a'&#125;, c2 &#123;'z'&#125;;swapObject(c1,c2); 第13 ~ 14行：当提供两个char类型的实参给swapObject( )函数，聪明的编译器会用char类型替换模板参数T，“内部生成”swapObject(char&amp;, char&amp;)函数并使用之。 第17 ~ 18行：当提供两个double类型的实参给swapObject( )函数，编译器会在“内部”生成swapObject(double&amp;, double&amp;)函数并使用之。 12short s1&#123;-22&#125;, s2&#123;22&#125;;swapObject&lt;short&gt;(s1,s2); 第20 ~ 21行：第21行尖括号内的short内显式地指定了模板参数T的值，要求编译器生成函数swapObject(short&amp;, short&amp;)并使用之。 当程序员试用调用执行一个函数时，编译器会“千方百计”地满足程序员的要求。比如，当函数要求一个int类型的传值参数，而实参是一个short对象时，编译器会进行类型提升，将short对象隐式类型转换为int对象并传值给函数。可以认为：只要编译器认为类型提升和转换不会带来风险，编译器会通过对实参进行类型提升或转换来尽可能满足函数形参的要求。 由于默认值参数、函数名重载、模板函数的使用，有些情况下，一行函数调用代码可能存在多个“合法”的候选函数。此时，编译器会选择最佳的可行函数来使用。显而易见，当多个“最佳”可行函数时，编译器会报错或者至少给出警告。实践中，程序员会尽量避免这种有歧义的函数调用发生。 7.12 decltype声明类型**【C++ 11】中的auto关键字可以通过变量的初始化值来推断确定变量的类型。decltype关键字【C++ 11】源于英文declare type（声明类型），它可以推断一个表达式的结果类型。decltype操作符的用法请见下述代码及其注释。 1234567int a = 1;float b = 1.1F;decltype(a+b) c; //int + float结果为float， c被推断为floatdecltype(b*a) d; //float * int结果为float， d被推断为floatfloat&amp; e = b; decltype(e) f = b; //e的类型为float&amp;，f被推断为float&amp; 其中，第7行的f被推断为float&amp;，编译器会要求程序员对引用f进行初始化，即它必须与一个float对象相关联。 为了讨论decltype的应用场景，请读者阅读下述代码： 12345template &lt;typename T1, typename T2&gt;decltype(a+b) add(T1&amp; a, T2&amp; b)&#123; //错误：a,b的声明在decltype(a+b)之后 auto c = a + b; return c;&#125; 模板函数add( )试图将T1类型的a和T2类型的b相加，其结果类型既可能是T1，也可能是T2，甚至可能是其它类型▲，因此，该模板函数试图通过decltype(a+b)来推断确定返回类型。看起来很合理，但对编译器而言，decltype(a+b)出现时，a，b尚未声明，不符合语法要求。为了解决这个问题，【C++ 11】引入了返回类型后置语法： 123456template &lt;typename T1, typename T2&gt;auto add(T1&amp; a, T2&amp; b) -&gt; decltype(a+b) //返回类型后置&#123; auto c = a + b; return c;&#125; 第2行的auto起到占位的作用，箭头 -&gt; 后面的decltype(a+b)则后置定义了函数的返回值类型。 有点麻烦，对吗？ 【C++ 17】对持此相同观点，它去除了这个麻烦。下述代码在C++ 17的编译器下可以正常工作： 12345678910111213141516171819202122//Project - DeclareType#include &lt;iostream&gt;using namespace std;template &lt;typename T1, typename T2&gt;auto add(T1&amp; a, T2&amp; b) // -&gt; decltype(a+b)在C++ 17中不再被需要&#123; auto c = a + b; return c;&#125;int main() &#123; int a = 1; float b = 1.1F; auto c = add(a,b); auto d = add&lt;float,int&gt;(b,a); cout &lt;&lt; \"c = \" &lt;&lt; c &lt;&lt; \", type = \" &lt;&lt; typeid(c).name() &lt;&lt; endl; cout &lt;&lt; \"d = \" &lt;&lt; d &lt;&lt; \", type = \" &lt;&lt; typeid(d).name() &lt;&lt; endl; return 0;&#125; 上述代码的执行结果为： 12c &#x3D; 2.1, type &#x3D; fd &#x3D; 2.1, type &#x3D; f 从执行结果可见，不论是int a + float b还是float b + int a，返回的结果都是float型，auto关键字正确推断了模板函数的返回值类型。 7.13 不确定数量的参数【？缺 扩展阅读】 8. 内存模型本讲义系重庆大学C/C++课程的教学笔记。 作者： 陈波 chenbo@cqu.edu.cn， All rights reserved. 未经作者许可，不允许经由互联网展示或提供下载。 不允许以纸质出版为目的进行摘抄或改编。 程序中的每一个对象都会占据内存空间。本章专门讨论不同类型对象的内存分配、管理及回收问题。 8.1 stack栈到目前为止，本书示例代码中定义的变量都是自动变量（automatic variables）。比如下述程序中的a和f。 12int a = 3;float f = 1.2; 所有对象都会占据内存空间，自动变量所占据的内存空间的分配与回收是由编译器负责的。而容纳这些自动变量的，是一种被称为堆栈（stack），简称为栈的数据结构。据信本书的大部分读者都不具备操作系统、CPU体系结构方面的知识，因此我们只能以比较”形象“但很可能不够准确的方式来解释编译器是如何借助于栈来管理自动变量的。 应用程序的栈空间是由操作系统分配的”固定“的有限大小的内存空间，如图8- 所示，这个栈空间是由栈底开始的一段连续的内存。在多数计算机上，栈空间由高地址的栈底向低地址方向生长。除了栈底之外，编译器还会保存一个叫做栈顶指针（stack pointer）的地址，从栈底一直到栈顶指针之间的区域，表示已经被分配利用的栈空间（网格状区域），栈顶指针之下的空白区域，则表示尚未利用的栈空间。 图8- 栈 我们结合图8- 来理解下述伪代码执行过程中的栈空间利用行为： 123456789101112void func(int b1, float b2, double b3)&#123; double b4 = b1 * b2 + b3; //...&#125;int main() &#123; int a1 = 1; float a2 = 2.1F; func(a1,a2,15.7); //... return 0;&#125; 第7 ~ 8行：编译器为自动变量a1，a2分配内存，它们存储在A区域，见图8- 函数调用前（1）。 第9行：调用执行函数func( )，函数的形参b1、b2、b3以及func( )内的局部变量b4都需要占据内存空间，所以编译器将栈顶指针下移，并将上述自动变量分配在B区域，见图8- 函数调用时（2）。需要说明的是，函数调用过程中还有一些额外的内存消耗，这些内存消耗也会使用图中B区域的空间。 第4行：当func( )函数执行结束时，其形参b1、b2、b3以及局部变量超出作用域范围。此时，编译器生成的机器指令将栈顶指针住上移，以回收栈空间。请参见图8- 函数调用返回后（3）。此时，B区域成为未利用的栈空间的一部分，可供后续程序使用。 不太严谨地，我们可以按如下方式总结C/C++语言的自动变量的内存管理：当一个新的代码块（比如函数调用）存在新定义的自动变量时，编译器生成代码下移栈顶指针，将新定义的自动变量安排在新开发的栈区域内。因代码块执行结束导致局部的自动变量超出作用范围时，编译器生成代码上移栈顶指针，回收内存。整个程序的执行过程伴随着无数次的栈顶指针移动 / 栈的生长和收缩。 我们通过执行下述C语言程序来“印证“上述理论的正确： 123456789101112131415161718192021222324252627//Project - StackExample2#include &lt;stdio.h&gt;void dummy(int i, int j)&#123; int k = i + j; printf(\"---------------dummy-------------\\n\"); printf(\"&amp;i = %p, &amp;j = %p\\n\", &amp;i, &amp;j); printf(\"&amp;k = %p, k = %d\\n\",&amp;k, k);&#125;void add(int d, int e, int f)&#123; int g = d + e; int h = f; printf(\"---------------add---------------\\n\"); printf(\"&amp;d = %p, &amp;e = %p, &amp;f = %p\\n\", &amp;d, &amp;e, &amp;f); printf(\"&amp;g = %p, &amp;h = %p, sum = %d\\n\", &amp;g, &amp;h, g + h);&#125;int main() &#123; int a=1,b=1,c=1; printf(\"&amp;a = %p, &amp;b = %p, &amp;c = %p\\n\", &amp;a, &amp;b, &amp;c); add(a,b,c); dummy(a,b); add(a,b,c); return 0;&#125; 上述代码的执行结果为： 12345678910&amp;a &#x3D; 000000000061FE1C, &amp;b &#x3D; 000000000061FE18, &amp;c &#x3D; 000000000061FE14---------------add---------------&amp;d &#x3D; 000000000061FDF0, &amp;e &#x3D; 000000000061FDF8, &amp;f &#x3D; 000000000061FE00&amp;g &#x3D; 000000000061FDDC, &amp;h &#x3D; 000000000061FDD8, sum &#x3D; 3---------------dummy-------------&amp;i &#x3D; 000000000061FDF0, &amp;j &#x3D; 000000000061FDF8&amp;k &#x3D; 000000000061FDDC, k &#x3D; 2---------------add---------------&amp;d &#x3D; 000000000061FDF0, &amp;e &#x3D; 000000000061FDF8, &amp;f &#x3D; 000000000061FE00&amp;g &#x3D; 000000000061FDDC, &amp;h &#x3D; 000000000061FDD8, sum &#x3D; 3 说明：在读者的计算机上，执行结果中的地址很可能与本书不同。 第20 ~ 21行：输出main( )函数内局部自动变量a，b，c的地址。从执行结果的第1行可见，它们的位于较高的地址，比较接近栈底。 1add(a,b,c); 第22行：执行add( )函数。从执行结果的第2 ~ 4行可见，add( )的形参d、e、f及局部变量g、h的地址较a、b、c更小，这说明栈顶指针下移，d、e、f、g、h被分配在了新开辟的栈区域内。 1dummy(a,b); 第23行：在add( )函数调用返回后执行dummy( )函数。从执行结果的第5 ~ 7行可见，dummy( )函数的形参i、j以及局部变量k被分配了与add( )函数形参及局部变量”几乎“相同的内存地址。这提示add( )函数返回时，编译器向上移动栈顶指针回收了内存，调用dummy( )函数时又再次下移栈顶指针，上述被回收的内存被再次利用。 1add(a,b,c); 第24行：在dummy( )函数调用返回后再次执行add( )函数。从执行结果的第8 ~ 10行可见，第二次add( )函数调用时，其内存分配情况与第一次add( )函数调用完全一致。这提示，编译器借助于栈，”完美“地处理了自动变量的内存分配和回收，坏账率为0，借出去多少，就收回来多少。 8.2 heap堆操作系统分配给应用程序的栈空间是有限且”固定“的。在作者的计算机（Windows 10, Qt Creator 4.11.0, mingw 7.3.0 64 bit）上，下述C语言程序会因为栈空间溢出而不能正常运行： 12345678//Project - StackOverflow#include &lt;stdio.h&gt;int main() &#123; int a[8000][100]; //如果在你的计算机上运行正常，那试着把100改成10000 printf(\"a[10][2] = %d, seems ok.\",a[10][2]); return 0;&#125; a数组的大小等于8000 x 100 x 4，大约等于3.2M字节的空间。这说明，自动变量不能存储大对象，如果我们需要在内存中保存巨量数据，还需要其它途径。这个其它途径就是堆（heap）。 堆也称为自由存储区（free store），是由操作系统管理的公共内存区域。区别于栈，堆不属于任何应用程序。任何应用程序均可通过操作系统API（Application Programming Interface，应用程序编程接口）向操作系统申请指定大小的堆内的存储空间，在资源允许的情况下，操作系统会尽量满足应用程序的内存需求。应用程序在使用完申请的内存后，应主动通过操作系统API释放该内存，以便操作系统将其用于其它用途。 在第6章中，我们已经使用过C语言的malloc( )、calloc( )函数从操作系统申请内存，使用完后再通free( )函数释放。事实上，malloc( )、calloc( )函数所申请的内存就源自于堆。 8.2.1 单个堆对象在C++语言中，我们通过new， delete操作符来申请和释放堆内存。请阅读下述C++语言示例： 123456789101112131415161718//Project - NewDelete1#include &lt;iostream&gt;#include &lt;stdio.h&gt;using namespace std;int main() &#123; int i = 3; int* p = new int; *p = 5; printf(\"i = %d, &amp;i = %p\\n\", i, &amp;i); printf(\"p = %p, &amp;p = %p, *p = %d\\n\", p, &amp;p, *p); delete p; printf(\"p = %p\", p); return 0;&#125; 上述程序的执行结果为： 123i &#x3D; 3, &amp;i &#x3D; 000000000061fe1cp &#x3D; 00000000001d17a0, &amp;p &#x3D; 000000000061fe10, *p &#x3D; 5p &#x3D; 00000000001d17a0 说明：在读者的计算机上，执行结果中的地址很可能与本书不同。 1int* p = new int; 第8行：new int通过操作系统API从堆里申请一个int，即4个字节的存储空间，并返回int*。通过指针赋值，指针p指向这块申请而得的堆内存。通过new操作符从堆里申请一个对象的存储空间的一般语法为： 1对象类型 *指针名 = new 对象类型; 需要注意的是，需要妥善保管new操作符返回的指针，因为这是应用程序“拥有“这块内存的标志，也是应用程序操作这块内存的唯一途径。 12printf(\"i = %d, &amp;i = %p\\n\", i, &amp;i);printf(\"p = %p, &amp;p = %p, *p = %d\\n\", p, &amp;p, *p); 第11 ~ 12行：打印局部变量i的值及地址；打印指针p的值和地址，以及p所指向的整数的值。从执行结果的第1~2行可见，p本身是一个自动变量，地址为0x0061fe10，它存储在栈里，与i紧挨着，i的地址为0x0061fe1c。如果观察p的值，也就是申请的内存块的地址，本例中为0x001d17a0，会发现申请的内存块不在栈中，它应该在堆里。 12delete p;printf(\"p = %p\", p); 第14 ~ 15行：delete p用于释放p指针所指向的内存块。然后将p值按地址格式输出。 使用delete释放内容块有如下注意事项： delete只能用于释放通过new操作符申请的内存块，如果试图用delete释放指向栈对象的地址，会发生错误。 new操作符申请的内存块必须通过delete操作符进行释放，如果忘记释放，则在该应用程序退出前，操作系统会一直认为该块内存处于占用状态，无法将其用作其他用途。这种情况称之为内存泄漏（memory leakage）。 不能对同一块内存进行两次delete操作，其结果是不确定的。 delete一个空指针是安全而又无用的，什么都不会发生。 第15行的输出结果告诉我们，delete p会释放p所指向的内存块，但并不会把指针p置为空指针。 要点🎯 当一个非空指针所指向的对象已经事实上被销毁时，该指针也称为悬空指针（dangling pointer）。 一个悬空指针可能会在后续代码中被误用， 为了避免这种情况的发生，作者一般会在项目中定义如下的名为safe_delete的模板函数，来解决这个问题。请见下述C++代码： 1234567891011121314151617//Project - SafeDelete#include &lt;iostream&gt;using namespace std;template &lt;typename T&gt;inline void safe_delete(T&amp; p)&#123; delete p; p = nullptr;&#125;int main()&#123; float* p = new float; cout &lt;&lt; \"before safe_delete: \" &lt;&lt; p &lt;&lt; endl; safe_delete(p); cout &lt;&lt; \"after safe_delete: \" &lt;&lt; p &lt;&lt; endl; return 0;&#125; 上述程序的执行结果为： 12before safe_delete: 0xe917a0after safe_delete: 0 说明：在读者的计算机上，执行结果第1行中的地址很可能与本书不同。 第6 ~ 9行：safe_delete( )函数接收一个指针的引用p，先使用delete p将p所指向的内存块释放，然后将p置为空指针。请注意，safe_delete( )函数的参数为T&amp;，这非常重要，因为该函数需要修改形参所关联的外部对象的值。 1safe_delete(p); 第14行：执行safe_delete( )函数，释放指针p所指向的内存块，并将p置为空指针（nullptr），以避免在后续代码中误用。 结合本行代码中p的类型float*，模板函数safe_delete( )形参p的类型为float*&amp;，即指向float对象的指针的引用。相应地，模板参数T的类型为float*。 执行结果证实，safe_delete(p)执行后，p成功被置为空指针。这种对p的delete更加安全可靠。同时，safe_delete( )函数的inline属性又避免了不必要的函数调用代价。 需要说明的是，上述new int， new float申请的内存块都是未经初始化的，即该int对象，float对象的值不确定。如果希望new出来的对象具有确定的初始值，可以使用下述形式的代码： 123int* a = new int(); //初始化为0float* b = new float(0); //初始化为0double* c = new double(3.3); //初始化为3.3 上述代码中的double(3.3)这种形式，可以认为是执行了double类型的构造函数▲，以3.3为构造函数的参数。 8.2.2 堆对象数组new int可以申请一个int类型的堆对象，如果希望申请100个int类型的堆对象，则应使用下述形式的代码： 1int* a = new int[100]; 本行代码中的new int[100]可按下述方式理解： 通过100 x sizeof(int)得到100个int对象占据400个字节的空间； new操作符通过操作系统API从堆申请400个字节的空间，然后将该空间地址作为int*类型返回。 new操作符返回的指针赋值给a之后，按照第6章的讨论，可以把a指针当数组用。下述C++代码演示了这种用法： 12345678910111213141516171819//Project - NewMany#include &lt;iostream&gt;using namespace std;int main() &#123; int n = 100; int* a = new int[n]; int iSum &#123;0&#125;; for (int i=0;i&lt;100;i++)&#123; a[i] = i+1; iSum += a[i]; &#125; delete []a; //同delete[] a; a = nullptr; cout &lt;&lt; \"sum = \" &lt;&lt; iSum &lt;&lt; endl; return 0;&#125; 上述代码的执行结果为： 1sum &#x3D; 5050 第6 ~ 7行：作者故意引入了变量n来表示需要期望的堆对象的个数。这是为了提醒读者，这个动态数组的元素个数并不需要在写代码的时刻确定，可以在运行时动态确定。 1delete []a; //同delete[] a; 第14行：当指针a所指向的不是一个对象，而是由多个对象所构成的对象数组时，应该在delete与a之间加一个方括号。 警告🚩 当一个指针指向的不是单个动态对象，而是由多个动态对象所构成的数组时，必须使用delete [ ]操作符进行释放。当一个提针指向是单个动态对象时，则必须用delete操作符进行释放。 1a = nullptr; 第15行：同样地，delete [] a执行后，a并不是空指针。此时将a设为空指针以避免后续代码误用。类似地，读者也可以自定义与前一小节相仿的模板函数safe_deletearray(T&amp; p)来实现”安全“的delete [ ]。 同样地，new int[100]所申请的内存是未经初始化的，如果期望申请的动态数组具有确定的初始值0，可以使用下述格式的代码： 123float* a = new float[10](); //全部初始化为0int* b = new int[10](); //全部初始化为0//double* c = new double[20](3.3); //错误，括号内不能带参数 无论是使用C语言的malloc( )、calloc( )，还是C++的new操作符，返回的内存都是由操作系统管理的堆内存。这种形式申请的内存，称为动态分配的内存（dynamic allocated memory），这种内存应该在使用完毕以后尽快通过free( )或者delete、delete[ ]归还给操作系统。忘记归还，就会造成内存泄漏，影响整个计算机的运行甚至引发错误。在本书的后续章节，我们还会讨论一种称之为智能指针▲的对象，它可以有效地避免内存泄漏。 8.3 静态对象自动变量/对象的内存被分配在栈里，其生存周期从定义开始直到作用域结束，由编译器生成代码自动管理。动态对象的内存从堆中申请，其生存周期从new/malloc/calloc开始直至delete/delete[ ]/free操作被执行，由程序员手动管理。 不同于自动对象和动态对象，静态对象的生存周期从程序开始运行起，一直到程序运行结束，且被存储到一块称为“全局静态数据区”的内存空间内。 下述C语言代码定义了三种形式的静态变量/对象： 12345678int iGlobal = 11; //能够在整个应用程序的所有源代码文件中使用static int iThisFileOnly = 22; //只能在本文件中被使用void func()&#123; static int iCounter = 0; //只能在本函数中被使用 iCounter++; printf(\"func called: %d, &amp;iCounter = %p\\n\", iCounter, &amp;iCounter);&#125; 其中，iGlobal定义在任何代码块（block）及函数外之外，它是静态对象的一种。相对于代码块或者函数内部的局部变量，习惯上我们称iGlobal这类变量为全局变量，它能够在整个应用程序的所有源代码文件上被使用。这种能够被外部源代码文件使用的性质，称为外部链接属性▲。 iThisFileOnly也定义在任何代码块及函数之外，但其类型前加了一个static关键字。这种类型的静态对象，只能在本源码文件中被使用。这种只能够被其所属于的源代码文件使用的性质，称为内部链接属性▲。 iCounter定义在函数代码块func( )之内，它既是一个静态对象，也是一个局部变量。作为静态对象，它具有全局生命周期；作为局部变量，它只能在func( )函数内被使用。我们稍后再讨论这种类型静态对象的神奇用处。 所有类型的静态对象，如果在定义时不提供初始值，编译器会主动将其初始化为0。作者强烈建议，即便期望的初始值是0，也应在代码中给静态变量显式地给出初始值0，这样可以提高代码的可读性，避免阅读者疑惑。因为，大多数的代码阅读者，不会记得C/C++标准中关于静态对象默认初始值为0的规定。 静态对象的初始化赋值只会执行一次，即便该初始化赋值的代码位于函数体内。对于上述func( )函数内的static int iCounter = 0，iCounter被赋值为0的操作只会发生一次，这项赋值操作是在程序最初启动时完成的。 下述完整的C语言代码可以更好地帮助读者理解静态对象： 123456789101112131415161718192021222324//Project - StaticObject#include &lt;stdio.h&gt;int iGlobal = 11; //能够在整个应用程序的所有源代码文件中使用static int iThisFileOnly = 22; //只能在本文件中被使用void func()&#123; static int iCounter = 0; //只能在本函数中被使用 iCounter++; printf(\"func called: %d, &amp;iCounter = %p\\n\", iCounter, &amp;iCounter);&#125;int main() &#123; int iLocal = 33; printf(\"&amp;iLocal = %p, iLocal = %d\\n\", &amp;iLocal, iLocal); printf(\"&amp;iGlobal = %p, iGlobal = %d\\n\", &amp;iGlobal, iGlobal); printf(\"&amp;iThisFileOnly = %p, iThisFileOnly = %d\\n\", &amp;iThisFileOnly, iThisFileOnly); for (int i=0;i&lt;5;i++) func(); return 0;&#125; 上述代码的执行结果为： 12345678&amp;iLocal &#x3D; 000000000061FE18, iLocal &#x3D; 33&amp;iGlobal &#x3D; 0000000000403010, iGlobal &#x3D; 11&amp;iThisFileOnly &#x3D; 0000000000403014, iThisFileOnly &#x3D; 22func called: 1, &amp;iCounter &#x3D; 0000000000407030func called: 2, &amp;iCounter &#x3D; 0000000000407030func called: 3, &amp;iCounter &#x3D; 0000000000407030func called: 4, &amp;iCounter &#x3D; 0000000000407030func called: 5, &amp;iCounter &#x3D; 0000000000407030 说明：在读者的计算机上，执行结果中的地址很可能与本书不同。 1int iLocal = 33; 第14行：为对照方便，我们在main( )函数内定义了自动变量iLocal。 1234printf(\"&amp;iLocal = %p, iLocal = %d\\n\", &amp;iLocal, iLocal);printf(\"&amp;iGlobal = %p, iGlobal = %d\\n\", &amp;iGlobal, iGlobal);printf(\"&amp;iThisFileOnly = %p, iThisFileOnly = %d\\n\", &amp;iThisFileOnly, iThisFileOnly); 第15 ~ 18行：输出了自动变量iLocal、具有外部链接属性的静态对象iGlobal、具体内部链接属性的静态对象iThisFileOnly的地址及值。从输出结果可见，自动变量iLocal的地址0x0061FE18与其他静态对象的地址相去甚远，它应该处于”栈“内。同时，静态对象iGlobal的地址0x00403010、iThisFileOnly的地址0x00403014则紧紧相邻，且与func( )函数内的静态对象iCounter的地址0x00407030相去不远，它们都位于全局静态数据区。 12345void func()&#123; static int iCounter = 0; //只能在本函数中被使用 iCounter++; printf(\"func called: %d, &amp;iCounter = %p\\n\", iCounter, &amp;iCounter);&#125; 第7 ~ 11行：函数内的iCounter如果是个普通的局部自动对象，则对于每次的函数调用，该变量都会重新在栈内分配空间且被初始化为0。如果是这样的话，第10行printf( )输出的iCounter值固定为1。 但这里的iCounter是一个静态局部对象，它的空间位于全局静态数据区，且其被赋值为0的初始化仅会被执行一次。这导致了下述两个结论： 对于每次的func( )调用，函数内部操作的iCounter均是同一个对象； iCounter可以在多次函数调用间保存其值。 12for (int i&#x3D;0;i&lt;5;i++) func(); 第20 ~ 21行：循环执行了func( )函数5次。从执行结果可以看见，iCounter成功记录了该函数被调用执行的次数1，2，3，… 下述代码没有使用函数内的局部静态对象，而使用全局变量iCounter来记录func( )函数执行的次数： 12345int iCounter = 0;void func()&#123; iCounter++; ...&#125; 这种实现方式实现了相同的功能，但代码质量要差很多：函数外部的iCounter变量成为func( )函数接口的一部分，这使得该函数的使用和维护都变得更加复杂；同时，全局变量iCounter的内存也”污染“了全局名字空间▲。 此外，除了普通变量外，函数也可以定义为static。下述函数private( )加上static属性之后，其仅被允许在包含它的源代码文件中使用。我们称该函数具有内部链接属性▲。 1static int private(float f)&#123; ... &#125; 按照面向对象程序设计的观点，万物皆对象，函数private( )也是一个对象。 8.4 存储类型说明符static即为存储类型说明符（storage class specifier）之一，它要求编译器将对象存储在全局静态数据区。 在C及C++ 11之前，register说明符（specifier）建议编译器将变量存储在寄存器中： 1register int i = 0; 寄存器是CPU内部超级快速的临时存储器，但数量有限。register说明符仅仅是对编译器的建议，当寄存器资源不足时，编译器会拒绝这种提义，为上述i对象分配普通的内存空间。 12register int i &#x3D; 0;printf(&quot;&amp;i &#x3D; %p, i &#x3D; %d&quot;, &amp;i, i); &#x2F;&#x2F;错误：不可以对register对象取地址 上述代码的第2行在C语言当中是错误的，因为寄存器变量不存在普通意义上的内存地址。 在C++ 11之后，register被弃用，丧失了语法含义。 在C++ 11之前，auto说明符用于表示变量属于自动变量，正如读者理解的那样，这毫无意义。因为如果不加以static等说明符，不加auto的变量也是自动变量。所以，C++ 11之后，auto被用来表示类型推断。 mutable、extern、thread_local【C++ 11】这些存储类型说明符将在本书的后续章节中逐步讨论。 9. 位操作本讲义系重庆大学C/C++课程的教学笔记。 作者： 陈波 chenbo@cqu.edu.cn， All rights reserved. 未经作者许可，不允许经由互联网展示或提供下载。 不允许以纸质出版为目的进行摘抄或改编。 计算机内的数据存储和操作永远是二进制的。称一个占据4字节空间的对象为int，仅仅表明我们以int的形式去理解和操作那32个比特位。从电路层面上，储存一个int的4字节空间与存储一个float的4字节空间没有什么不同，都存储着32个0或者1。 当我们操作一个整数对象，比如给它赋值时，是把其32个比特位当成一个整体操作。有时，特别当我们的程序试图直接跟CPU外部电路打交道时，我们期望能够直接操作一个对象的单个比特位。C语言的位操作可以达成此目的。 9.1 二进制及十六进制假设一个无符号短整数（unsigned short）由2字节共16比特构成，其每个比特的值如图9- 所示。 图9- 二进制示意图 在图9- 中， 16个二进制位来源于连续的两字节存储空间，从低到高依次标为第0位 ~ 第15位，然后每一位都对应位权20 ~ 215。 为了帮助读者理解，作者特意画了十进制的952710的结构作为参照。十进制数952710的值 = 9 x 103 + 5 x 102 + 2 x 101 + 7 x 100。即，十进制数的值等于其每位的位值乘以对应的位权，再求和。 类似地，二进制数的值也等于其每位的位置乘以对应的位权，再求和。本例中，有：$$\\begin{align}0100111110110010_2 &amp;= 0 \\times 2^{15} + 1 \\times 2^{14} + 0 \\times 2^{13} + 0 \\times 2^{12} + 1 \\times 2^{11} + 1 \\times 2^{10} + 1 \\times 2^{9} + 1 \\times 2^8 \\ &amp;+ 1 \\times 2^7 + 0 \\times 2^6 + 1 \\times 2^5 + 1 \\times 2^4 + 0 \\times 2^3 + 0\\times 2^2 +1 \\times 2^1 + 0 \\times 2^0 \\ &amp;= 20402_{10}\\end{align}$$在编程时，如果直接书写二进制字面量是一件痛苦的工作，程序员要非常小心地反复确认那些0和1的数字有没有错漏。相对于二进制，那些长期与电路打交道的电气工程师更愿意使用十六进制。十六进制的每一位，可以表示0 ~ 15共16种组合，由于24恰好等于16，所以每个十六进制位正好对应4个二进制位，其对应关系如表9- 所示。 表9- 十六进制、十进制及二进制对应关系 十六进制 十进制 二进制（4位） 十六进制 十进制 二进制（4位） 0 0 0000 8 8 1000 1 1 0001 9 9 1001 2 2 0010 A 10 1010 3 3 0011 B 11 1011 4 4 0100 C 12 1100 5 5 0101 D 13 1101 6 6 0110 E 14 1110 7 7 0111 F 15 1111 按照表9- ，我们很容易把二进制数换算成对应的十六进制。方法就是从低位往高位方向，将二进制位分为4位一组，然后按表9- 将每一组转成对应的十六进制符号即可。如图9- 所示，本例中的01001111101100102 = 4FB216，按字面量表示为0x4FB2。 图9- 十六进制与二进制的互换 反过来，如果要把十六进制转换成二进制，则需要按表9- 将每个十六进制位转换成4位二进制，然后再串起来即可。 扩展阅读📕 本例中的unsigned short是由两个连续的字节构成的。其中第07位是低位字节，第815位是高位字节。在实际的内存布置中，是高位字节的地址高还是低位字节的地址高，不同的CPU有不同的规定。这个问题就是所谓的大小端（big endian/small endian）问题。【这个问题提示我们，如果没有特殊技术优势，一定要区别人别人，自己独搞一套的都是王八蛋。此句话会删掉的，骂人解压】 需要提醒读者，本章中所讨论的全部按位操作的讨论，均基于无符号整数。对于有符号整数，由于补码的存在，问题要稍显复杂。在实践中，对有符号整数进行按位操作的情况比较少。 9.2 按位取反C语言中的按位（bitwise）操作符都用于整型对象，包括char、short、int、long、long long等。 操作符用于将操作数按位取反（not），即对于每个二进制位，1变0，0变1。下述C++程序演示了操作符的用法： 123456789101112131415//Project - NotOp#include &lt;iostream&gt;#include &lt;bitset&gt;using namespace std;int main()&#123; unsigned char c = 0b01011101; //二进制字面量是C++14引入的，早期版本中请用0x5d代替 unsigned char d = ~c; cout &lt;&lt; \"c = \" &lt;&lt; bitset&lt;8&gt;(c) &lt;&lt; endl; //尖括号中的8是模板参数，意即要把c转为8位二进制字符串 cout &lt;&lt; \"~c = \" &lt;&lt; bitset&lt;8&gt;(d) &lt;&lt; endl; return 0;&#125; 上述程序的执行结果为： 12c &#x3D; 01011101~c &#x3D; 10100010 说明：C语言的printf( )函数不支持把对象按二进制格式输出。为了演示方便，本章中几乎全部使用C++程序来演示，C++标准模板库中的bitset类型可以方便地把对象转换成指定位数的二进制字符串。这些C++示例当中关于位操作的语法，与C语言完全相同。 从上述执行结果可以看到：~（01011101） = 10100010。 9.3 按位与a &amp; b中的&amp;操作符将a对象与b对象的对应二进制位逐一进行按位与（and）运算。当且仅当a与b中的对应二进制位均为1时，结果位为1，否则为0。对于单个比特位的&amp;运算，可以总结其规则如下： 1 &amp; 1 = 1 1 &amp; 0 = 0 0 &amp; 1 = 0 0 &amp; 0 = 0 a &amp; b中的&amp;操作符是按位与操作符，它二元运算符，需要两个操作数。 &amp;b中的&amp;操作符是取地址操作符，它是一元操作符，只需要一个操作数。下述C++程序演示了按位与操作符&amp;的用法： 123456789101112131415161718192021//Project - BitAnd#include &lt;iostream&gt;#include &lt;bitset&gt;using namespace std;int main() &#123; unsigned int a = 0x8ffff37a; unsigned int b = 0xfc7779f6; unsigned int c = a &amp; b; cout &lt;&lt; \"a = \" &lt;&lt; bitset&lt;32&gt;(a) &lt;&lt; endl; //转为32位二进制字符串输出 cout &lt;&lt; \"b = \" &lt;&lt; bitset&lt;32&gt;(b) &lt;&lt; endl; cout &lt;&lt; \"a &amp; b = \" &lt;&lt; bitset&lt;32&gt;(c) &lt;&lt; endl; cout &lt;&lt; \"a = \" &lt;&lt; bitset&lt;32&gt;(a) &lt;&lt; endl; cout &lt;&lt; \"0xfffffff7 = \" &lt;&lt; bitset&lt;32&gt;(0xfffffff7) &lt;&lt; endl; a &amp;= 0xfffffff7; //复合操作符，等价于a = a &amp; 0xfffffff7; cout &lt;&lt; \"a &amp; fffffff7 = \" &lt;&lt; bitset&lt;32&gt;(a) &lt;&lt; endl; return 0;&#125; 上述程序的执行结果为： 123456a &#x3D; 10001111111111111111001101111010b &#x3D; 11111100011101110111100111110110a &amp; b &#x3D; 10001100011101110111000101110010a &#x3D; 100011111111111111110011011110100xfffffff7 &#x3D; 11111111111111111111111111110111a &amp; fffffff7 &#x3D; 10001111111111111111001101110010 执行结果的第1 ~ 3行反应了无符号整数a与b进行按位与运算的结果，请读者仔细逐一检查结果中每一个比特位的值与a，b对应位之间的关系。 1a &amp;= 0xfffffff7; //复合操作符，等价于a = a &amp; 0xfffffff7; 第17行：&amp;=是一个复合操作符，本行等价于a = a &amp; 0xfffffff7。 请读者注意，0xfffffff7是一个很特别的数，在它的32个比特位中，只有第3位为0，其余位全为1。将unsigned int对象a与0xfffffff7进行按位与预算并赋值给a，将导致如下如果： a的第3位将被置为0，不论其第3位本来是0还是1； a的其余位不会发生变化，因为任何值与1做与运算，值不变。 请读者观察执行结果的第4 ~ 6行，检验上述分析是否正确。所以，通过按位与运算，可以达到将对象的特定位”置0“同时又保持其它位不变的目的。 9.4 按位或a | b中的|操作符将a对象与b对象的对应二进制位逐一进行按位或（or）运算。当且仅当a与b中的对应二进制位中有至少一个1时，结果位为1，否则为0。对于单个比特位的|运算，可以总结其规则如下： 1 | 1 = 1 0 | 1 = 1 1 | 0 = 1 0 | 0 = 0 下述C++程序演示了按位或操作符|的使用方法： 123456789101112131415161718192021//Project - BitOr#include &lt;iostream&gt;#include &lt;bitset&gt;using namespace std;int main() &#123; unsigned short a = 0xf37a; unsigned short b = 0x79f6; unsigned short c = a | b; cout &lt;&lt; \"a = \" &lt;&lt; bitset&lt;16&gt;(a) &lt;&lt; endl; //转为16位二进制字符串输出 cout &lt;&lt; \"b = \" &lt;&lt; bitset&lt;16&gt;(b) &lt;&lt; endl; cout &lt;&lt; \"a | b = \" &lt;&lt; bitset&lt;16&gt;(c) &lt;&lt; endl; cout &lt;&lt; \"a = \" &lt;&lt; bitset&lt;16&gt;(a) &lt;&lt; endl; cout &lt;&lt; \"0x0800 = \" &lt;&lt; bitset&lt;16&gt;(0x0800) &lt;&lt; endl; a |= 0x0800; //复合操作符，等价于a = a | 0x0800; cout &lt;&lt; \"a | 0x0800 = \" &lt;&lt; bitset&lt;16&gt;(a) &lt;&lt; endl; return 0;&#125; 上述程序的执行结果为： 123456a &#x3D; 1111001101111010b &#x3D; 0111100111110110a | b &#x3D; 1111101111111110a &#x3D; 11110011011110100x0800 &#x3D; 0000100000000000a | 0x0800 &#x3D; 1111101101111010 执行结果的第1 ~ 3行反应了无符号短整数a与b进行按位或运算的结果，请读者仔细逐一检查结果中每一个比特位的值与a，b对应位之间的关系。 1a |= 0x0800; //复合操作符，等价于a = a | 0x0800; 第17行：|=是一个复合操作符，本行等价于a = a | 0x0800。 请读者注意，0x0800是一个很特别的数，在它的16个比特位中，只有第11位为1，其余位全为0。将unsigned short对象a与0x0800进行按位或预算并赋值给a，将导致如下如果： a的第11位将被置为1，不论其第11位本来是0还是1； a的其余位不会发生变化，因为任何值与0作或运算，值不变。 请读者观察执行结果的第4 ~ 6行，检验上述分析是否正确。所以，通过按位或运算，可以达到将对象的特定位“置1”同时又保持其它位不变的目的。 9.5 按位异或*a ^ b中的^操作符将a对象与b对象的对应二进制位逐一进行按位异或（xor）运算。当且仅当a与b中的对应二进制位不同时，结果位为1，否则为0。对于单个比特位的^运算，可以总结其规则如下： 1 ^ 1 = 0 1 ^ 0 = 1 0 ^ 1 = 1 0 ^ 0 = 0 下述C++程序演示了按位或操作符|的使用方法： 12345678910111213141516//Project - BitXor#include &lt;iostream&gt;#include &lt;bitset&gt;using namespace std;int main() &#123; unsigned char a = 0xb4; unsigned char b = 0x77; unsigned char c = a ^ b; cout &lt;&lt; \"a = \" &lt;&lt; bitset&lt;8&gt;(a) &lt;&lt; endl; cout &lt;&lt; \"b = \" &lt;&lt; bitset&lt;8&gt;(b) &lt;&lt; endl; cout &lt;&lt; \"a ^ b = \" &lt;&lt; bitset&lt;8&gt;(c) &lt;&lt; endl; return 0;&#125; 上述程序的执行结果为： 123a &#x3D; 10110100b &#x3D; 01110111a ^ b &#x3D; 11000011 请读者结合执行结果的每一位对照检查其与操作数a，b对应位之间的关系。类似地，a ^= b中的^=b是个复合操作符，等价于a = a ^ b。 灵活地运用异或运算，也可以达成某些神奇的效果，见下述C++程序： 12345678910111213//Project - BitXor2#include &lt;iostream&gt;#include &lt;bitset&gt;using namespace std;int main()&#123; unsigned char a = 0xaa; unsigned char b = 0xf0; cout &lt;&lt; \"a = \" &lt;&lt; bitset&lt;8&gt;(a) &lt;&lt; endl; cout &lt;&lt; \"b = \" &lt;&lt; bitset&lt;8&gt;(b) &lt;&lt; endl; cout &lt;&lt; \"a^b = \" &lt;&lt; bitset&lt;8&gt;(a^b) &lt;&lt; endl; return 0;&#125; 上述程序的执行结果为： 123a &#x3D; 10101010b &#x3D; 11110000a^b &#x3D; 01011010 如果读者仔细观察执行结果的第3行和第1行，可以发现： b的高4位全是1，a^b的高4位相当于把a的高4位1010取反，得0101； b的低4位全是0，a^b的低4位同a的低4位相同，仍为1010。 客观上，上述程序达到了将a的高4位取反， 而低4位不变的目的。而哪些位取反， 哪些位不变，则由b的二进制值来确定：为1的对应位取反，为0的对应位不变。 9.6 左移位a &lt;&lt; n中的&lt;&lt;称为左移位操作符（left shift operator），它将对象a的二进制位逐次左移n位，超出左端的二进制位丢弃，并用0填充右端空出的位置。下述C++示例演示了&lt;&lt;操作符的用法： 123456789101112//Project - LeftShift#include &lt;iostream&gt;#include &lt;bitset&gt;using namespace std;int main() &#123; unsigned short a = 5; cout &lt;&lt; \"a = \" &lt;&lt; bitset&lt;16&gt;(a) &lt;&lt; \", value = \" &lt;&lt; a &lt;&lt;endl; a = a &lt;&lt; 3; //等价于 a &lt;&lt;= 3; cout &lt;&lt; \"a &lt;&lt; 3 = \" &lt;&lt; bitset&lt;16&gt;(a) &lt;&lt; \", value = \" &lt;&lt; a &lt;&lt; endl; return 0;&#125; 上述程序的执行结果为： 12a &#x3D; 0000000000000101, value &#x3D; 5a &lt;&lt; 3 &#x3D; 0000000000101000, value &#x3D; 40 第9行代码将a左移3位，执行结果显示，在左移三位后，右方空出位全部填充了0。 对于10进制数52310，如果将其左移一位，右方补0，得523010，客观上，左移一位相当于把数字乘以10。同理，在不溢出的前提下，二进制数左移一位，右方补0，客观上相当于把该数乘以2。如果左移n位，则相当于把该数乘以2n。本例中，原值为5的a被左移了3位，相当于乘以23，变为原始的8倍，结果为40。 类似地，a &lt;&lt;= n中的&lt;&lt;=为复合操作符，其等价于a = a &lt;&lt; n。请读者不要把左移位操作符与cout &lt;&lt; “a …”中的&lt;&lt;相混淆，它们具有完全不同的含义和用途。 9.7 右移位a &gt;&gt; n中的&gt;&gt;称为右移位操作符（right shift operator），它将对象a的二进制位逐次右移n位，超出右端的二进制位丢弃。如果a是无符号整数，用0填充左端空位，如果a为有符号整数，填充值取决于具体的机器，可以是0，也可以是符号位。下述C++示例演示了&gt;&gt;操作符的用法： 123456789101112//Project - RightShift#include &lt;iostream&gt;#include &lt;bitset&gt;using namespace std;int main() &#123; unsigned short a = 2368; cout &lt;&lt; \"a = \" &lt;&lt; bitset&lt;16&gt;(a) &lt;&lt; \", value = \" &lt;&lt; a &lt;&lt;endl; a = a &gt;&gt; 5; //等价于 a &gt;&gt;= 5; cout &lt;&lt; \"a &gt;&gt; 5 = \" &lt;&lt; bitset&lt;16&gt;(a) &lt;&lt; \", value = \" &lt;&lt; a &lt;&lt; endl; return 0;&#125; 上述程序的执行结果为： 12a &#x3D; 0000100101000000, value &#x3D; 2368a &gt;&gt; 5 &#x3D; 0000000001001010, value &#x3D; 74 第9行代码将无符号短整数a右移5位，执行结果显示，在右移五位后，左方空出位全部填充了0。 与左移操作相反，在没有损失有效位（即没有1被移出丢弃）的情况下，将无符号整数右移1位，相当于将该数除以2，右移n位，相当于将该数除以2n。本例中，原值为2368的无符号短整数a右移5位，相当于除以25，即32，结果为74。 类似地，a &gt;&gt;= n中的&gt;&gt;=为复合操作符，其等价于a = a &gt;&gt; n。请读者不要把右移位操作符与cin &gt;&gt; a中的&gt;&gt;相混淆，它们具有完全不同的含义和用途。 9.8 置位与复位将整数的指定位“置为1”称为置位（set bit）；将整数的指定位“置为0”称为复位（reset bit）。之前的讨论中，我们已经知道：通过按位与运算，可以达到将对象的特定位“置0”同时又保持其它位不变的目的；通过按位或运算，可以达到将对象的特定位“置1”同时又保持其它位不变的目的。 下述C++程序中的setBit( )及resetBit( )模板函数即是通过按位或及按位与操作实现置位和复位的。 12345678910111213141516171819202122232425262728//Project - SetResetBit#include &lt;iostream&gt;#include &lt;bitset&gt;using namespace std;template &lt;typename T&gt;inline void setBit(T&amp; v, int bit)&#123; v |= (0x01 &lt;&lt; bit);&#125;template &lt;typename T&gt;inline void resetBit(T&amp;v, int bit)&#123; v &amp;= (~(0x01 &lt;&lt; bit));&#125;int main() &#123; unsigned short v = 0xff00; cout &lt;&lt; \"before v = \" &lt;&lt; bitset&lt;16&gt;(v) &lt;&lt; endl; setBit(v,6); setBit(v,0); setBit(v,11); //置0，6，11位为1 resetBit(v,15); resetBit(v,10); //置10，15位为0 cout &lt;&lt; \"after v = \" &lt;&lt; bitset&lt;16&gt;(v) &lt;&lt; endl; return 0;&#125; 上述程序的执行结果为： 12before v &#x3D; 1111111100000000after v &#x3D; 0111101101000001 第６ ~ 9行：setBit(T&amp; v，int bit)将v对象的第bit位置位。 第11 ~ 14行：resetBit(T&amp; v, int bit)将v对象的第bit位复位。 第20 ~ 22行：先后将v的第0、6及11位置位，执行结果可见，置位操作是成功的。同时，在置位前，v的第11位即为1，第11位的置位没有带来任何改变。 第23 ~ 24行：将v的第10、15位复位。执行结果可见，复位操作成功进行。 图9- setBit(v,6)的执行过程 图9- 以setBit(v,6)为例，来说明本程序的置位原理。本例中，程序首先使用0x01 &lt;&lt; 6来构造一个第6位为1，其它位全为0的unsigned short，然后再把这个临时对象与v作按位或运算，将v的第6位置位，其它位则保持不变。 图9- resetBit(v,10)的执行过程 图9- 以resetBit(v,10)为例，来说明本程序的复位原理。本例中，程序首先使用0x01 &lt;&lt; 10来构造一个第10位为1，其它位全为0的unsigned short，然后再按位取反，得到一个第10位为0，其它位全为1的unsigned short。然后，再把这个临时对象与v作按位与运算，将v的第10位复位，其它位则保持不变。 几乎所有CPU都没有提供直接操作单个比特位的机器指令，所以，C/C++语言仅提供了基于单个字节、两个字节、四个字节及八个字节的整体位操作语法。单个比特位的操纵，只能通过上述运算来间接完成。 微实践 - 地铁能够关门了吗？ 图9- 地铁门障碍检测电路简图 地铁上完客，在关门前必须要确认没有人或者物品挡住门口，否则可能会造成人员夹伤或财产损失。图9- 展示了一种用于地铁门障碍物检测的电路： 发光二极管D1装在门的左侧，它在电流驱动下发出不可见的红外光。 光敏三极管D2装在门的右侧，当门口没有障碍物时，D1发出的红外线照射在光敏三极管D2上，其集电极-发射极导通，其集电极信号S0与地导通，电压为低。 当门口有障碍物挡住了D1发射的红外线时，D2的集电极-发射极断开，此时，其集电极信号S0被上拉电阻拉高，电压为高。 S0信号与CPU的端口管脚相连，当有障碍物时，S0电压为高，CPU认为其值为1；当没有障碍物时，S0电压为低，CPU认为其值为0。 假设一列地铁有8节车厢共16扇车门，每扇车门都安装了类似的障碍物检测电路，共了S0 ~ S15共16个传感器信号连接到CPU。现CPU通过输入指令读取了这个端口上的16个传感器信号，并将其存入了一个unsigned short类型的变量。现请通过位操作方法检测有哪几扇门存在障碍物，即对应的比特位为1？ 读者如果看不懂上述检测电路图，并不影响对程序的理解。本程序的实质就是要检测一个unsigned short哪些位为1。作者编写了下述C++代码来实现上述功能。 12345678910111213141516171819202122//Project - SubwayDoor#include &lt;iostream&gt;#include &lt;bitset&gt;using namespace std;void testDoorSensors(unsigned short s, bool r[])&#123; for (int i=0;i&lt;16;i++) r[i] = s &amp; (0x01 &lt;&lt; i);&#125;int main() &#123; unsigned short s = 0x4031; //随意假设的测试值 bool blocked[16]; cout &lt;&lt; \"s = \" &lt;&lt; bitset&lt;16&gt;(s) &lt;&lt; endl; testDoorSensors(s,blocked); for (int i=0;i&lt;16;i++)&#123; if (blocked[i]) cout &lt;&lt; \"Door \" &lt;&lt; i &lt;&lt; \" is blocked.\" &lt;&lt; endl; &#125; return 0;&#125; 上述程序的执行结果为： 12345s &#x3D; 0100000000110001Door 0 is blocked.Door 4 is blocked.Door 5 is blocked.Door 14 is blocked. 第6 ~ 9行：testDoorSensors( )用于检测形参变量s的每一个二进制位，并将结果存入r数组，如果对应的二进制位为1，存入r数组的值为true，否则为false。 1r[i] = s &amp; (0x01 &lt;&lt; i); 第8行：首先通过将0x01左移i位，形成一个仅第i位为1，其余位全为0的unsigned short。然后将这个临时变量与s作按位与运算，如果s的第i位为0，则结果对象的每一位都是0，整个与运算的运果为0，转换成布尔型，为false。如果s的第i位为1，则结果对象中的第i位为1，整个与运算的结果非0，按非零即真原则转换成布尔型，为true。下面以s的第4位的检测过程为例进行解释。 0x01 &lt;&lt; 4，其结果为00000000000100002。 00000000000100002与s变量01000000001100012进行按位与运算，结果为00000000000100002。 该结果00000000000100002按非零即真原则转换成布尔型，结果为true。 1234for (int i=0;i&lt;16;i++)&#123; if (blocked[i]) cout &lt;&lt; \"Door \" &lt;&lt; i &lt;&lt; \" is blocked.\" &lt;&lt; endl;&#125; 第17 ~ 20行：遍历传感器变量s检测的结果数组blocked，如果发现元素值为true，说明该门存在障碍物，将其打印出来。从打印结果看，上述程序成功地检测并报告了s变量的全部值为1的位。 看起来，地铁的控制CPU还需要发出额外的警告声，等几秒后再次检测。 10. 枚举与联合本讲义系重庆大学C/C++课程的教学笔记。 作者： 陈波 chenbo@cqu.edu.cn， All rights reserved. 未经作者许可，不允许经由互联网展示或提供下载。 不允许以纸质出版为目的进行摘抄或改编。 10.1 枚举型对事物进行分类是人类的技能之一。人分男女，大学的学生则又分为专科生、本科生、硕士研究生和博士研究生。与现实世界相对应，在程序当中，我们也常常需要表达对象所属的类别。而枚举类型，则是完成该任务的主要工具。 下述C语言代码定义了一个名为ColorType的枚举（enumeration）类型： 12345//Project - ColorTypeenum ColorType &#123; red, orange, yellow=100, green, blue, violet&#125;; //注意末尾的分号不能少// 0 1 100 101 102 103 对于编译器而言，枚举类型的实质就是整数。上述定义中，编译器会从0开始，给各个枚举项确定对应的整数值。同时，程序也可以给某些枚举项指定值，如本例中的yellow被指定为100。那些在yellow之后的枚举项，则依次被确定100+1，100+2，100+3。上述程序中的第5行注释列出了所有枚举项所对应的整数值。 上述定义之后，在C语言里便可以把enum ColorType当成一个新的数据类型来使用。在C++里，可以直接把ColorType当成数据类型使用，不必加上enum关键字。 1enum ColorType color = blue; 上述代码定义了一个名为color的对象/变量，其类型为enum ColorType，初始值为blue，即整数102。 123color = green;color = 999; //编译器警告：999不在枚举范围内color = 1; //等价于orange 任何ColorType的枚举项都可以赋值给color对象，也可以直接整数值赋值给color对象。当把一个不在ColorType枚举值范围内的整数，比如999赋值给color时，编译器会给出警告。 1color = (enum ColorType)103; //等价于violet 有的编译器可能不喜欢你直接把整数赋值给枚举类型的对象，会给出类型不一致的警告，因为严格地说，上述赋值语句的左边是enum ColorType类型，而103则是整数字面量。此时，可以通过类型转换消除这种警告。 1printf(\"violet = %d\\n\", violet); 所有的枚举项，均可视为整数类型的常量，上述代码的输出值应为103。 12345678910111213141516171819//Project - ColorTypeconst char* getColor(enum ColorType c)&#123; switch (c)&#123; case red: return \"red\"; case orange: return \"orange\"; case yellow: return \"yellow\"; case green: return \"green\"; case blue: return \"blue\"; case violet: return \"violet\"; default: return \"error\"; &#125;&#125; 也可以把枚举类型的对象作为switch分支语句的”整数表达式”。上述getColor( )函数将enum ColorType对象转换成对应的英文字符串。 1printf(\"color = %s\\n\", getColor(green)); 借助于getColor( )函数，上行代码将枚举项green转换成字符串”green”并输出。 在作者的开发环境及编译器下，sizeof(color)及sizeof(enum ColorType)均为4，这说明编译器内部将该枚举类型按4字节整数处理。枚举型对应整数，但到底对应1个字节（unsigned char, char），2个字节（unsigned short, short），还是4个字节的整数（unsigned int, int）则取决于编译器的决定。但可以放心，编译器最终确定的整数类型一定可以容纳所有枚举项对应的整数值。 读者可能会问：既然枚举类型的实质就是整数，那直接用整数0，1，2，3 … 来表示红、橙、黄、绿不就可以了？要枚举型为何用？ 答案是枚举型可以改善程序的可读性，对程序的阅读者而言，red比0更容易理解和记忆。 10.2 typedef语句在编写单片机的C语言程序时，电气工程师特别喜欢清楚地了解每个整数类型的字节数，以及符号特性，即是有符号还是无符号整数。这个目的可以通过typedef语句实现。typedef源自英文type definition。 12345678//Project - TypeDeftypedef unsigned char UINT8; //无符号8位整数 unsigned int of 8 bitstypedef unsigned short UINT16; //无符号16位整数typedef unsigned int UINT32; //无符号32位整数typedef char INT8; //有符号8位整数typedef short INT16; //有符号16位整数typedef int INT32; //有符号32位整数 相对于unsigned char，unsigned short这种类型名称，UINT8，UINT16具有更好的解释性。在上述typedef之后，UINT8、INT32等类型直接与unsigned char，int通用。 123UINT8 b = 0x77; //b的类型实为unsigned charUINT16 s = 0xf900; //s的类型实为unsigned shortINT32 c = 0x1f2f3f4f; //c的类型实为int 如果用sizeof操作符求上述b、s、c对象的字节数，分别应为1，2和4。 在第7章中，我们曾经借助typedef定义了一个名为biggerFunc的函数指针类型： 1typedef bool (*biggerFunc)(const string&amp;, const string&amp;); 上述定义完成后，biggerFunc可以当成数据类型来使用，下述代码定义了类型为biggerFunc的函数指针f： 1biggerFunc f; 借助于typedef，我们也可以简化枚举类型的使用语法。下述代码将一个枚举类型定义为一个名为GenderType的数据类型： 1234//Project - GenderTypetypedef enum &#123; male, female //依次取值0,1&#125; GenderType; 在C语言里，前节中的枚举类型ColorType必须结合enum关键字来使用，而使用typedef定义的GenderType可以直接使用。 12//enum ColorType color = red; //必须结合enum关键字使用GenderType gender = female; //直接当成数据类型使用 10.3 枚举类传统C/C++语言中的枚举类型有个很大的缺点。在下述GenderType枚举类型引入后，male、female做为一个枚举项，被视为整数常量。 123enum GenderType &#123; male, female&#125;; male、female这两个名字处于全局名字空间。male，female是很普通的命名，它们的存在“污染”了名字空间。 【C++ 11】引入了enum class（枚举类），示例如下： 1234//Project - EnumClassenum class GenderType:unsigned char&#123; male,female&#125;; //注意末尾分号不能少 上述代码定义了一个名为GenderType的枚举类（enum class），其有两个枚举项，分别为male和female。基于相似的规则，male和female分别与整数0和1对应。上述定义中，GenderType冒号之后的unsigned char则显式地指定了该枚举类按unsigned char进行存储。如果省略该冒号及其之后的存储类型指示，枚举类的存储格式将由编译器自行确定。 域解析符：”::”称为域解析符。Rocket::Engine可以理解为火箭（Rocket）里的发动机（Engine），以区别于Car::Engine（轿车里的发动机），和Engine（发动机）。 相较于传统的枚举类型，enum class带来诸多益处。首先，其枚举项不再“污染”空字空间，必须通过域解析符::来使用，见下述代码： 12GenderType gender = GenderType::male; //::为域解析符//gender = male; //错误: male不在全局名字空间内 作为一个整体，GenderType::male具有更好的自解释性且不容易意外导致重名。 此外，不同于传统枚举型，enum class不允许其枚举项与整数之间的隐式类型转换，但显式类型转换是允许的。这种更严格的类型要求可以减少因为疏忽而导致的软件缺陷。 123//gender = 1; //错误：不允许进行整数与enum class之间的隐式类型转换gender = GenderType(0); //显式类型转换 整数 -&gt; 枚举项int i = int(GenderType::female); //显式类型转换 枚举项 -&gt; 整数 如果对上述gender对象应用sizeof操作符，返回的字节数应为1，因为GenderType的定义过程中指定了背后的存储类型：unsigned char。 10.4 联合C语言中的联合（union）类型为我们提供了操纵和解读“数据”的独特方式，它允许对同一块内存以不同的方式进行解读和操纵。 1234union UINT &#123; unsigned int intValue; //占4个字节 unsigned char bytes[4]; //占4个字节&#125;; //注意末尾分号不能少 上述代码定义了一个名为UINT的联合类型。该类型提供了两个成员，分别是unsigned int类型的intValue，以及元素类型unsigned char的长度为4的字符数组bytes。这两个成员的内存空间是共享的，即，一个union UNIT类型的对象只占4个字节的空间。当以成员intValue进行操作时，这4个字节的内存被当成一个unsigned int进行操纵和解读；当以成员bytes进行操作时，这4个字节的内存被当成一个4字节的字符数组进行操纵和解读。 我们通过下述C语言程序来解释联合类型的使用方法： 1234567891011121314151617181920212223//Project - UnionExample#include &lt;stdio.h&gt;union UINT &#123; unsigned int intValue; //占4个字节 unsigned char bytes[4]; //占4个字节&#125;; //注意末尾分号不能少int main() &#123; union UINT v = &#123;.intValue=0x11223344&#125;; printf(\"&amp;v = %p, &amp;v.intValue = %p, v.bytes = %p\\n\", &amp;v, &amp;v.intValue, v.bytes); printf(\"v.bytes[0..3] = 0x%x 0x%x 0x%x 0x%x\\n\", v.bytes[0], v.bytes[1], v.bytes[2], v.bytes[3]); v.bytes[0] = 0x55; v.bytes[1] = 0x66; v.bytes[2] = 0x77; v.bytes[3] = 0x88; printf(\"v.intValue = 0x%x\\n\",v.intValue); printf(\"sizeof(v) = %lld\",sizeof(v)); return 0;&#125; 上述程序的执行结果为： 1234&amp;v &#x3D; 000000000061FE1C, &amp;v.intValue &#x3D; 000000000061FE1C, v.bytes &#x3D; 000000000061FE1Cv.bytes[0..3] &#x3D; 0x44 0x33 0x22 0x11v.intValue &#x3D; 0x88776655sizeof(v) &#x3D; 4 说明：在读者的计算机上，执行结果中的地址很可能与本书不同。 要点🎯 “.”被称为成员操作符，a.b意为对象a的b成员。 1union UINT v = &#123;.intValue=0x11223344&#125;; 第10行：C语言中，union UINT作为一个整体，代表名为UNIT的联合类型。在C++语言中，使用UINT类型时，前面的union关键字可以省略。此处的v是一个对象，其类型为union UINT。因为联合对象的多个成员是内存共享的，所以v的初始值必须以{ }包裹起来，.intValue指明了v初始化的实际动作是把0x11223344赋值给v的intValue成员。作者在这里故意使用了十六进制，因为十六进制每位占4个比特，每两位占1个字节。v定义并初始化以后，其内存结构可以用图10- 表示。 图10- 联合对象v的内存结构 如图10- 所示，v占据了地址为0x0061FE1C、0x0061FE1D、0x0061FE1E和0x0061FE1F的连续4个字节的存储空间。v的所谓数据成员，无非这4字节内存的不同视图（view）而已。从v.intValue的角度看，这是一个地址为0x0061FE1C的32位无符号整数；从v.bytes的角度看，这是一个从地址0x0061FE1C开始的4个元素的字符数组。 读者可能注意到，图10- 中，4个字节从低地址往高地址方向读，依次是0x44、0x33、0x22和0x11，其顺序与作为无符号整数的v.intValue的值正好相反。这是因为，Intel的x86系列CPU执行Big Endian的字节顺序，高位字节(0x11)存高地址（0x0061FE1F）。 12printf(\"&amp;v = %p, &amp;v.intValue = %p, v.bytes = %p\\n\", &amp;v, &amp;v.intValue, v.bytes); 第12 ~ 13行：依次打印v的地址，v.intValue的地址，v.bytes的地址（数组名即为地址）。从执行结果的第1行可见，3个地址值相同。这证实，联合对象v的不同成员间是共享内存的。此处的v.intValue应用了”.”操作符，读者可以形象的将其理解为“v对象的intValue”。 12printf(\"v.bytes[0..3] = 0x%x 0x%x 0x%x 0x%x\\n\", v.bytes[0], v.bytes[1], v.bytes[2], v.bytes[3]); 第15 ~ 16行：依次打印v.bytes的4个元素。这相当于从v.bytes的角度去解释v.intValue的数据。执行结果的第2行证实，v.intValue最高位字节的0x11存在了v.bytes[3]里。如刚才所述，这是Big Endian的字节顺序导致的。 12v.bytes[0] = 0x55; v.bytes[1] = 0x66; v.bytes[2] = 0x77; v.bytes[3] = 0x88;printf(\"v.intValue = 0x%x\\n\",v.intValue); 第18 ~ 19行：对v.bytes成员进行赋值，然后再以v.intValue成员解释数据。执行结果的第3行证实，对v.bytes的修改即是对v.intValue的修改。 1printf(\"sizeof(v) = %lld\",sizeof(v)); 第21行：打印sizeof(v)，执行结果证实，联合对象v占4个字节的空间。 请阅读下述C语言程序： 1234567891011121314151617181920212223//Project - MoreUnion#include &lt;stdio.h&gt;union UMore &#123; double dValue; //全部8个字节 char cValue; //8个字节中的前1个字节 int iValue; //8个字节中的前4个字节&#125;;int main() &#123; printf(\"sizeof(union UMore) = %d\\n\", sizeof(union UMore)); union UMore v = &#123;33.22&#125;; //未指定初始化成员时默认赋值给第0个成员dValue printf(\"v.dValue = %f\\n\",v.dValue); printf(\"&amp;v.dValue = %p, &amp;v.cValue = %p, &amp;v.iValue = %p\\n\", &amp;v.dValue, &amp;v.cValue, &amp;v.iValue); union UMore* p = &amp;v; printf(\"p-&gt;iValue = %d\", p-&gt;iValue); return 0;&#125; 上述代码的执行结果为： 1234sizeof(union UMore) &#x3D; 8v.dValue &#x3D; 33.220000&amp;v.dValue &#x3D; 000000000061FE10, &amp;v.cValue &#x3D; 000000000061FE10, &amp;v.iValue &#x3D; 000000000061FE10p-&gt;iValue &#x3D; -171798692 说明：在读者的计算机上，执行结果中的地址很可能与本书不同。 要点🎯 指向操作符：”-&gt;”称为指向操作符，如果p是一个指针，p-&gt;a表示p所指向的对象的a成员。p-&gt;a与(*p).a等价。 上述程序中，联合类型UMore的三个成员分别占据8个、1个及4个字节的空间。从执行结果看，UMore类型的联合对象v占据8个字节的空间，正好是各成员空间尺寸的最大值。同时，还应注意到v的三个成员的地址相同。这意味着，当我们操作v.cValue时，仅会影响v的第0个字节，其余7个字节不受影响。 12union UMore v = &#123;33.22&#125;; //未指定初始化成员时默认赋值给第0个成员dValueprintf(\"v.dValue = %f\\n\",v.dValue); 第13 ~ 14行：需要说明，当联合对象初始化时，如果没有指明初始化成员，则会默认初始化第1个成员。执行结果的第2行证实，v.dValue被初始化为33.22。 12printf(\"&amp;v.dValue = %p, &amp;v.cValue = %p, &amp;v.iValue = %p\\n\", &amp;v.dValue, &amp;v.cValue, &amp;v.iValue); 第16 ~ 17行：打印v的dValue、cValue及iValue成员的地址。执行结果证实，三者的地址相同。 12union UMore* p = &amp;v;printf(\"p-&gt;iValue = %d\", p-&gt;iValue); 第19 ~ 20行：定义了一个指向v的指针p。p-&gt;iValue表示指针p所指向的联合对象的iValue成员。从执行结果可见，将8个字节double数据的前4个字节当成int来解读，结果是“莫名其妙”的。 11. 结构本讲义系重庆大学C/C++课程的教学笔记。 作者： 陈波 chenbo@cqu.edu.cn， All rights reserved. 未经作者许可，不允许经由互联网展示或提供下载。 不允许以纸质出版为目的进行摘抄或改编。 朵拉同学家里运营着一家工厂，她希望编写一个程序来管理员工档案。考虑到每个雇员都有姓名、ID、性别、月薪等信息，她组织了如下的数据结构来存储雇员信息。 12345678typedef enum &#123; male = 0, female = 1&#125; GenderType;char idEmployees[1000][30]; //身份证号字符串数组char nameEmployees[1000][256]; //姓名字符串数组int salaryEmployees[1000]; //月薪字符串数组GenderType genderEmployees[1000]; //性别数组 在上述数据结构中，朵拉在内存中开辟了1000个员工档案的存储空间，其中，第i个员工的身份证号储存在idEmployees数组的下标i处，月薪存储在genderEmployees数组的下标i处 … 这种数据结构主要有两个缺点： 数组的元素个数是固定的，当员工数量显著少于1000时，内存浪费，员工数量超过1000时，溢出。这个问题需要通过本书后半部分介绍的容器类▲来解决。 同一个员工的信息分散在不同的数组里，使用不便。这个问题可以通过C语言的结构（struct）类型来解决。 11.1 结构定义下述C语言程序定义并使用了一个名为Employee的结构类型： 123456789101112131415161718192021222324252627//Project - EmployeeStruct#include &lt;stdio.h&gt;#include &lt;stdbool.h&gt;typedef enum &#123; male = 0, female = 1&#125; GenderType;struct Employee &#123; char sName[10]; //姓名 bool bRetired; //是否已退休 int iSalary; //月薪 GenderType gender; //性别&#125;; //注意末尾分号不能少int main() &#123; struct Employee e = &#123;.sName = \"Jack Ma\", .iSalary = 9000, .gender = male, .bRetired = false&#125;; printf(\"&amp;e = %p, size = %lld\\n\", &amp;e, sizeof(e)); printf(\"e.sName = %p, size = %lld\\n\", e.sName, sizeof(e.sName)); printf(\"&amp;e.bRetired = %p, size = %lld\\n\", &amp;e.bRetired, sizeof(e.bRetired)); printf(\"&amp;e.iSalary = %p, size = %lld\\n\", &amp;e.iSalary, sizeof(e.iSalary)); printf(\"&amp;e.gender = %p, size = %lld\\n\", &amp;e.gender, sizeof(e.gender)); return 0;&#125; 上述程序的执行结果为： 12345&amp;e &#x3D; 000000000061FE00, size &#x3D; 20e.sName &#x3D; 000000000061FE00, size &#x3D; 10&amp;e.bRetired &#x3D; 000000000061FE0A, size &#x3D; 1&amp;e.iSalary &#x3D; 000000000061FE0C, size &#x3D; 4&amp;e.gender &#x3D; 000000000061FE10, size &#x3D; 4 说明：在读者的计算机上，执行结果中的地址很可能与本书不同。 123456struct Employee &#123; char sName[10]; //姓名 bool bRetired; //是否已退休 int iSalary; //月薪 GenderType gender; //性别&#125;; //注意末尾分号不能少 第9 ~ 14行：定义了一个名为Employee的结构（struct），它有4个数据成员（data member），这4个数据成员分别负责记录一个雇员的姓名、是否已退休、月薪及性别信息。 在上述定义之后，在C语言中，struct Employee便可以当成一个数据类型来使用。从面向对象程序设计的角度看，struct Employee类型与int、float、char一样，都是数据类型，区别在于，后3个是语言原生的，struct Employee是程序员通过编程“介绍”给编译器的。 类似地，可以通过typedef定义一个名为Employee的数据类型，避免每次使用都必须带上struct关键字的烦恼： 123456typedef struct &#123; char sName[10]; //姓名 bool bRetired; //是否已退休 int iSalary; //月薪 GenderType gender; //性别&#125; Employee; 12struct Employee e = &#123;.sName = \"Jack Ma\", .iSalary = 9000, .gender = male, .bRetired = false&#125;; 第17 ~ 18行：定义了一名类型为struct Employee的对象e，并对其进行了初始化。与联合对象类似，其初始化值必须包裹在{ }之中。本例中，通过”.”操作符分别给各成员赋值。 1struct Employee e = &#123;\"Jack Ma\",false,9000,male&#125;; //各成员初始值必须按顺序提供 如该行代码所示：当{ }内的成员值按结构内成员定义顺序给出时，{ }内的成员名称可以省略。 12345printf(\"&amp;e = %p, size = %lld\\n\", &amp;e, sizeof(e));printf(\"e.sName = %p, size = %lld\\n\", e.sName, sizeof(e.sName));printf(\"&amp;e.bRetired = %p, size = %lld\\n\", &amp;e.bRetired, sizeof(e.bRetired));printf(\"&amp;e.iSalary = %p, size = %lld\\n\", &amp;e.iSalary, sizeof(e.iSalary));printf(\"&amp;e.gender = %p, size = %lld\\n\", &amp;e.gender, sizeof(e.gender)); 第20 ~ 24行：分别打印e、e.sName、e.bRetired、e.iSalary和e.gender的地址及字节数。与联合类型不同，结构的不同成员之间并不共享内存，它们是同一块内存的不同组成部分，相互之间是独立的。根据执行结果，我们画出了结构对象e的内存结构，如图11- 所示。 图11- 结构对象e的内存结构 如图11- 所示，结构对象e占20个字节的空间，其数据成员按定义顺序依次排列在这20个字节的空间内。其中： e.sName类型为char[ ]，占10个字节； e.bRetired类型为bool，占1个字节，编译器出于数据对齐▲的原因，在该成员后安排了1个字节的空白区域； e.iSalary类型int，占4个字节； e.gender类型为GenderType枚举型，占4个字节。 11.2 结构对象在完成定义之后，结构类型在理论上与其他数据类型，比如int没有什么不同。下述C语言代码进一步展示了结构类型对象的使用方法： 12345678910111213141516171819202122232425262728293031323334//Project - EmployeeInfo#include &lt;stdio.h&gt;#include &lt;stdbool.h&gt;typedef enum &#123; male = 0, female = 1&#125; GenderType;typedef struct &#123; char sName[10]; //姓名 bool bRetired; //是否已退休 int iSalary; //月薪 GenderType gender; //性别&#125; Employee;void printEmployee(const Employee* p)&#123; printf(\"------Employee Information--------\\n\"); printf(\"Name: \\t%s\\n\",p-&gt;sName); printf(\"Retired:\\t%s\\n\",p-&gt;bRetired?\"Yes\":\"No\"); printf(\"Salary: \\t%d\\n\",p-&gt;iSalary); printf(\"Gender: \\t%s\\n\",p-&gt;gender==male?\"MALE\":\"FEMALE\");&#125;int main() &#123; Employee e = &#123;\"Jack Ma\", false, 9000, male&#125;; e.iSalary += 1000; Employee* p = &amp;e; p-&gt;bRetired = true; (*p).bRetired = false; printEmployee(p); return 0;&#125; 上述程序的执行结果为： 12345------Employee Information--------Name: Jack MaRetired: NoSalary: 10000Gender: MALE 第25 ~ 26行：定义并初始化了一个名为e的Employee类型对象。第26行通过”.”操作符访问e的iSalary成员。 12Employee* p = &amp;e;p-&gt;bRetired = true; 第28 ~ 29行：定义了一个指向Employee结构的指针p。当通过指针p访问结构成员时，通过”-&gt;”操作符实现。p-&gt;bRetired表示p所指向的Employee类型结构对象的bRetired成员。 1(*p).bRetired = false; 第30行：对p应用间接操作符*之后，(*p)即表示p所指向的结构对象，此处为e。然后再对e应用”.”操作符，访问该结构对象的bRetired成员。这种访问方法跟p-&gt;bRetired等效。 1printEmployee(p); 第32行：将结构对象e的指针传递给printEmployee( )函数，该函数负责打印参数指针所指向的“雇员”信息。 1234567void printEmployee(const Employee* p)&#123; printf(\"------Employee Information--------\\n\"); printf(\"Name: \\t%s\\n\",p-&gt;sName); printf(\"Retired:\\t%s\\n\",p-&gt;bRetired?\"Yes\":\"No\"); printf(\"Salary: \\t%d\\n\",p-&gt;iSalary); printf(\"Gender: \\t%s\\n\",p-&gt;gender==male?\"MALE\":\"FEMALE\");&#125; 第16 ~ 22行：printEmployee( )函数用于打印雇员信息。请读者注意形参e的类型为const Employee*，即指向常量Employee对象的指针。这个形参定义带来了三项益处。 避免直接对Employee对象e进行传值。直接传值将“创建”一个e的复制品，该传值的代价为20个字节。而传递指针，无论对象本身有多大，指针的尺寸是固定的4字节（32位编译器）或者8字节（64位编译器）。 避免在函数内意外修改p所指向的对象。按照printEmployee( )函数的预期用途，这种”名不副实“的修改极其有害。 让printEmployee( )函数的使用者放心地将对象的指针传递给该函数使用。因为该函数”声称“不会修改参数指针指向的对象。 当然，在C++里，我们更倾向于使用常量型的引用，而不是指针。 123Employee e = &#123;\"Jack Ma\", false, 9000, male&#125;;Employee f;f = e; //e，f类型相同 C语言允许在同类型结构对象间进行整体赋值，上述代码的第3行将e完整地复制到f。 12345float computeTax(Employee obj)&#123; //用于计算员工的个税 ...&#125;computeTax(e); 上述computeTax( )函数的形参obj将导致传值（call by value）行为的发生。computeTax(e)将实参e复制传递给形参obj，本例中的代价为20个字节。 11.3 复合字面量复合字面量（compound literals），顾名思义，是由多个普通字面量组合而得。如果需要一个临时的结构对象，复合字面量很好用。下述C语言代码演示了复合字面量的相关用法： 123456789101112131415161718192021222324252627//Project - CompoundLiteral#include &lt;stdio.h&gt;#include &lt;stdbool.h&gt;typedef struct &#123; float width; float height;&#125; Rect; //表示一个矩形的结构体float computeArea1(Rect r)&#123; //矩形面积计算函数1 return r.width * r.height;&#125;float computeArea2(const Rect* r)&#123; //矩形面积计算函数2 return r-&gt;width * r-&gt;height;&#125;int main() &#123; Rect r; r = (Rect)&#123;15,10&#125;; //复合字面量 float fArea1 = computeArea1((Rect)&#123;3,2&#125;); //生成临时对象并传值 float fArea2 = computeArea2(&amp;(Rect)&#123;3,2&#125;); //对临时对象取地址 printf(\"fArea1 = %f, fArea2 = %f\\n\", fArea1, fArea2); return 0;&#125; 上述代码的执行结果为： 1fArea1 &#x3D; 6.000000, fArea2 &#x3D; 6.000000 1r = (Rect)&#123;15,10&#125;; //复合字面量 第20行：(Rect){15,10}即为一个Rect类型的复合字面量，注意类似于显式类型转换语法的(Rect)部分在这里是不可或缺的。该行创建了一个Rect类型的临时对象，然后把它赋值给r。 1float fArea1 = computeArea1((Rect)&#123;3,2&#125;); //生成临时对象并传值 第22行：使用复合字面量做为函数的实际参数。 1float fArea2 = computeArea2(&amp;(Rect)&#123;3,2&#125;); //对临时对象取地址 第23行：对复合字面量临时对象取地址，传地址调用函数。 11.4 结构对象数组对于编译器而言， 下述两个数组本质相同： 12struct Employee a[3];int b[3]; a，b都是3个元素的数组，其数组名均为数组首元素的地址。唯一的区别是，a中的元素类型为struct Employee，b的元素类型则为int。 下述C语言程序演示了结构对象数组的使用语法： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;typedef enum &#123; male = 0, female = 1&#125; GenderType;typedef struct &#123; char sName[20]; //姓名 int iSalary; //月薪 GenderType gender; //性别&#125; Employee;int main() &#123; Employee es0[3] = &#123; //3个数组元素初始化，提供3个复合字面量 &#123;\"Jack Ma\", 9000, male&#125;, &#123;\"Dorothy Henry\", 5000, female&#125;, &#123;\"Frank Bush\", 6000, male&#125; &#125;; Employee* es1 = (Employee*)calloc(3,sizeof(Employee)); for (int i=0;i&lt;3;i++) es1[i] = es0[i]; es0[1].iSalary += 200; //es0[1]指Dorothy //es0.iSalary[1] += 200; //错误语法 Employee* p = es1; p++; //p向右滑动一个对象，指向es1[1]，即Dorothy p-&gt;iSalary += 200; //修改的是es1[1]，即Dorothy的Salary printf(\"Name: %s, Salary: %d\\n\", es0[1].sName,es0[1].iSalary); printf(\"Name: %s, Salary: %d\\n\", es1[1].sName,es1[1].iSalary); free(es1); //释放calloc取得的动态内存空间 return 0;&#125; 上述程序的执行结果为： 12Name: Dorothy Henry, Salary: 5200Name: Dorothy Henry, Salary: 5200 12345Employee es0[3] = &#123; //3个数组元素初始化，提供3个复合字面量 &#123;\"Jack Ma\", 9000, male&#125;, &#123;\"Dorothy Henry\", 5000, female&#125;, &#123;\"Frank Bush\", 6000, male&#125;&#125;; 第16 ~ 20行：定义并初始化了包含3个Employee结构类型元素的数组es0。由于元素是结构对象，所以提供初始始的{ }内包含了3个复合字面量。请注意Employee是经由typedef定义的结构类型，在使用时可以省略前边的struct关键字。es0数组属于自动变量，其内存分配在栈里，生命周期由编译器负责管理。 1Employee* es1 = (Employee*)calloc(3,sizeof(Employee)); 第22行：通过calloc( )函数在堆里申请了3个sizeof(Employee)的空间，然后赋值给指针es1。根据第6章中的讨论，指向Employee对象的指针es1，可以当成数组名使用。 12for (int i=0;i&lt;3;i++) es1[i] = es0[i]; 第23 ~ 24行：通过循环，把数组es0中的三个结构体对象赋值给es1“数组”。 12es0[1].iSalary += 200; //es0[1]指Dorothy//es0.iSalary[1] += 200; //错误语法 第26 ~ 27行：es0是包含Employee对象的数组的数组名，es0[1]即为该数组下标为1的元素，它是一个结构体对象。es0[1].iSalary即为该结构对象的iSalary成员，本例中，指Dorothy的Salary。 123Employee* p = es1;p++; //p向右滑动一个对象，指向es1[1]，即Dorothyp-&gt;iSalary += 200; //修改的是es1[1]，即Dorothy的Salary 第29 ~ 31行：按第6章指针运算部分的讨论，p++并不是把p的值（地址）加1，而是增加一个sizeof(Employee)。p++执行后，p事实上指向es1”数组“的下标1的元素，即Dorothy。p-&gt;iSalary即为p所指向的结构体对象Dorothy的iSalary成员。 12printf(\"Name: %s, Salary: %d\\n\", es0[1].sName,es0[1].iSalary);printf(\"Name: %s, Salary: %d\\n\", es1[1].sName,es1[1].iSalary); 第33 ~ 34行：分别打印es0，es1数组的第1个元素的sName及iSalary。执行结果反应了前述数据修改的成果，Dorothy的工资由5000变成了5200。 1free(es1); //释放calloc取得的动态内存空间 第36行：释放通过calloc( )函数申请的堆空间。请注意，上述程序中，作者为了演示指向Employee的指针运算（p++），有意新增了一个指针变量p，而没有直接对es1++。这很重要，动态内存的地址宜妥善保管，因为它们是内存收回（free, delete）的唯一依据。 11.5 结构的嵌套前述结构体包含了char[ ]、bool、int等各种类型的数据成员。当一个结构的成员类型也是一个结构时，称为结构的嵌套。下述C语言程序演示了一个结构嵌套的示例： 123456789101112131415161718192021222324252627282930//Project - CircleStruct#include &lt;stdio.h&gt;struct Point &#123; //平面上的一个点，(x,y)为坐标 int x; int y;&#125;;typedef struct &#123; struct Point ptCenter; //圆心 float fRadius; //半径&#125; Circle;void horizontalMove(Circle* c, int offset)&#123; c-&gt;ptCenter.x += offset; //圆在水平方向上移动offset&#125;int main() &#123; Circle c = &#123;&#123;0,100&#125;,4.1F&#125;; c.ptCenter = (struct Point)&#123;0,0&#125;; c.ptCenter.y = 0; horizontalMove(&amp;c, -12); printf(\"center = (%d, %d), radius = %f\", c.ptCenter.x, c.ptCenter.y, c.fRadius); return 0;&#125; 上述程序的执行结果为： 1center = (-12, 0), radius = 4.100000 第4 ~ 12行：定义了一个Circle类型的结构，其包含两个成员，分别是圆心ptCenter以及半径fRadius。其中，ptCenter的类型为Point结构，这属于结构嵌套的范畴。 1Circle c = &#123;&#123;0,100&#125;,4.1F&#125;; 第19行：定义并初始化了Circle结构对象c。请注意{ }包裹的初始值的格式，其中，{0,100}部分用于初始化c的ptCenter成员，4.1F用于初始化fRadius成员。 1c.ptCenter = (struct Point)&#123;0,0&#125;; 第21行：c.ptCenter代表c的ptCenter成员，而该成员是Point结构类型的对象，可以直接把一个struct Point类型的复合字面量赋值给它。该赋值完成后，ptCenter的x和y成员都被置为0。 1c.ptCenter.y = 0; 第22行：c.ptCenter.y代表c的ptCenter成员的y成员。 1horizontalMove(&amp;c, -12); 第24行：调用horizontalMove( )函数将c横向移动-12个坐标单位。 123void horizontalMove(Circle* c, int offset)&#123; c-&gt;ptCenter.x += offset; //圆在水平方向上移动offset&#125; 第14 ~ 16行：形参c是一个指针，它指向被移动的Circle对象，offset代表移动偏移量。c-&gt;ptCenter.x代表指针c所指向的结构对象的ptCenter成员的x成员。由于这个函数预期要修改c所指向的圆，因此c的类型定义为Circle*，而不是const Circle*。 12printf(\"center = (%d, %d), radius = %f\", c.ptCenter.x, c.ptCenter.y, c.fRadius); 第26 ~ 27行：打印c的值。从执行结果看，调用horizontalMove( )函数对c的横向移动是成功的，其圆心坐标变成了(-12, 0)。 11.6 柔性数组成员**考虑如下问题： 我们试图定义一个名为Student的结构，这个结构应包括学生的姓名，学生已修课程的数量以及已修课程各科的分数。 实践中，每个学生已修课程的数目是不一样的，这使得我们在定义用于存储分数的结构成员时面临两难的局面： 如果将该数组定义得比较小，会存在某学生所修课程数量较多，存不下的情况。 如果将该数组定义得很大，比如10000，则对于大多数学生而言，内存空间浪费严重。而且， 无论将该数组定义得再大，理论上都存在实际数据超量，存不下的可能。 解决方案之一是把分数数组成员定义为一个指向float的指针，如下述C语言代码所示： 123456789101112131415161718192021222324252627//Project - StudentScores#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct &#123; char sName[20]; //学生姓名 int n; //已修课程数量 float* scores; //指针作为结构成员，分数数组&#125; Student;int main() &#123; Student s = &#123;\"Dorothy Henry\", 4, NULL&#125;; printf(\"sizeof(s) = %lld, sizeof(s.sName) = %lld, \" \"sizeof(s.n) = %lld, sizeof(s.scores) = %lld\\n\", sizeof(s),sizeof(s.sName),sizeof(s.n),sizeof(s.scores)); s.scores = calloc(s.n,sizeof(float)); s.scores[0] = 80; s.scores[1] = 90; s.scores[2] = 90; s.scores[3] = 80; float fSum = 0; for (int i=0;i&lt;s.n;i++) fSum += s.scores[i]; printf(\"Average score of %s: %f\",s.sName,fSum/s.n); free(s.scores); return 0;&#125; 上述程序的执行结果为： 12sizeof(s) &#x3D; 32, sizeof(s.sName) &#x3D; 20, sizeof(s.n) &#x3D; 4, sizeof(s.scores) &#x3D; 8Average score of Dorothy Henry: 85.000000 第5 ~ 9行：定义了Student结构，其包含3个数据成员，分别是20个字节的学生姓名sName，4个字节的已修课程数量n，8个字节的分数”数组“指针scores。其3个成员的字节数相加，等于一个Student对象的尺寸32个字节。 对于Student结构而言，scores跟其它成员一样，只是数据成员，只不过类型特殊，是float*。 1Student s = &#123;\"Dorothy Henry\", 4, NULL&#125;; 第12行：s对象的初始化中，将s.n初始化为4，s.scores初始化为空指针。 1s.scores = calloc(s.n,sizeof(float)); 第17行：s.scores只是一个指针，要往s.scores”数组“里存分数前，需要手动申请需要的内存空间。这行代码为其申请了s.n，即4个float的空间。必要时，如果希望往s.scores“数组”中存入超过4个的分数，可以通过realloc( )函数重新调整其动态内存的大小。 12345s.scores[0] = 80; s.scores[1] = 90; s.scores[2] = 90; s.scores[3] = 80;float fSum = 0;for (int i=0;i&lt;s.n;i++) fSum += s.scores[i];printf(\"Average score of %s: %f\",s.sName,fSum/s.n); 第19 ~ 23行：在分配了内存空间之后，s.scores指针便可以当成”数组“来使用。使用过程中，程序员会注意避免下标越界。这几行代码先把4个分数填入s.scores”数组”，然后再计算平均分并打印出来。 1free(s.scores); 第25行：释放calloc( )申请的动态内存。 这种使用指针成员来管理不定尺寸空间的方法需要程序员手动申请及释放内存，程序会变得比较零散。另外一个解决方案是使用结构的柔性数组成员（flexible array member）。请阅读下述C语言程序： 1234567891011121314151617181920212223242526272829//Project - FlexMember#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct &#123; char sName[20]; //学生姓名 int n; //已修课程数量 float scores[]; //柔性数组成员必须是结构的最后一个成员&#125; Student;int main() &#123; unsigned int nBytes = sizeof(Student) + 4*sizeof(float); Student* s = malloc(nBytes); printf(\"sizeof(*s) = %lld, sizeof(s-&gt;sName) = %lld, \" \"sizeof(s-&gt;n) = %lld, nBytes = %lld\\n\", sizeof(*s),sizeof(s-&gt;sName),sizeof(s-&gt;n), nBytes); printf(\"s = %p, s-&gt;scores = %p\\n\", s, s-&gt;scores); s-&gt;n = 4; s-&gt;scores[0] = 80; s-&gt;scores[1] = 90; s-&gt;scores[2] = 90; s-&gt;scores[3] = 80; float fSum = 0; for (int i=0;i&lt;s-&gt;n;i++) fSum += s-&gt;scores[i]; printf(\"Average score: %f\",fSum/s-&gt;n); free(s); return 0;&#125; 上述程序的执行结果为： 123sizeof(*s) &#x3D; 24, sizeof(s-&gt;sName) &#x3D; 20, sizeof(s-&gt;n) &#x3D; 4, nBytes &#x3D; 40s &#x3D; 0000000000711480, s-&gt;scores &#x3D; 0000000000711498Average score: 85.000000 说明：在读者的计算机上，执行结果中的地址很可能与本书不同。 12345typedef struct &#123; char sName[20]; //学生姓名 int n; //已修课程数量 float scores[]; //柔性数组成员必须是结构的最后一个成员&#125; Student; 第5 ~ 9行：scores数组成员即为Student结构的柔性数组成员。柔性数组成员的定义要满足如下要求。 该成员必须是结构的最后一个成员； 该成员在语法上定义了一个不指定元素数量的“空”数组。 事实上，对于一个Student类型的对象而言， 只有sName及n成员会被分配空间，scores成员是不占空间的。 12unsigned int nBytes = sizeof(Student) + 4*sizeof(float);Student* s = malloc(nBytes); 第12 ~ 13行：现假设我们要存4门课程的分数，通过一个Student的对象大小加上4个float的对象大小得到需要的内存字节数nBytes。然后，通过malloc( )函数分配nBytes的堆空间，并把地址传给指针s。 123printf(\"sizeof(*s) = %lld, sizeof(s-&gt;sName) = %lld, \" \"sizeof(s-&gt;n) = %lld, nBytes = %lld\\n\", sizeof(*s),sizeof(s-&gt;sName),sizeof(s-&gt;n), nBytes); 第14 ~ 16行：通过执行结果可以看到，sName成员占20个字节，n成员占4个字节。虽然我们事实上给s所指向的Student对象申请了nBytes = 40个字节的空间，但在编译器看来，*s，即s所指向的Student对象的大小只有24个字节。 1printf(\"s = %p, s-&gt;scores = %p\\n\", s, s-&gt;scores); 第18行：把s，s-&gt;scores按地址格式输出。根据执行结果，我们可以画出该Student对象的内存结构图11- 。 图11- 带柔性数组成员的Student对象的内存结构 如果把s-&gt;scores的地址值减去s的地址值，差为24 = sizeof(Student)。这说明，结构的柔性数组成员事实上是一个指针，它指向紧随该对象的内存地址，其值恒等于对象地址+sizeof(类型)。换句话说：如果我们实际分配给结构对象的空间大于sizeof(Student)，那么多出来的内存可以通过其柔性数组成员来访问。 12Student s1;printf(\"\\n%p - %p\",&amp;s1,s1.scores); 如果我们直接定义类型为Student的变量s1，编译器会为s1分配sizeof(Student) = 24个字节的空间。但即便如此，s1.scores仍然会等于s1的地址+24。如果我们强行通过s1.scores进行数据访问，事实上访问的是不属于s1对象的空间，这是程序员需要小心避免的。 123456s-&gt;n = 4;s-&gt;scores[0] = 80; s-&gt;scores[1] = 90; s-&gt;scores[2] = 90; s-&gt;scores[3] = 80;float fSum = 0;for (int i=0;i&lt;s-&gt;n;i++) fSum += s-&gt;scores[i];printf(\"Average score: %f\",fSum/s-&gt;n); 第20 ~ 25行：给s的柔性数组成员赋值，然后计算平均分并打印。由于我们确信s-&gt;scores所对应的内存空间属于s指向的结构对象，上述操作是安全的。 1free(s); 第27行：一定不要忘了释放动态分配的内存空间。 请读者注意，将带有柔性数组成员的结构对象赋值给另外一个同类型对象是危险的： 12Student s1;s1 = *s; //*s是存有4个分数的占40个字节空间的结构对象 对于编译器而言，s1和*s都只有sizeof(Student) = 24字节的空间。从*s到s1的赋值，只会拷贝前24个字节。同样的危险也会发生在函数传值时，函数的传值，可以认为是从实际参数到形式参数的赋值。 【？缺： 结构体内带函数指针成员，模仿C++中的类】 12. 编译及构建【？缺】 【？ 危险的宏】 13. 类与抽象在程序设计语言的早期（1990年以前），大多数的程序设计都采用结构化编程：程序中遍布着全局函数、数组以及变量。从1990年代起，面向对象程序设计（Object Oriented Programming） 逐渐成为主流。 面向对象程序设计属于【C++】的内容。从本章开始，除非特别说明，所述内容仅适用于C++。 13.1 面向对象本章只讨论一件事情：如何定义和使用新的数据类型。面向对象程序设计可以在程序设计的过程中模拟人类在现实世界的思维。 说到人本身，人是个概念也是个名词， 我们称“人”是一个类（class），以区别于大象、手机和彗星。具体到程序设计的范畴，类和数据类型（data type）是同义词。 一个具体的人，例如你、我、Mr Lee，是人这个概念的外延，是若干个类型为“人”的具体对象（Object）。我们也称某个具体的对象，例如Mark Zackberg，为“人”这个类型的实例（instance）。在面向对象程序设计语言中，变量（variable）、对象（object）以及实例（instance）这3个术语的含义大致相同。 凡是人类，皆有姓名、性别、血压、肤色、身高、体重等性质，这些性质被称为类型的属性（attribute），有时也称为数据成员（data member）。 人除了具备上述身高、肤色等属性外，还能做很多事情，例如说话（speak）、进食（eat）、思考（think）、走路（walk），这些行为是这个类型的方法（method），也可以称为成员函数（member function）。 在程序设计中，我们通过设计新的类型来刻画某类对象的共性，例如，定义一个新类（Person）。然后将这个类型实例化成一个对象，例如定义一个Person类型的变量a。 a既然属于Person类型，那么a自然就有了姓名、性别这些属性，有了eat、speak、think这些方法。 为了避免把读者搞糊涂，我们专门列了几个表格来总结上述术语。 表13- 类与数据类型的关系 术语 同义术语 举例 类(class) 数据类型(data type) Person（表示人，需要自定义）、 char、int、float 表13- 中，自定义的新类型Person与字符、整数这些系统提供的类型并列。在面向对象程序设计的范畴中，它们都是数据类型，其区别在于，有的是系统自带的，而有的（如Person），需要自定义。 表13- 则总结了对象、属性和方法的各种同义术语。 表13- 对象及其相关术语 术语 同义术语 举例 对象（object） 变量（variable） 实例（instance） Person p1 ， int i = 3， float f {3.14}；这里的p1、i、以及f都是对象，区别仅在于他们所属的类型不同，p1类型是Person，是Person类型的实例（instance），i类型是int，是int类型的实例。 属性(attribute) 数据成员（data member） Person::sName（人的姓名）， Person::iAge（人的年龄）， 数组的长度，浮点数的值 方法（method） 成员函数（member function） Person::speak（人说话），Person::eat（人进食），float(3)（将整数3转换成float对象） 还有一个术语有必要提及，执行一个对象的方法，也称为向这个对象发送一个消息（message）。这正如你为晚归的室友准备了霄夜时，无论是通过语言，或是表情，你肯定会向室友发送消息：收下这碗爱心！ 在本书的后续部分，将频繁使用下述三个操作符，现列表予以解释。 表13- 三个操作符 名称 示例 说明 域解析符 :: Person::sName 表示Person类型的sName成员。 成员运算符 . peter.sName peter对象的sName成员。其中，peter的类型为Person。 指向运算符 -&gt; dora-&gt;sName 指针dora指向的Person对象的sName成员。其中，dora的类型为Person*。 13.2 创建类回到人的案例，我们可以用类图（class diagram）来描述人这个类型的概要，见图13- 。这个类图属于统一建模语言 (Unified Modeling Language)的范畴。我们知道，“人”其实还有很多别的属性和方法，比如头发颜色、思考、走路、开车之类，到底要在程序里描述这个类型的哪些属性和方法，以及描述到什么程度，取决于应用软件的实际需要。在一个图书馆管理系统里，我们需要知道这个人的ID和姓名，他的血压通常不是系统所关心的。在一个医疗档案系统里，我们多半需要记录这个人的血压甚至血压变化的过程及细节。 图13- Person类图 有了这个图纸，我们就可以照图施工，当然，是先画图还是直接施工，决定权在你。下述C++代码定义实现了图13- 所述的Person类型： 123456789101112131415161718192021222324252627282930313233343536//Project - SimplePersonenum class GenderType&#123; male = 0, female = 1&#125;;class Person&#123;public: string sName; //姓名 string sID; //身份证号 GenderType gender = GenderType::male; //性别 int iWeight &#123;50000&#125;; //体重，以克为单位 Person(const string&amp; id = \"N/A\", const string&amp; name = \"N/A\" )&#123; sID = id; sName = name; cout &lt;&lt; \"Person::Person(), sName = \" &lt;&lt; sName &lt;&lt; endl; &#125; void speak()&#123; cout &lt;&lt; \"Person::speak()\" &lt;&lt; endl; cout &lt;&lt; \"I am \" &lt;&lt; sName &lt;&lt;\", Nice to meet you here.\" &lt;&lt; endl; &#125; void eat(int weight)&#123; iWeight += weight; cout &lt;&lt; \"I just ate \" &lt;&lt; weight &lt;&lt; \" gram's food.\" &lt;&lt; endl; &#125; string description()&#123; char buffer[1024]; //注意缓冲区尺寸，当心溢出 sprintf(buffer,\"ID: %s\\nName: %s\\nGender: %s\\nWeight: %d\", sID.c_str(),sName.c_str(), gender==GenderType::male?\"Male\":\"Female\",iWeight); return buffer; &#125;&#125;; //注意末尾的分号不能少 第6行以class开始的代码块定义了一个名为Person的新数据类型。C++里定义一个新类的语法格式大体如下： 123456789class 类名 &#123; 类型 数据成员名称1; ... 类型 数据成员名称n; 返回值类型 成员函数名1(...); ... 返回值类型 成员函数名n(...);&#125;; //注意末尾的分号不能少 1public: 第7行：公有成员▲声明。在该声明之后定义的属性/数据成员和方法/成员函数都是公开的。公有成员的含义我们在14.2节中讨论。 1234string sName; //姓名string sID; //身份证号GenderType gender = GenderType::male; //性别int iWeight &#123;50000&#125;; //体重，以克为单位 第8 ~ 11行：定义了Person类的4个属性/数据成员。 这意味着，一个Person类型的对象由4个分别名为sName、sID、gender和iWeight的子对象构成。其中，gender和iWeight指定了初始值。 12345Person(const string&amp; id = \"N/A\", const string&amp; name = \"N/A\" )&#123; sID = id; sName = name; cout &lt;&lt; \"Person::Person(), sName = \" &lt;&lt; sName &lt;&lt; endl;&#125; 第13 ~ 17行：定义了Person类型的构造函数（constructor）。构造函数是特殊的成员函数。 构造函数的函数名与类型相同； 构造函数声明/定义时返回值类型必须空缺 ； 当程序员没有为类型定义构造函数时，编译器会”内部“为该类生成一个零参数的，什么都不做构造函数； 当创建一个类的对象时，编译器会自动执行构造函数； 类定义中给属性指定的默认值到属性的赋值事实上是在构造函数中执行的。 本例中，该构造函数包含了id（身份证号）及name（姓名）两个带默认值的形参。当创建Person类的对象时，如果不提供对应的实参，id和name将取默认值”N/A”。函数体初始化了对象的4个属性，其中，sID和sName用形参赋值，gender赋值为男性，iWeight赋值为50000，即50Kg。最后，该构造函数还打印输出了一行字符，表明该函数的执行结果。第16行Person::Person( )，表示Person类型的成员函数Person( )。 1234void speak()&#123; cout &lt;&lt; \"Person::speak()\" &lt;&lt; endl; cout &lt;&lt; \"I am \" &lt;&lt; sName &lt;&lt;\", Nice to meet you here.\" &lt;&lt; endl;&#125; 第19 ~ 22行：定义了成员函数speak( )，该函数无形参，无返回值，仅打印两行文字表示其执行结果。 1234void eat(int weight)&#123; iWeight += weight; cout &lt;&lt; \"I just ate \" &lt;&lt; weight &lt;&lt; \" gram's food.\" &lt;&lt; endl;&#125; 第24 ~ 27行：定义了成员函数eat( )，形参weight表示该次进食的重量。作为进食的成果，进食的对象体重增加了weight。最后，函数打印一行文字表示其执行结果。 1234567string description()&#123; char buffer[1024]; //注意缓冲区尺寸，当心溢出 sprintf(buffer,\"ID: %s\\nName: %s\\nGender: %s\\nWeight: %d\", sID.c_str(),sName.c_str(), gender==GenderType::male?\"Male\":\"Female\",iWeight); return buffer;&#125; 第29 ~ 35行：定义了成员函数description( )。该函数返回Person对象的描述性字符串。由于C++的标准模板库没有提供占位符格式化功能，我们这里不得不使用C语言的sprintf( )函数来完成占位符格式化。与printf( )将格式化字符串打印输出不同，第31行的sprintf( )函数将格式化字符串保存在字符数组buffer当中。由于sprintf( )函数并不接受string类型的值，所以我们还需要将string类型的sID及sName通过其成员函数c_str( )转换成const char*，即C风格的字符数组供sprintf( )函数使用。c_str( )是string类型的成员函数，该函数将string对象内部的字符串内容转换成const char*。 在执行sprintf( )函数的过程中，需要保证用于存储结果字符串的字符数组足够大，否则，可能会因为下标超界而破坏其它数据。 第34行将字符数组buffer作为返回值返回。读者可能注意到，buffer的类型为char[ ]，而返回值类型为string，理论上两者类型不一致，应被编译器拒绝。但是，string类型存在一个构造函数，该构造函数可以通过char *（char [ ]）构造出一个string对象。编译器接受了这个选项，通过string类型的构造函数创建了一个临时的string对象，然后返回。当然，直接将第37行改成return string(buffer)，显式地调用string的构造函数将buffer转换成string对象也是可以的。 在【C++ 20】标准里，终于定义了标准模板库的占位符格式化功能。但因为本书写作时，绝大多数的编译器都还不支持C++ 20标准，只能选择忽略。 13.3 创建对象在定义了新的类/数据类型后，就可以通过实例化（instantialize）该类来创建该类对象了。下述C++程序使用了前节中定义的Person类型来构造对象。 123456789101112131415161718192021222324//Project - SimplePerson#include &lt;iostream&gt;using namespace std;...class Person&#123;...&#125;; int main()&#123; Person peter(\"3604020001\", \"Peter Lee\"); peter.eat(100); peter.speak(); cout &lt;&lt; peter.description() &lt;&lt; endl; cout &lt;&lt; \"-----------------------------------------\" &lt;&lt; endl; Person dora; dora.sID = \"3604020002\"; dora.sName = \"Dora Henry\"; dora.speak(); cout &lt;&lt; dora.description() &lt;&lt; endl; return 0;&#125; 上述程序的执行结果为： 12345678910111213141516Person::Person(), sName &#x3D; Peter LeeI just ate 100 gram&#39;s food.Person::speak()I am Peter Lee, Nice to meet you here.ID: 3604020001Name: Peter LeeGender: MaleWeight: 50100-----------------------------------------Person::Person(), sName &#x3D; N&#x2F;APerson::speak()I am Dora Henry, Nice to meet you here.ID: 3604020002Name: Dora HenryGender: MaleWeight: 50000 上述程序的main( )函数中，总共定义并使用了两个Person类型的对象，分别是peter和dora。这两个对象都是自动变量，均存储在栈里。两个对象各自拥有的数据成员分别存储在各自的存储空间之内，互不相关。 12 Person peter(\"3604020001\", \"Peter Lee\");int i(0); 第10行：定义了Person类型的对象peter。在语法上，上述peter对象的定义语法与整数i的定义语法没什么不同。 peter是Person类型的对象，第10行导致Person的构造函数Person::Person( )被执行，以”3604020001”，”Peter Lee”为参数。该构造函数的执行初始化了peter对象的数据成员。并导致了执行结果第1行的输出。 i是int类型的对象，int i(0)在语法上可以理解为以0为参数执行int类型的构造函数，该构造函数的执行初始化了int类型的对象i，将其值设置为0。当然，这只是语法上的解读，事实上对i的初始化只是一次简单的赋值，不会有真实的函数调用发生。 1peter.eat(100); 第11行：执行peter对象的eat( )成员函数，以100为参数。显然，Peter吃东西应该只会导致Peter体重增加，跟Dora没关系，所以，eat( )函数所修改的iWeight数据成员对应的是Peter的iWeight。第11行代码对应执行结果的第2行。 1peter.speak(); 第12行：执行peter对象的speak( )方法。执行结果的第3 ~ 4行显示，说话的是Peter Lee，不是Dora。 1cout &lt;&lt; peter.description() &lt;&lt; endl; 第13行：执行peter的description( )成员函数，并将返回的string对象输出给cout。执行结果的第5 ~ 8行即为对应的输出信息。可以看到，Peter的体重由50000变成了50100，因为在代码的第11行，Peter吃了100克的食物。 1Person dora; 第17行：定义了Person类型的对象dora。本行代码也会调用Person的构造函数Person::Person( )来初始化dora对象，其参取值默认值”N/A”。执行结果的第10行即为构造函数的输出，请注意结果中的姓名为”N/A”。 12dora.sID = \"3604020002\";dora.sName = \"Dora Henry\"; 第18 ~ 19行：对dora对象的sID和sName数据成员进行赋值。因为dora是Person类型的对象，所以dora对象包含Person类型所定义的全部属性。 1dora.speak(); 第20行：执行dora对象的speak( )函数。其输出对应执行结果的第11 ~ 12行，结果显示，说话的是Dora，不是Peter。 1cout &lt;&lt; dora.description() &lt;&lt; endl; 第21行：输出dora对象description( )成员函数返回的字符串，对应执行如果的第13 ~ 16行。请注意，输出的结果当中，Dora的体重仍为50000，因为Dora没有吃（eat）东西。 13.4 内存故事关于对象的数据成员，请读者记住下述两个结论： 每个对象拥有独立的存储空间，存储自己的数据成员。 相同类型的对象所拥有的数据成员，其类型、数量和名称相同。例如，dora和peter都是Person类型的对象，所以他们都有姓名、身份证号、性别、体重等属性。 下述C++程序通过对一个Person对象的解析，来说明一个Person类型的对象是如何由其他子对象来构成，以及这些子对象是如何存储在一个Person对象的内部的。 12345678910111213141516171819202122232425262728293031323334//Project - PersonMemory#include &lt;iostream&gt;#include &lt;stdio.h&gt;using namespace std;...class Person&#123;public: string sName; //姓名 string sID; //身份证号 GenderType gender; //性别 int iWeight; //体重，以克为单位 ...&#125;; //注意末尾的分号不能少int main()&#123; printf(\"sizeof(Person) = sizeof(string) x 2 + sizeof(GenderType) \" \"+ sizeof(int)\\n= %lld x 2 + %lld + %lld \\n= %lld\\n\", sizeof(string),sizeof(GenderType),sizeof(int),sizeof(Person)); Person a(\"3604020001\", \"Peter Lee\"); printf(\"&amp;a = %p, sizeof(a) = %lld\\n\", &amp;a, sizeof(a)); printf(\"&amp;a.sName = %p, sizeof(a.sName) = %lld\\n\", &amp;a.sName, sizeof(a.sName)); printf(\"&amp;a.sID = %p, sizeof(a.sID) = %lld\\n\", &amp;a.sID, sizeof(a.sID)); printf(\"&amp;a.gender = %p, sizeof(a.gender) = %lld\\n\", &amp;a.gender, sizeof(a.gender)); printf(\"&amp;a.iWeight = %p, sizeof(iWeight) = %lld\\n\", &amp;a.iWeight, sizeof(a.iWeight)); return 0;&#125; 上述程序的执行结果为： 123456789sizeof(Person) &#x3D; sizeof(string) x 2 + sizeof(GenderType) + sizeof(int)&#x3D; 32 x 2 + 4 + 4&#x3D; 72Person::Person(), sName &#x3D; Peter Lee&amp;a &#x3D; 000000000062fd60, sizeof(a) &#x3D; 72&amp;a.sName &#x3D; 000000000062fd60, sizeof(a.sName) &#x3D; 32&amp;a.sID &#x3D; 000000000062fd80, sizeof(a.sID) &#x3D; 32&amp;a.gender &#x3D; 000000000062fda0, sizeof(a.gender) &#x3D; 4&amp;a.iWeight &#x3D; 000000000062fda4, sizeof(iWeight) &#x3D; 4 说明：在读者的计算机上，执行结果中的地址很可能与本书不同。此外，不同的编译器下，string类型的大小，GenderType类型的大小也可能与本书不同。 第6 ~ 13行：一个Person类型的对象，依次包含sName、sID、gender及iWeight共4个数据成员，其类型分别为string、string、GenderType和int。 123printf(\"sizeof(Person) = sizeof(string) x 2 + sizeof(GenderType) \" \"+ sizeof(int)\\n= %lld x 2 + %lld + %lld \\n= %lld\\n\", sizeof(string),sizeof(GenderType),sizeof(int),sizeof(Person)); 第16 ~ 18行：打印Person、string、GenderType及int类型的字节数。执行结果的第1 ~ 3行证实，一个Person对象的大小正好等于两个string对象、1个GenderType对象及1个int对象的大小之和。即，对象的尺寸等于构成该对象的全部子对象尺寸之和。 1Person a(\"3604020001\", \"Peter Lee\"); 第20行：定义Person类型的对象a，并调用Person::Person( )对a进行了初始化。 第22 ~ 31行：打印了a的全部数据成员的地址及大小。根据输出结果，我们绘制了对象a的内存结构，见图13- 。 图13- 对象a的内存结构 如图13- 所示，Person类型的对象a占据了从0x0062fd60开始的连续72个字节的空间。由于a属于自动变量，因此，其内存空间位于栈内。a的4个数据成员按定义顺序依次排列在这72个字节的空间内，其中，sName和sID各占32个字节，gender占4个字节，iWeight占4个字节。 如第5章所述，string类型的对象尺寸是固定的（如本例中的32个字节），但却可以存储几乎长度不限的字符串。其秘密在于： string对象内部并不存储实际的字符数组，对象内部所存储的只是用于管理实际字符数组的数据结构，例如指向实际字符数组的指针； string对象将实际的字符数组安排在堆（heap）里，并使用对象内部的指针指向申请的动态内存。此外，string对象还会根据实际存储的字符串的长度来动态调整所占用的堆空间，以避免浪费。 从图13- 可见，a.sName，a.sID的实际字符串事实上并不在对象内部，而是在堆里。在作者的计算机上，sizeof(Person)以及sizeof(a)均为固定的72个字节，不论a.sName以及a.sID所包含的字符串实际有多长。也就是说，使用sizeof操作符获得的对象尺寸不包含对象动态创建的部分。 13.5 隐藏的this指针Dora和Peter都是Person类型的对象，他们的属性各自独立，互不相关。但是，他们的行为却是相似的：无论是Dora，还是Peter，在吃完100克的食物后，体重都会增加100克。 显而易见，为Person类型的各个对象分别存储各种独立的成员函数代码是不必要且严重浪费的。事实上，无论是执行dora.eat( )还是peter.eat( )，执行的都是同一个函数Person::eat( )，程序通过一个秘密传递的this指针来区分吃东西的是Dora还是Peter，或者是其他人。 事实上，类型的每一个成员函数（静态成员函数除外▲），包括构造函数，都包含一个隐藏的名为this的形式参数，这个this参数为指向该类型的指针，用于指明被执行该成员函数的对象。 下述C++程序帮助我们理解this指针的工作机制： 1234567891011121314151617181920212223242526272829303132333435//Project - ThisPerson#include &lt;iostream&gt;using namespace std;class Person&#123;public: string sName; //姓名 int iWeight; //体重，以克为单位 Person()&#123; cout &lt;&lt; \"Person::Person(), this = \" &lt;&lt; this &lt;&lt; endl; this-&gt;sName = \"N/A\"; //sName = \"N/A\"; this-&gt;iWeight = 50000; &#125; void eat(int weight)&#123; cout &lt;&lt; \"Person::eat(), this = \" &lt;&lt; this &lt;&lt; endl; iWeight += weight; //this-&gt;iWeight += weight; &#125;&#125;; //注意末尾的分号不能少int main()&#123; Person tom; Person dora; cout &lt;&lt; \"&amp;tom = \" &lt;&lt; &amp;tom &lt;&lt; \", &amp;dora = \" &lt;&lt; &amp;dora &lt;&lt; endl; tom.sName = \"Tom\"; dora.sName = \"Dora\"; dora.eat(100); cout &lt;&lt; \"Name: \" &lt;&lt; tom.sName &lt;&lt; \", Weight: \" &lt;&lt; tom.iWeight &lt;&lt; endl; cout &lt;&lt; \"Name: \" &lt;&lt; dora.sName &lt;&lt; \", Weight: \" &lt;&lt; dora.iWeight &lt;&lt; endl; return 0;&#125; 上述程序的执行结果为： 123456Person::Person(), this &#x3D; 0x61fde0Person::Person(), this &#x3D; 0x61fdb0&amp;tom &#x3D; 0x61fde0, &amp;dora &#x3D; 0x61fdb0Person::eat(), this &#x3D; 0x61fdb0Name: Tom, Weight: 50000Name: Dora, Weight: 50100 说明：在读者的计算机上，执行结果中的地址很可能与本书不同。 123Person tom;Person dora;cout &lt;&lt; \"&amp;tom = \" &lt;&lt; &amp;tom &lt;&lt; \", &amp;dora = \" &lt;&lt; &amp;dora &lt;&lt; endl; 第24 ~ 26行：定义并构建了两个Person类型的对象，分别是tom和dora；输出两个对象的地址。 事实上，tom和dora对象的构建包含如下过程： 编译器生成的代码为对象分配存储空间，并取得地址；对象的存储空间固定为sizeof(Person)； 执行Person::Person( )构造函数，并将对象存储空间的地址作为this参数“秘密”地传递给构造函数； 构造函数以这个this指针为依据，访问并初始化对象的数据成员。 12345Person()&#123; cout &lt;&lt; \"Person::Person(), this = \" &lt;&lt; this &lt;&lt; endl; this-&gt;sName = \"N/A\"; //sName = \"N/A\"; this-&gt;iWeight = 50000;&#125; 第10 ~ 14行：在Person的构造函数里，第11行将那个秘密的this指针按地址格式输出，第12 ~ 13行则通过this指针初始化对象的数据成员。事实上，在成员函数内对本对象数据成员的访问，总是通过this指针进行的。具体到本例，this-&gt;sName与直接写sName等价，都指当前被构造的对象的sName数据成员。事实上，程序通过对象的地址再加上数据成员在对象内的偏移量来确定数据成员的地址。 本例中，tom的构造函数先执行，其输出对应执行结果的第1行。可以看到，tom构造函数中输出的this指针地址与执行结果第3行里tom对象的地址相同。同理，后执行的dora对象的构造函数中输出的this指针地址与dora对象的地址相同。 12tom.sName = \"Tom\";dora.sName = \"Dora\"; 第28 ~ 29行：修改tom和dora的sName属性。 1dora.eat(100); 第30行：执行dora对象的eat( )方法。同理，eat( )成员函数也有秘密的this指针参数。本行代码事实上指明了要执行eat( )成员函数的对象，即dora。编译器会生成“秘密”代码，取得dora的地址并传递给Person::eat( )函数。读者可以按如下方式理解第30行代码。 1Person::eat(&amp;dora, 100); //示意代码，并非编译器认可的“合法”代码 对于所有Person类型对象的eat( )方法，编译器调用的是同一个函数。该函数的第0个参数是被执行对象的地址，即this指针，第1个参数才是100。 12345void eat(int weight)&#123; cout &lt;&lt; \"Person::eat(), this = \" &lt;&lt; this &lt;&lt; endl; iWeight += weight; //this-&gt;iWeight += weight&#125; 第16 ~ 20行：Person::eat( )函数中，我们也输出了this指针的地址。第18行的iWeight事实上是this-&gt;iWeight的简写形式，程序会自动地通过this指针来确定iWeight数据成员的真实地址并进行操作。执行结果的第4行显示，dora.eat( )函数所输出的this指针的值，就是dora对象的地址。 12cout &lt;&lt; \"Name: \" &lt;&lt; tom.sName &lt;&lt; \", Weight: \" &lt;&lt; tom.iWeight &lt;&lt; endl;cout &lt;&lt; \"Name: \" &lt;&lt; dora.sName &lt;&lt; \", Weight: \" &lt;&lt; dora.iWeight &lt;&lt; endl; 第32 ~ 33行：输出tom和dora的姓名及体重。执行结果的第6行可见，作为吃了100克食物的结果，dora的体重变成了50100，而tom的体重仍为50000。 13.6 析构函数构造函数（constructor）负责初始化新对象，析构函数（destructor）则负责在对象生命周期结束，其内存被释放前做清理（cleanup）工作： 如果对象生命周期内申请了动态内存，尚未释放，可在析构函数中释放； 其他：保存尚未保存的数据；释放除内存之外的其它资源，比如网络连接等。 只要对象被销毁，编译器会主动调用对象的析构函数并提供this指针表明被析构的对象。程序中不必也不能主动执行对象的析构函数。 为了简化程序，突出重点，我们设计了一个称为Fish的类，并为之设计了特殊的构造及析构函数，以便演示对象析构函数的“调用”方法。请阅读下述C++程序： 123456789101112131415161718192021222324252627282930//Project - Fish#include &lt;iostream&gt;using namespace std;class Fish &#123;public: string sName; Fish(const string&amp; name)&#123; sName = name; cout &lt;&lt; \"Fish Constructor called: \" &lt;&lt; sName &lt;&lt; endl; &#125; Fish()&#123; sName = \"N/A\"; cout &lt;&lt; \"Fish Constructor called: \" &lt;&lt; sName &lt;&lt; endl; &#125; ~Fish()&#123; cout &lt;&lt; \"Fish Destructor called: \" &lt;&lt; sName &lt;&lt; endl; //同样存在this指针，sName事实上通过this指针访问 &#125;&#125;;int main() &#123; Fish tom(\"tom\"); Fish dora(\"dora\"); Fish nameless; return 0;&#125; 上述程序的执行结果为： 123456Fish Constructor called: tomFish Constructor called: doraFish Constructor called: N&#x2F;AFish Destructor called: N&#x2F;AFish Destructor called: doraFish Destructor called: tom 上述程序中，Fish类有两个构造函数： 12Fish::Fish(const string&amp; name);Fish::Fish(); 一个有参数，一个零参数。其中，带参数的构造函数用形参name初始化Fish的名称（.sName），零参数构造函数则将Fish的名称初始化为N/A。同名的多个成员函数也是一种函数名重载形式，编译器会根据构建对象时提供的实际参数来选择对应的构造函数并执行之。严格地说，Fish::Fish( )也不是零参数，因为它还有秘密参数this。这两个构造函数都向cout输出了表示构造函数被执行的信息。 1234~Fish()&#123; cout &lt;&lt; \"Fish Destructor called: \" &lt;&lt; sName &lt;&lt; endl; //同样存在this指针，sName事实上通过this指针访问&#125; 第18 ~ 20行：定义了Fish类型的析构函数。 一个类型的析构函数应满足如下要求： 析构函数名为类型名，如本例中的Fish； 构析函数必须为零参数，因为C++并不支持显式地调用执行对象析构函数，当然也不可能向析构函数传递除了this指针之外的其他参数； 析构函数不能有返回值； 每个类型只能有一个析构函数。 本例中，Fish类型的析构函数~Fish( )只是打印了一行表示析构函数被执行的信息。 123Fish tom(\"tom\");Fish dora(\"dora\");Fish nameless; 第25 ~ 27行：顺序构建了tom鱼、dora鱼和无名（nameless）鱼。其中，tom鱼和dora鱼执行的是带参数的构造函数，无名鱼执行的是零参数的构造函数。三次构造函数的输出见执行结果的第1 ~ 3行。 到了main( )函数的结尾，tom、dora和nameless这3个对象的生命周期结束，在收缩栈指针释放这3个对象的内存前，程序会自动调用执行这3个对象的析构函数。按照第8章的讨论，nameless鱼最靠近栈顶，收缩栈顶指针时，理论上，最先释放nameless鱼的内存。所以，nameless鱼的析构函数先被执行，然后是dora鱼和tom鱼。一般地，自动变量的析构顺序与构造顺序相反。见执行结果的第4 ~ 6行。 13.7 动态对象与语言原生的数据类型一样，自定义类型也可以通过new操作符来创建对象。请见下述C++程序： 12345678910111213141516171819202122232425262728293031323334353637383940//Project - NewFish#include &lt;iostream&gt;using namespace std;class Fish &#123;public: string sName; Fish(const string&amp; name)&#123; sName = name; cout &lt;&lt; \"Fish Constructor called: \" &lt;&lt; sName &lt;&lt; endl; &#125; Fish()&#123; sName = \"N/A\"; cout &lt;&lt; \"Fish Constructor called: \" &lt;&lt; sName &lt;&lt; endl; &#125; ~Fish()&#123; cout &lt;&lt; \"Fish Destructor called: \" &lt;&lt; sName &lt;&lt; endl; &#125;&#125;;int main() &#123; Fish tom = Fish(\"tom\"); //等价于Fish tom(\"tom\") Fish* dora = new Fish(\"dora\"); Fish* nameless = new Fish; //new Fish等价于new Fish() cout &lt;&lt; \"---------------------------------\" &lt;&lt; endl; cout &lt;&lt; \"&amp;tom = \" &lt;&lt; &amp;tom &lt;&lt; \", dora = \" &lt;&lt; dora &lt;&lt; \", nameless = \" &lt;&lt; nameless &lt;&lt; endl; cout &lt;&lt; \"3 Fish objects: \" &lt;&lt; tom.sName &lt;&lt; \", \" &lt;&lt; dora-&gt;sName &lt;&lt; \", \" &lt;&lt; nameless-&gt;sName &lt;&lt; endl; cout &lt;&lt; \"---------------------------------\" &lt;&lt; endl; delete dora; delete nameless; return 0;&#125; 上述程序的执行结果为： 12345678910Fish Constructor called: tomFish Constructor called: doraFish Constructor called: N&#x2F;A---------------------------------&amp;tom &#x3D; 0x61fd80, dora &#x3D; 0x1f1790, nameless &#x3D; 0x1f1b003 Fish objects: tom, dora, N&#x2F;A---------------------------------Fish Destructor called: doraFish Destructor called: N&#x2F;AFish Destructor called: tom 1Fish tom = Fish(\"tom\"); //等价于Fish tom(\"tom\") 第24行：构建了栈对象tom。如注释所示，这种写法的实际效果与Fish tom(“tom”)等同。 12Fish* dora = new Fish(\"dora\");Fish* nameless = new Fish; //new Fish等价于new Fish() 第26 ~ 27行：第26行代码的执行过程简述如下。 在栈内为作为自动对象的指针dora分配空间； new操作符通过操作系统API申请sizeof(Fish)大小的堆空间并取得地址； 以上述对象地址为this指针，调用执行构造函数Fish::Fish(const string&amp; name)，初始化该对象； 将对象地址赋值给指针dora。 nameless鱼的构建过程类似，唯一区别在于执行的是零参数的构造函数Fish::Fish( )。三次构造函数的输出请见执行结果的第1 ~ 3行。 1234cout &lt;&lt; \"&amp;tom = \" &lt;&lt; &amp;tom &lt;&lt; \", dora = \" &lt;&lt; dora &lt;&lt; \", nameless = \" &lt;&lt; nameless &lt;&lt; endl;cout &lt;&lt; \"3 Fish objects: \" &lt;&lt; tom.sName &lt;&lt; \", \" &lt;&lt; dora-&gt;sName &lt;&lt; \", \" &lt;&lt; nameless-&gt;sName &lt;&lt; endl; 第30 ~ 33行：输出3个Fish对象的地址及3条鱼的姓名。tom.sName表示tom鱼对象的sName数据成员；dora-&gt;sName表示dora指针指向的鱼对象的sName数据成员。 执行结果的第5行证实，dora鱼和nameless鱼的地址很近，它们都在堆里；tom鱼的地址与dora鱼相去甚远，它在栈里。 12delete dora;delete nameless; 第36 ~ 37行：第36行的执行过程简述如下。 如果dora指针为空，直接返回； 由于dora的类型为Fish*，程序调用执行Fish类型的析构函数Fish::~Fish( )，以dora为this指针，以完成dora鱼对象的清理（cleanup）工作； 通过操作系统API释放dora指向的动态内存。 请注意，第36行执行结束后，dora仍然是一个有值非空的指针。谨慎起见，我们建议程序员随后将其置为空，以免误用。 如果不delete dora，会导致两个后果： 对象的析构函数不会被执行； 内存不会被释放，造成泄漏。 执行结果的第8 ~ 9行证实，因为dora先释放，所以dora鱼的析构输出早于nameless鱼的析构输出。 同样地，自动变量tom的析构与内存回收由编译器生成指令来保证。在输出结果的最后，我们看到了tom鱼的析构输出。 13.8 对象数组与语言原生的数据类型一样，自定义类型也可以创建对象数组。请见下述C++示例： 123456789101112131415161718192021222324252627282930313233//Project - FishArray#include &lt;iostream&gt;using namespace std;class Fish &#123;public: int iNumber; Fish()&#123; static int iCounter = 0; //静态对象可以在函数的多次调用间保存其值 iNumber = iCounter++; cout &lt;&lt; \"Fish Constructor called: \" &lt;&lt; iNumber &lt;&lt; endl; &#125; ~Fish()&#123; cout &lt;&lt; \"Fish Destructor called: \" &lt;&lt; iNumber &lt;&lt; endl; &#125;&#125;;int main() &#123; Fish stackFishes[3]; for (auto&amp; f:stackFishes) cout &lt;&lt; f.iNumber &lt;&lt; \", \"; cout &lt;&lt; \"\\n---------------------------------------\" &lt;&lt; endl; Fish* heapFishes = new Fish[4]; //也可写作new Fish[4]() cout &lt;&lt; heapFishes[0].iNumber &lt;&lt; \", \" &lt;&lt; heapFishes[1].iNumber &lt;&lt; \", \" &lt;&lt; heapFishes[2].iNumber &lt;&lt; \", \" &lt;&lt; heapFishes[3].iNumber &lt;&lt; endl; delete []heapFishes; cout &lt;&lt; \"--------------------------------------\" &lt;&lt; endl; return 0;&#125; 上述程序的执行结果为： 123456789101112131415161718Fish Constructor called: 0Fish Constructor called: 1Fish Constructor called: 20, 1, 2,---------------------------------------Fish Constructor called: 3Fish Constructor called: 4Fish Constructor called: 5Fish Constructor called: 63, 4, 5, 6Fish Destructor called: 6Fish Destructor called: 5Fish Destructor called: 4Fish Destructor called: 3--------------------------------------Fish Destructor called: 2Fish Destructor called: 1Fish Destructor called: 0 第9行：iCounter是位于Fish构造函数之内的静态对象。 iCounter被初始化为0的赋值操作只会进行一次； iCounter的生命周期一直持续在程序运行结束， 它可以在多次函数调用间保持其值； Fish::Fish( )借助于iCounter为每条鱼生成一个递增的编号并存入iNumber属性。 1Fish stackFishes[3]; 第20行：除了类型不同外，本行的语法等同于int a[3]。stackFishes是包含三个元素的栈内数组，其构建过程包含如下步骤。 程序在栈内分配3个sizeof(Fish)大小的空间； 从下标0开始至最后一个元素，从前往后逐一调用Fish类型的构造函数Fish::Fish( )，以元素地址为this指针，初始化每一个元素对象。 执行结果的第1 ~ 3行对应上述构造函数的输出。可以看到，3条鱼的编号依次为0，1，2。 12for (auto&amp; f:stackFishes) cout &lt;&lt; f.iNumber &lt;&lt; \", \"; 第21 ~ 22行：遍历stackFishes数组，打印每条鱼的编号。执行结果的第4行证实，3个数组元素的构造顺序确实是从下标0开始从前往后顺序进行的。请读者注意这里的循环元素f的类型为Fish&amp;，而不是Fish，以避免从数组元素到f的赋值。 1Fish* heapFishes = new Fish[4]; //也可写作new Fish[4]() 第26行：除了类型不同外，本行的代码等同于int* p = new int[4]。heapFishes是包含4个元素的动态（堆）数组，其构建过程包含如下步骤。 在栈内为作为自动对象的指针heapFishes分配空间； new操作符通过操作系统API申请4个sizeof(Fish)大小的堆空间并取得地址； 从下标0开始，从前往后逐一调用执行Fish的构造函数Fish::Fish( )，将元素地址作为this指针，用于初始化动态数组的全部元素； 将堆空间地址，即数组首元素的地址赋值给heapFishes。 执行结果的第6 ~ 9行对应上述4次构造函数执行的输出。从中可见，编号为3，4，5，6的鱼被构建出来。 12cout &lt;&lt; heapFishes[0].iNumber &lt;&lt; \", \" &lt;&lt; heapFishes[1].iNumber &lt;&lt; \", \" &lt;&lt; heapFishes[2].iNumber &lt;&lt; \", \" &lt;&lt; heapFishes[3].iNumber &lt;&lt; endl; 第27 ~ 28行：顺次打印heapFishes数组内元素的iNumber。执行结果的第10行表明，数组中下标为0的鱼最先被构造，数组元素的构造顺序确实是从前往后的。 1delete []heapFishes; 第29行：使用delete [ ] 释放heapFishes动态数组。相关执行过程包含下述步骤。 如果heapFishes为空指针，直接返回； heapFishes的类型为Fish*，程序从后往前依次执行heapFishes动态数组所有元素的析构函数~Fish( )，以元素地址为this指针； 释放heapFishes指针所指向的堆内存。 执行结果的第11 ~ 14行对应heapFishes数组元素的析构。可见，6号鱼，也就是数组的最后一个元素，最先被析构，析构顺序为从后往前。 再次提醒，new与delete，new [ ]与delete [ ]必须配对使用。 扩展阅读📕 delete [ ]如何知道指针所指向的动态数组包含多少个元素？ https://codelearn.club/2020/03/delete/ 执行结果的第16 ~ 18行对应自动对象数组stackFishes的元素析构。可以看到，析构的顺序与构造的顺序相反。 14. 隐藏的实现点完菜后坐下就好，菜一会儿就上来。至于菜是从哪个市场买的，在锅里炒多久，油温多少，我们来操心就好。 — “面向对象”餐厅服务员 14.1 接口与封装封装（encapsulation）也是面向对象程序设计的一个重要概念。作者在下面写了一段不完整、不能执行的示意代码： 12345678910111213141516171819202122232425#include &lt;Engine&gt;#include &lt;Wheel&gt;#include &lt;Window&gt;#include &lt;Seat&gt;class Car&#123;public: Engine e(2000); Wheel wheels[4]; Window frontWindows[2]; Window backWindows[2]; Seat seats[5]; int iWeight = 2300; void pushSpeedPedal(int offset)&#123; if (offset &gt; 0) cout &lt;&lt; \"Speed Up.\" &lt;&lt; endl; else cout &lt;&lt; \"Speed Down.\" &lt;&lt; endl; &#125; void pushBrake()&#123; cout &lt;&lt; \"Car is slowing down.\" &lt;&lt; endl; &#125;&#125;; 这段不完整的代码试图描述一个轿车(Car)类。这个型号的轿车有一个发动机，排量2000，整车自重2300Kg，有四个轮子，前后各两个车窗，五把座椅。 我们看到，文件开始就引入了发动机(Engine)、车轮(Wheel)、车窗(Window)、座椅(Seat)这些类。这些类可能是自己写的，也可能是别人写的；这些类可能是专门为这个项目设计的，也可能是很多年前的某人设计出来用于别的目的的。没关系，反正能利用的尽量利用。这种利用他人代码的方式我们称为复用(reuse)。可以看出，面向对象程序设计给代码的复用提供了极大的便利。我们引入别人写的头文件，就是在复用别人的代码。 人类之所以能不断得到进步，其中一个重要原因就是利用他人的劳动成果。一个智能手机的设计师，在设计一款手机时，其中一个重要决定就是选用哪家供应商的哪款CPU作为手机的大脑。在选型时，设计师会考虑CPU的性能、功耗、接口、封装大小，甚至价格，但一般不需要考虑这款CPU是如何制造的，内部的晶体管是如何排列的，甚至，设计师可以根本不需要了解半导体光刻加工工艺的任何细节。设计师需要了解的是：CPU有什么功能，CPU怎么跟外部设备通信，跟存储器怎么联接？跟摄像头怎么连接？ 这些部分，我们称为这个CPU的接口(interface)，接口告诉我们器件的功能及使用方法。那些设计师不需要了解的部分，半导体加工工艺，器件内部晶体管布局，称之为实现(implementation)。作者相信，正是因为这种社会分工的细化，以及将接口与实现分离的思路，促进了人类社会的进步。想象一下，如果设计师需要全盘了解半导体加工的全部细节，需要全盘了解一个液晶屏设计、加工的全部细节，需要了解手机操作系统的全部细节，这个世界上还有手机设计师么？等到一个手机设计并制造出来，作为使用者的我们，就更简单了，触屏操作，用手指按就好了，至于里面是什么型号的CPU，Android操作系统包含多少行代码，根本不需要我们关心。我们只关心接口：怎么用，有什么用！至于手机内部复杂的实现 ，就让那些需要操心的人去操心吧。更为关键的是，不同厂家的手机，在使用方法上大同小异，基本上不需要阅读说明书，我们就能够使用手机的大部分功能。 这种借助于已有的子系统和零部件，借助于现代工程化方法，将一个复杂系统实现并将复杂的系统实现的细节隐藏起来，只向使用者提供一个简洁易用的接口的工作模式，我们称之为封装(encapsuation)。 再回到轿车这个例子，借助于Engine、Window、Seat这些已有的子系统和零部件，我们可以设计一个轿车(Car)类。本例中描述了一辆轿车由发动机、4个轮胎、4个车窗、5个座椅构成，这种将某些自定义类型的对象作为对象的属性/构成部分的方法，也是一种代码复用的手段，称为组合(composition)。 现代燃油轿车内部是极其复杂的，绝大多数驾驶者都不了解其工作细节。但所有驾驶者都掌握一辆自动档汽车的基本使用方法，也就是接口：踩油门，速度变快；踩刹车，速度变慢甚至停下。正是因为使用者只需要了解接口，而不是背后的实现细节，我们才有机会开上车。 在上述Car类里，我们设计了两个成员函数。其中一个叫pushSpeedPedal(int offset)，这就是踩油门函数，offset为正，表明油门往下踩了，要加速，offset为负，表明油门往上松了，要减速。​ 作为这个类的使用者，你或者他只需要了解这些信息就够了。至于这个函数内部是如何实现的，不必关心。可以想象，其内部实现应该极其复杂，可能涉及喷油量大小的调整、火花塞点火频率的快慢、变速器档位的变化等等。另外一个函数叫pushBrake() ，这是刹车。踩刹车汽车速度会减慢甚至停止。同样，使用者只需要知道踩刹车就减速，至于汽车车载计算机收到刹车传感器的指令后是减少油量还是给变速器降档，还是兼而有之，就不需要使用者操心了。 我们做个总结，作为类的设计者的你，应该朝下述目标努力：类设计者的任务 尽量复用或者重用前人的代码，不要重新发明轮子。 使用你认为好的算法以及代码实现类的功能，尽管这些实现部分可能是相当复杂的。 用尽可能简单的函数及属性向使用者提供使用这个类型的简洁的易于理解的接口，并尽可能兼容人们已经习惯的通用接口；也就是说，你设计出来的汽车，还应该是油门在右边，刹车在左边。 把实现的细节隐藏起来。这样，将来，你就有机会在接口不变的情况下，通过修改内部实现而提高类型的性能，比如执行速度。 作为类的使用者的你，应该朝下述目标努力，既使这个类就是半小时前的你设计的： 类使用者的任务 尽量使用别人设计好的类，仅在必要时设计新类。 只管用，不管别人如何实现的。除非你对类的性能不够满意，期望修改它以提升性能。 14.2 访问控制要实现简洁的接口，就需要把复杂的实现隐藏起来。这些复杂的实现，包括： 不希望被类的使用者访问的数据成员； 不希望被类的使用者访问的成员函数。 C++借助于下述三个访问控制符来隐藏实现： 访问控制符 说明 private 私有，说明该成员（数据/函数）仅允许在类的内部访问。 protected 保护，该成员：1. 允许在类的内部访问；2.也允许在该类的继承类▲中访问。 public 公有，该成员可以随意访问。 下述C++程序演示了private，public两个访问控制符的用途： 123456789101112131415161718192021222324252627282930313233343536373839404142//Project - AccessControl#include &lt;iostream&gt;using namespace std;class Person&#123;private: //可略去不写，默认为private float fIncome &#123;0.0f&#125;; //月收入 float computeIncomeTax()&#123; //计算收入税 return fIncome*0.2F; //收入税=月收入 x 20% &#125;public: string sID; string sName; void setIncome(float fIncome)&#123; //设置月收入 this-&gt;fIncome = fIncome; //在类里访问本类私有属性 &#125; string description()&#123; auto fIncomeTax = computeIncomeTax(); //在类里访问本类私有函数 char buffer[1024]; //注意缓冲区尺寸，当心溢出 sprintf(buffer,\"ID: %s\\nName: %s\\nIncome:\" \" %.2f\\nIncome Tax: %.2f\", sID.c_str(), sName.c_str(), fIncome, fIncomeTax); return buffer; &#125;&#125;;int main() &#123; Person dora; dora.sID = \"3604020001\"; //访问公有数据成员 dora.sName = \"Dora Henry\"; //dora.fIncome = 3000; //错误：不可以访问私有成员 //auto fIncomeTax = dora.computeIncomeTax(); dora.setIncome(5000); //访问公有成员函数 cout &lt;&lt; dora.description(); return 0;&#125; 上述程序的执行结果为： 1234ID: 3604020001Name: Dora HenryIncome: 5000.00Income Tax: 1000.00 12345private: //可略去不写，默认为private float fIncome &#123;0.0f&#125;; //月收入 float computeIncomeTax()&#123; //计算收入税 return fIncome*0.2F; &#125; 第6 ~ 10行：fIncome及computeIncomeTax( )位于private访问控制符之后，说明fIncome属于私有数据成员，computeIncomeTax( )则是私有成员函数。请注意，private关键之后的冒号不可或缺。 在定义类成员时，如果没有指定访问控制符，默认为private。这意味着，本例第6行的private可以省略。 123456public: string sID; string sName; void setIncome(float fIncome)&#123; //设置月收入 ... 第11 ~ 27行：数据成员sID，sName位于public访问控制符之后，属于公有数据成员；setIncome( )及description( )位于public访问控制符之后，属于公有成员函数。 123void setIncome(float fIncome)&#123; //设置月收入 this-&gt;fIncome = fIncome; //在类里访问本类私有属性&#125; 第15 ~ 17行：fIncome（月收入）属于私有成员，在外部无法访问。为了设置这个值，我们专门编写了公有成员函数setIncome( )。setIncome( )函数在类的内部，可以访问私有数据成员fIncome。setIncome(float fIncome)负责把形参fIncome赋值给对象的属性fIncome。由于形参名恰巧与属性名重名，如果直接写成fIncome = fIncome，编译器无法正确区分谁是谁，将属性名fIncome改为this-&gt;fIncome可以解决这种表达歧义。 123string description()&#123; auto fIncomeTax = computeIncomeTax(); //在类里访问本类私有函数 ... 第19 ~ 27行：description( )函数在类的内部，它不是类的使用者，它可以访问对象的私有成员函数computeIncomeTax( )。 123Person dora;dora.sID = \"3604020001\"; //访问公有数据成员dora.sName = \"Dora Henry\"; 第31 ~ 33行：sID，sName属于公有属性，类的使用者（此处为main( )函数）可以直接访问dora对象的sID及sName属性。 1//dora.fIncome = 3000; //错误：不可以访问私有成员 第35行：类的使用者（此处为main( )函数），或者说在类的外部，不可以访问对象的私有数据成员。 1//auto fIncomeTax = dora.computeIncomeTax(); 第36行：在类的外部，不可以访问对象的私有成员函数。 1dora.setIncome(5000); //访问公有成员函数 第38行：在类的外部，访问对象的公有成员函数setIncome( )设置对象的私有属性（月收入）。 1cout &lt;&lt; dora.description(); 第39行：在类的外部，访问对象的公有成员函数description( )。如前所述，该公有成员函数内部访问了对象的私有成员函数computeIncomeTax( )。 粗略地，一个类型的公有成员（包括数据成员及成员函数）构成了该类的对外接口，这个接口应尽可能简洁，容易理解；一个类型的私有成员（包括数据成员及成员函数）构成了该类的隐藏的实现。 14.3 标准类实现从第13章到目前为止，出于节省篇幅的目的，我们一直使用一种非标准的方式来定义类。事实上，常规的应用程序通常包括几十、几百甚至几万个自定义类型。 通常，我们需要把一个或者多个紧密相关的类型定义在一对.h及.cpp文件中。这样做有如下益处： 便于项目管理及团队协作，一个大型项目的数百位程序员不可能同时在一个文件里编程。 实现成员函数代码的隐藏。类的使用者要了解一个类的接口，只要阅读头文件就够了，至于放置成员函数详细代码的cpp文件，非必要情况下不必关心。 为了帮助读者理解如何在项目如何创建新类型所对应的“一对.h及.cpp文件”，我们以Qt Creator为例，进行演示说明。 ①. 在Qt Creator中创建一个Non-Qt Project/Plain C++ Application，项目名称为HeaderCpp。 ②. 鼠标右击项目名称HeaderCpp，在弹出菜单中选择“Add New…”。 ③. 选择C++, C++ Class，然后再选“Choose…”。 ④. 类名（Class name）栏中输入Person，然后选“下一步”，接下来选“完成”。 ⑤. 随会可以看到项目树形列表中Headers文件夹下多了一个名为person.h的文件，Sources文件夹下多了一个名为person.cpp的文件。同时，原有的main.cpp还在。 接下来，我们把上一节的程序用标准类的方式重写。person.h的内容如下： 123456789101112131415161718192021#ifndef PERSON_H#define PERSON_H#include &lt;string&gt;using namespace std;class Person&#123;private: //可略去不写，默认为private float fIncome &#123;0.0f&#125;; //月收入 float computeIncomeTax()&#123; //计算收入税 - 内联成员函数 return fIncome*0.2F; //收入税=月收入 x 20% &#125;public: string sID; string sName; void setIncome(float fIncome); //设置月收入 string description();&#125;;#endif // PERSON_H 头文件的职责是对类进行声明。这种类声明包含如下内容： 类名称； 声明类的数据成员； 声明类的方法，通常不定义函数体。 person.h即提供了Person类的声明。如果.h/.cpp文件中只声明/定义了一个类，习惯上我们会让文件与类同名。 1234#ifndef PERSON_H#define PERSON_H...#endif // PERSON_H 第1 ~ 2， 21行：这三行代码由Qt Creator自动帮我们创建，用于避免person.h的类声明部分多次被引入同一个.cpp文件。 根据第12章的讨论，这三行代码属于预处理指令，其语法意义大约等同于下述伪代码： 12345如果 PERSON_H 还没有定义&#123; 定义 PERSON_H [进行Person类声明 ... ]&#125; 如果缺乏上述预处理指令的保护，在特定条件下，某些cpp文件（例如person.cpp），可能会引入person.h多于一次。此时，即相当于在person.cpp中重复对Person类型进行了多次声明，这是不允许的。我们举例说明这种特定条件：a.cpp引入person.h; a.cpp引入b.h， b.h又引入person.h。上述预处理指令的存在，使得Person的类声明部分只能被引入一次。 1#include &lt;string&gt; 第4行：引入Person类声明中需要使用到的string类型。 123float computeIncomeTax()&#123; //计算收入税 - 内联成员函数 return fIncome*0.2F; //收入税=月收入 x 20%&#125; 第10 ~ 12行：通常，类声明中只提供类方法声明，函数体应在对应的.cpp文件中提供。本例中，computeIncomeTax( )的函数体直接写在了类声明里，这事实上是另一种形式的内联函数。它告诉编译器，在可能的情况下，将这个成员函数内联。 person.cpp内容如下： 123456789101112131415#include \"person.h\"void Person::setIncome(float fIncome)&#123; this-&gt;fIncome = fIncome; //在类里访问本类私有属性&#125;string Person::description()&#123; auto fIncomeTax = computeIncomeTax(); //在类里访问本类私有函数 char buffer[1024]; //注意缓冲区尺寸，当心溢出 sprintf(buffer,\"ID: %s\\nName: %s\\nIncome:\" \" %.2f\\nIncome Tax: %.2f\", sID.c_str(), sName.c_str(), fIncome, fIncomeTax); return buffer;&#125; .cpp文件用于类方法定义。person.cpp定义了person.h中声明的两个成员函数。 1#include \"person.h\" 第1行：包含person.h头文件。这是必须的，因为person.cpp中定义的类成员函数必须在person.h中进行了声明。同时，person.h类声明中的成员函数如果不是内联的，也必须在person.cpp中进行定义。 12void Person::setIncome(float fIncome)&#123; ... 第3行：请注意，person.cpp进行函数类定义时使用了域解析符。Person::setIncome意为Person类型中的名为setIncome的成员函数。 main.cpp内容如下： 12345678910111213//Project - HeaderCpp#include &lt;iostream&gt;#include &lt;person.h&gt;using namespace std;int main() &#123; Person dora; dora.sID = \"3604020001\"; //访问公有数据成员 dora.sName = \"Dora Henry\"; dora.setIncome(5000); //访问公有成员函数 cout &lt;&lt; dora.description(); return 0;&#125; 上述程序（即main( )函数）的执行结果与前节完全相同： 1234ID: 3604020001Name: Dora HenryIncome: 5000.00Income Tax: 1000.00 main.cpp是Person类型的使用者，它通过引入person.h头文件才了解Person类型的接口。有了接口（属性的名称，成员函数的名称，形参，返回值类型等）之后，main.cpp就知道应该如何使用Person类型及其对象。 而Person类型的实现部分，至少是成员函数的实现部分，则位于person.cpp。对于整个程序而言，person.cpp与main.cpp分属两个不同的编译单元，main.cpp当中对Person类型的成员函数的调用解析，是在链接阶段完成的。 考虑到描述的简便性，本书后续部分，多数时候仍然会将类的定义与使用放在同一个cpp文件中。但请读者注意，在正式的软件项目中，务必使用本节所描述的标准类实现方法，将类声明和类方法定义组织在一对.h及.cpp文件中。 14.4 友元使用private访问控制符可以把对象成员私有。这种私有是对所有外部对象而言的，并不能达成我们对访问控制的所有需要。例如，多数家庭的银行账户密码对家庭以外成员是保密的，但对妻子/丈夫却是公开的。C++通过友元（friend）语法实现这种存在例外的访问控制。 复数：不同于普通的实数，一个复数由实部和虚部两个部分构成。两个复数相加的结果等于另一个复数，结果复数的实部等于两个操作数的实部的和，虚部等于两个操作数的虚部的和。 下述C++程序设计实现了复数类Complex。在该类中，通过将add( )及main( )函数设定为该类的友元函数（friend class），允许这两个函数访问Complex类的私有成员。 123456789101112131415161718192021222324252627282930//Project - FriendFunction#include &lt;iostream&gt;using namespace std;class Complex&#123; //复数类private: float fReal; //私有的实部和虚部 float fImage;public: Complex(float real, float img)&#123; fReal = real; fImage = img; &#125; friend Complex add(const Complex&amp;, const Complex&amp;); friend int main(); //声明友元函数&#125;;Complex add(const Complex&amp; a, const Complex&amp; b)&#123; float fReal = a.fReal + b.fReal; //友元函数访问对象的私有成员 float fImage = a.fImage + b.fImage; return Complex(fReal,fImage);&#125;int main() &#123; Complex a(3,2); Complex c = add(a,Complex(2,3)); cout &lt;&lt; \"(3+2i)+(2+3i)= \" &lt;&lt; c.fReal &lt;&lt; \"+\" &lt;&lt; c.fImage &lt;&lt; \"i\"; return 0;&#125; 上述代码的执行结果为： 1(3+2i)+(2+3i)&#x3D; 5+5i 第6 ~ 8行：Complex类型将实部fReal及虚部fImage声明为私有数据成员。 12friend Complex add(const Complex&amp;, const Complex&amp;);friend int main(); //声明友元函数 第14 ~ 15行：Complex类型将add( )及main( )函数声明为类型的友元函数。请注意这种声明不仅包括友元函数的函数名，还包括了返回类型，形参列表等，因为函数名重载的原因，仅凭函数名不能确定性地标识一个函数。 12345Complex add(const Complex&amp; a, const Complex&amp; b)&#123; float fReal = a.fReal + b.fReal; //友元函数访问对象的私有成员 float fImage = a.fImage + b.fImage; return Complex(fReal,fImage);&#125; 第18 ~ 22行：add( )接受两个Complex对象的常量型引用作为参数，然后将两个复数对象相加，返回结果复数。请注意，函数体内，该函数访问了Complex对象的私有数据成员，这是作为友元函数的特权。 1234567int main() &#123; Complex a(3,2); Complex c = add(a,Complex(2,3)); cout &lt;&lt; \"(3+2i)+(2+3i)= \" &lt;&lt; c.fReal &lt;&lt; \"+\" &lt;&lt; c.fImage &lt;&lt; \"i\"; return 0;&#125; 第24 ~ 30行：main( )函数也是Complex类的友元函数，所以第28行对c的私有成员的访问是合法的。 请注意，由于add( )函数，main( )函数中需要使用到Complex类型，本例中Complex类型的声明必须早于add( )及main( )函数的定义。 1Complex c = add(a,Complex(2,3)); 第26行：Complex(2,3)通过Complex的构造函数构造了一个临时对象并作为实参传递给add( )函数。这个临时对象也是自动变量，在该函数执行完成后，编译器会自动执行其析构函数。 进一步，我们还可以将另一个类的某个成员函数指定为本类的友元成员函数。下述代码第21行，Complex类型将Computer类型的成员函数void Computer::output(const Complex&amp;)设为友元成员函数，允许其访问本类的私有成员。 1234567891011121314151617181920212223242526272829303132333435//Project - FriendMemberFunction#include &lt;iostream&gt;using namespace std;class Complex;class Computer&#123; //计算器类public: void output(const Complex&amp; c);&#125;;class Complex&#123; //复数类private: float fReal; //私有的实部和虚部 float fImage;public: Complex(float real, float img)&#123; fReal = real; fImage = img; &#125; //友元成员函数 friend void Computer::output(const Complex&amp;);&#125;;void Computer::output(const Complex&amp; c)&#123; cout &lt;&lt; \"Complex(\" &lt;&lt; c.fReal &lt;&lt; \" + \" &lt;&lt; c.fImage &lt;&lt; \"i)\" &lt;&lt; endl;&#125;int main() &#123; Complex a(3,2); Computer c; c.output(a); return 0;&#125; 上述代码的执行结果为： 1Complex(3 + 2i) 第24 ~ 27行：Computer类型的output( )函数是Complex类的友元成员函数，其函数体对Complex对象c的私有成员的访问是合法的。 图14- 声明的顺序 上述程序使用了非常奇怪的声明/定义顺序来保证代码的合法性，我们借助图14- 来进行说明。 ①. Complex类型在声明友元成员函数时，必须先声明Computer类以及该类的output( )成员函数。为了解决这个问题，我们把Computer的类声明放在前面。 ②. Computer类的成员函数output( )有一个类型为const Complex&amp;的形参，根据语法要求，Complex类型必须在该处之前先行声明。为了解决这个先有鸡还是先有蛋的问题，我们在程序开头通过代码class Complex“简易”声明了一个名为Complex的类型，然后再在Computer类声明之后给出Complex类型的详细声明。 ③. Computer的output( )成员函数的函数体要使用到Complex类的数据成员，所以，Computer::output( )成员方法定义只能位于Complex的详细声明之后。 更进一步，我们还可以把其它类整体声明为本类的友元类（friend class）。下述C++代码中，Complex类型声明Computer类型为本类的友元类，授权Computer类的所有成员函数访问Complex类型的私有成员。 12345678910111213141516171819202122232425262728293031323334//Project - FriendClass#include &lt;iostream&gt;using namespace std;class Complex&#123; //复数类private: float fReal; //私有的实部和虚部 float fImage;public: Complex(float real, float img)&#123; fReal = real; fImage = img; &#125; //友元成员函数 friend class Computer;&#125;;class Computer&#123; //计算器类public: void output(const Complex&amp; c)&#123; cout &lt;&lt; \"Complex(\" &lt;&lt; c.fReal &lt;&lt; \" + \" &lt;&lt; c.fImage &lt;&lt; \"i)\" &lt;&lt; endl; &#125; Complex add(const Complex&amp; a, const Complex&amp; b)&#123; return Complex(a.fReal+b.fReal, a.fImage+b.fImage); &#125;&#125;;int main() &#123; Computer c; Complex r = c.add(Complex(1,2),Complex(1,2)); c.output(r); return 0;&#125; 上述程序的执行结果为： 1Complex(2 + 4i) 第14行：将Computer声明为Complex类的友元类。程序中可见，Computer类的成员函数output( )，add( )都因此获得了对Complex类私有成员的访问权。 14.5 静态数据成员第8章中讨论的静态对象存储于全局静态数据区，其生存周期一直持续到程序运行结束。如果将静态对象定义了类的数据成员，便为类的静态数据成员。 下述C++程序中的Tomato类型试图通过静态数据成员来记录“切水果”游戏当中剩余的番茄数量。 123456789101112131415161718192021222324252627282930313233343536373839404142//Project - TomatoCount#include &lt;iostream&gt;#include &lt;stdio.h&gt;using namespace std;class Tomato &#123;private: static int objectCount; //静态数据成员 float fSize &#123;10&#125;; //番茄的尺寸public: Tomato()&#123; objectCount++; //每构造一个对象，数量加1 &#125; ~Tomato()&#123; objectCount--; //每析构一个对象，数量减1 &#125; friend int main();&#125;;int Tomato::objectCount = 0; //给静态数据成员赋初始值int main() &#123; cout &lt;&lt; \"sizeof(Tomato) = \" &lt;&lt; sizeof(Tomato) &lt;&lt; endl; Tomato t1; printf(\"&amp;t1: %p, &amp;Tomato::objectCount: %p\\n\", &amp;t1, &amp;Tomato::objectCount); Tomato t2[10]; Tomato* t3 = new Tomato; printf(\"t1.objectCount=%d, t3-&gt;objectCount=%d, Tomato::objectCount=%d\\n\", t1.objectCount,t3-&gt;objectCount,Tomato::objectCount); printf(\"&amp;t1.objectCount = %p, &amp;t3-&gt;objectCount = %p\\n\", &amp;t1.objectCount,&amp;t3-&gt;objectCount); delete t3; printf(\"t1.objectCount=%d, t3-&gt;objectCount=%d, Tomato::objectCount=%d\\n\", t1.objectCount,t3-&gt;objectCount,Tomato::objectCount); return 0;&#125; 上述程序的执行结果为： 12345sizeof(Tomato) &#x3D; 4&amp;t1: 000000000061fe04, &amp;Tomato::objectCount: 000000000040c030t1.objectCount&#x3D;12, t3-&gt;objectCount&#x3D;12, Tomato::objectCount&#x3D;12&amp;t1.objectCount &#x3D; 000000000040c030, &amp;t3-&gt;objectCount &#x3D; 000000000040c030t1.objectCount&#x3D;11, t3-&gt;objectCount&#x3D;11, Tomato::objectCount&#x3D;11 说明：在读者的计算机上，执行结果中的地址很可能与本书不同。 123private: static int objectCount; //静态数据成员 float fSize &#123;10&#125;; //番茄的尺寸 第7 ~ 9行：Tomato类中定义静态数据成员objectCount。普通数据成员fSize的初始值可以直接在类声明中给出，但非常量型静态数据成员必须在类声明之外进行初始化。 1int Tomato::objectCount = 0; //给静态数据成员赋初始值 第21行：在类声明之外对静态数据成员进行定义和初始化。如果类型是按照14.3节中描述的”标准类“方法实现的，则对静态数据成员定义和初始化必须在相应的.cpp文件中完成，与那些类方法定义在一起。 具体到本例，语法上，上述静态数据成员的定义可以不给objectCount赋初始值，但定义本身不可或缺。因为在物理上，objectCount事实上不属于任何Tomato对象，其内存应该单独分配。这种额外的强制定义确保了该静态数据成员被恰当地分配存储空间。 图14- 静态数据成员的存储 事实上，Tomato类型的普通数据成员fSize与静态数据成员objectCount，在数据存储上有本质区别。如图14- 所示，非静态的普通数据成员fSize在每一个Tomato对象内均分配存储空间，各对象的fSize成员相互独立。但是，静态数据成员Tomato::objectCount仅在全局静态数据区存储一个副本，无论是1号番茄还是3号番茄，它们的objectCount成员代表同一个int类型的对象，即Tomato::objectCount。 只有类的静态数据成员可以使用类名::成员名的形式来使用，例如本例中的Tomato::objectCount，因为objectCount不依赖于具体的Tomato对象而存在。对于普通数据成员fSize，Tomato::fSize是错误的使用形式，因为fSize属于具体的Tomato对象，编译器需要通过其所属对象的地址再加上其在对象内的偏移量来确定其内存地址。 12345678public: Tomato()&#123; objectCount++; //每构造一个对象，数量加1 &#125; ~Tomato()&#123; objectCount--; //每析构一个对象，数量减1 &#125; 第10 ~ 17行：每构造一个对象，静态数据成员objectCount+1；每析构一个对象，静态数据成员objectCount-1。考虑到静态数据成员Tomato::objectCount只有一个副本，+1或-1都是在操作同一个objectCount，理论上，objectCount的值即为当前仍处于“生存”状态的Tomato对象的个数。 事实上，考虑到拷贝构造函数▲的存在，特定情况下，本例中的objectCount并不能完美记录Tomato对象的“生存”个数。 1cout &lt;&lt; \"sizeof(Tomato) = \" &lt;&lt; sizeof(Tomato) &lt;&lt; endl; 第24行：打印一个Tomato对象的大小。执行结果的第1行显示，该值为4个字节。这证实，1个Tomato对象内部仅存储了其普通数据成员fSize（float，4个字节），静态数据成员objectCount未占用对象内的空间。 12Tomato t1;printf(\"&amp;t1: %p, &amp;Tomato::objectCount: %p\\n\", &amp;t1, &amp;Tomato::objectCount); 第26 ~ 27行：定义了自动变量t1，t1存储在栈内。执行结果的第2行显示，栈对象t1地址0x0061fe04与Tomato::objectCount的地址0x0040c030相去甚远，后者存储于全局静态数据存储区，不在栈内。 12Tomato t2[10];Tomato* t3 = new Tomato; 第29 ~ 30行：t2数组有包含10个Tomato，t3指针指向1个Tomato，再加上t1，第30行代码执行后，内存中共有12个番茄。 12printf(\"t1.objectCount=%d, t3-&gt;objectCount=%d, Tomato::objectCount=%d\\n\", t1.objectCount,t3-&gt;objectCount,Tomato::objectCount); 第32 ~ 33行：通过t1.objectCount，t3-&gt;objectCount, Tomato::objectCount三种途径输出静态数据成员objectCount值。执行结果的第3行显示，三种途径均得到12的值，与内存中存在12个番茄的事实相符。 12printf(\"&amp;t1.objectCount = %p, &amp;t3-&gt;objectCount = %p\\n\", &amp;t1.objectCount,&amp;t3-&gt;objectCount); 第34 ~ 35行：打印t1.objectCount，t3-&gt;objectCount的地址。执行结果的第4行证实，它们的地址与Tomato::objectCount完全相同，事实上代表同一个对象。 123delete t3;printf(\"t1.objectCount=%d, t3-&gt;objectCount=%d, Tomato::objectCount=%d\\n\", t1.objectCount,t3-&gt;objectCount,Tomato::objectCount); 第37 ~ 39行：释放指针t3指向的对象后，再次打印objectCount。执行结果的第5行显示，Tomato::objectCount的值变成了11，与事实相符。 至于t2数组所包含的10个Tomato，以及t1，需要等到main( )函数的结尾处才会由编译器自动析构回收。 14.6 静态成员函数类的成员函数也可以是静态的，下述C++程序演示了静态成员函数的基本用法。相对于普通成员函数，静态成员函数有如下特点： 没有秘密的this指针参数，其执行不依赖于任何具体的对象。 在静态成员函数的函数体内，只能访问类的静态数据成员及其他静态成员函数，不能访问类的非静态成员。这是因为：非静态成员的访问依赖于具体的对象，需要通过this指针进行，但静态成员函数没有this指针。 12345678910111213141516171819202122232425262728293031323334353637383940414243//Project - LivingTomato#include &lt;iostream&gt;using namespace std;class Tomato &#123;private: static int iConstructed; //构造数量 static int iDestructed; //析构数量 float fSize &#123;10&#125;; //番茄的尺寸public: Tomato()&#123; iConstructed++; //构造数量+1 &#125; ~Tomato()&#123; iDestructed++; //析构数量+1 &#125; static int livingCount()&#123; //fSize *= 2; //错误：不可以访问非静态成员 //this-&gt;fSize -= 2; //错误：静态成员函数没有this指针 //存活数量 = 构造数量 - 析构数量 return iConstructed - iDestructed; &#125;&#125;;int Tomato::iConstructed &#123;0&#125;; //给静态数据成员赋初始值int Tomato::iDestructed &#123;0&#125;;int main() &#123; Tomato t1; Tomato t2[10]; Tomato *t3 = new Tomato[3]; cout &lt;&lt; \"Number of living tomatoes = \" &lt;&lt; Tomato::livingCount() &lt;&lt; endl; cout &lt;&lt; \"Number of living tomatoes = \" &lt;&lt; t2[3].livingCount() &lt;&lt; endl; cout &lt;&lt; \"Number of living tomatoes = \" &lt;&lt; t3-&gt;livingCount() &lt;&lt; endl; delete[] t3; cout &lt;&lt; \"Number of living tomatoes = \" &lt;&lt; t1.livingCount() &lt;&lt; endl; return 0;&#125; 上述程序的执行结果为： 1234Number of living tomatoes &#x3D; 14Number of living tomatoes &#x3D; 14Number of living tomatoes &#x3D; 14Number of living tomatoes &#x3D; 11 123456static int livingCount()&#123; //fSize *= 2; //错误：不可以访问非静态成员 //this-&gt;fSize -= 2; //错误：静态成员函数没有this指针 //存活数量 = 构造数量 - 析构数量 return iConstructed - iDestructed;&#125; 第19 ~ 24行：定义了“内联”的静态成员函数livingCount( )，该函数通过构造数量减去析构数量的方法求得当前仍“存活”的番茄数量，然后返回。 第20行代码错误：fSize属于类的非静态成员，其它属于某个特定的番茄对象。livingCount( )因为没有this指针，故无法访问该成员。 第21行代码错误：livingCount( )函数没有this指针。 第23行：可以访问iConstructed及iDestructed数据成员，因为它们是静态的，不依赖任何具体的番茄对象而存在。 1234567Tomato t1;Tomato t2[10];Tomato *t3 = new Tomato[3];cout &lt;&lt; \"Number of living tomatoes = \" &lt;&lt; Tomato::livingCount() &lt;&lt; endl;cout &lt;&lt; \"Number of living tomatoes = \" &lt;&lt; t2[3].livingCount() &lt;&lt; endl;cout &lt;&lt; \"Number of living tomatoes = \" &lt;&lt; t3-&gt;livingCount() &lt;&lt; endl; 第31 ~ 37行：先创建了番茄对象t1、番茄对象数组t2以及动态番茄数组t3，共14个番茄，然后通过三种途径调用执行livingCount( )静态成员函数。执行结果的前3行证实，无论是直接调用类的静态成员函数（Tomato::livingCount( )），还是通过对象来调用其静态成员函数（t3-&gt;livingCount( )），实际执行的都是同一个函数，其结果相同。事实上，t3-&gt;livingCount( )这种调用形式，在语法上虽然可以解释为执行t3所指向的Tomato对象的livingCount( )成员函数，但因为livingCount( )是静态的，所以编译器并不会向livingCount( )传递this指针。静态成员函数的执行不依赖于任何具体的对象，即便一个类型从未被实例化，其静态成员函数依然可以执行。 12delete[] t3;cout &lt;&lt; \"Number of living tomatoes = \" &lt;&lt; t1.livingCount() &lt;&lt; endl; 第39 ~ 40行：在删除动态数组t3后，再次执行livingCount( )，执行结果的第4行显示，存活的番茄个数变成了11个，与事实相符。 微实践 - 单件模式**设计模式（design patterns）是软件体系结构中一个比较深入的话题。其中，单件（singleton）模式是其中最简单的一种，它描述了下述应用场景其及解决方案：在程序中，有些类型我们最多只需要一个对象，比如数据库连接、错误日志记录器等等。单件模式试图通过特殊的类设计确保该类型最多只能被实例化一次。 下述C++程序演示了一个名为Daemon的单件类，它是通过静态成员函数来实现的。 123456789101112131415161718192021222324252627282930313233//Project - Singleton#include &lt;iostream&gt;using namespace std;class Daemon &#123;private: static Daemon* instance; Daemon()&#123;&#125; //将构造函数私有 Daemon(const Daemon&amp;)&#123;&#125; //将拷贝构造函数私有public: static Daemon* Instance()&#123; if (instance==nullptr) instance = new Daemon(); return instance; &#125;&#125;;Daemon* Daemon::instance &#123;nullptr&#125;;int main() &#123; //Daemon d; //错误：私有的构造函数不能执行 //Daemon* d = new Daemon(); Daemon* d1 = Daemon::Instance(); //借助于d1指针使用唯一的Daemon对象... Daemon* d2 = Daemon::Instance(); //借助于d2指针使用唯一的Daemon对象... cout &lt;&lt; \"d1 = \" &lt;&lt; d1 &lt;&lt; \", d2 = \" &lt;&lt; d2 &lt;&lt; endl; delete Daemon::Instance(); //释放唯一的Daemon对象 return 0;&#125; 上述程序的执行结果为： 1d1 &#x3D; 0xe517b0, d2 &#x3D; 0xe517b0 说明：在读者的计算机上，执行结果中的地址很可能与本书不同。 1234private: static Daemon* instance; Daemon()&#123;&#125; //将构造函数私有 Daemon(const Daemon&amp;)&#123;&#125; //将拷贝构造函数私有 第6 ~ 9行：Daemon类型的构造函数被私有，这意味着类型的使用者无法直接定义Daemon对象。 Daemon类型的拷贝构造函数（copy constructor）▲也被私有，这意味着类型的使用者无法通过对象的拷贝赋值来创建Daemon对象。 123456public: static Daemon* Instance()&#123; if (instance==nullptr) instance = new Daemon(); return instance; &#125; 第10 ~ 15行：公有的静态成员函数Instance( )用于返回唯一的Daemon对象的指针。该指针保存在静态数据成员instance里，当instance为空时，说明当前程序中不存在Daemon对象，第13行通过new操作符新建一个Daemon对象并将其地址赋值给instance。由于Instance( )是Daemon类的成员函数，所以此处对Daemon的构造函数的调用是合法的。 12//Daemon d; //错误：私有的构造函数不能执行//Daemon* d = new Daemon(); 第21 ~ 22行：任何常规的对象创建方法都需要调用Daemon的构造函数，但其构造函数是私有的。 1234Daemon* d1 = Daemon::Instance();//借助于d1指针使用唯一的Daemon对象...Daemon* d2 = Daemon::Instance();//借助于d2指针使用唯一的Daemon对象... 第24 ~ 27行：类的使用者仅被允许通过Instance( )获取唯一的Daemon对象的指针，然后再借助于获取的指针来使用该对象。 1cout &lt;&lt; \"d1 = \" &lt;&lt; d1 &lt;&lt; \", d2 = \" &lt;&lt; d2 &lt;&lt; endl; 第29行：执行结果证实，每次调用Instance( )函数所获取的指针，都是同一个值。它们都指向那个“唯一”的Daemon对象。 1delete Daemon::Instance(); //释放唯一的Daemon对象 第31行：唯一的Daemon对象必须被释放，否则会造成内存泄漏。 借助于单件模式，在类的设计阶段就保证了该类最多只可能被实例化一次，以避免类的使用者不小心犯错（意外创建多个类对象）。 14.7 常量成员函数可以将类的成员函数设定为常量型。执行一个对象的常量型成员函数不可以导致对对象的任何修改，这意味着： 常量型成员函数不可以修改对象的任何数据成员，mutable类型的数据成员除外。 常量型成员函数不可以调用执行对象的任何非常量型成员函数，因为这些函数的执行，可能会导致对象状态的改变。 mutable在英文中意为“易变的”，用mutable修饰的数据成员不受对象及其成员函数常量性的约束。 常量型成员函数执行预期不会修改对象的状态，那么非常量型成员函数的执行则有可能修改对象的状态。因此：不能执行常量型对象的非常量型成员函数；对于常量型对象，仅可执行其常量型成员函数。 我们通过下述C++程序来解释常量型成员函数的应用。 123456789101112131415161718192021222324252627282930313233343536373839404142//Project - ConstMemberFunction#include &lt;iostream&gt;#include &lt;math.h&gt;using namespace std;class Complex &#123;private: float fReal; float fImage; mutable bool bAbsComputed = false;public: Complex(float real, float image)&#123; fReal = real; fImage = image; &#125; const Complex&amp; add(const Complex&amp; v)&#123; fReal += v.fReal; fImage += v.fImage; return *this; &#125; float abs() const &#123; bAbsComputed = true; //正确：可以修改mutable类型的数据成员 //fReal += 10; //错误：不可以修改非mutable类型的数据成员 //add(Complex(1,2)); //错误：不可以调用非const类型的成员函数 return sqrt(fReal*fReal + fImage*fImage); &#125;&#125;;int main() &#123; Complex c(2,3); c.add(Complex(1,1)); const Complex* p = &amp;c; const Complex&amp; r = c; //p-&gt;add(Complex(1,1)); //错误：不可以执行常量型对象的非常量型成员函数 //r.add(Complex(1,1)); //错误：不可以执行常量型对象的非常量型成员函数 cout &lt;&lt; \"abs(r) = \" &lt;&lt; r.abs() &lt;&lt; endl; return 0;&#125; 上述程序的执行结果为： 1abs(r) &#x3D; 5 12345const Complex&amp; add(const Complex&amp; v)&#123; fReal += v.fReal; fImage += v.fImage; return *this;&#125; 第17 ~ 21行：add( )是一个非常量型的成员函数，该函数把形参v累加到复数对象，然后返回该对象的常量型引用。第17行的const用于修饰函数的返回值类型，并非修饰函数本身。我们看到，第18 ~ 19行，该函数修改了对象的数据成员。 123456float abs() const &#123; bAbsComputed = true; //错误：可以修改mutable类型的数据成员 //fReal += 10; //错误：不可以修改非mutable类型的数据成员 //add(Complex(1,2)); //错误：不可以调用非const类型的成员函数 return sqrt(fReal*fReal + fImage*fImage);&#125; 第23 ~ 28行：abs( )是Complex类的常量型成员函数，它用于计算复数的模。理论上，计算一个复数的模不应该导致这个复数被修改，因此，该函数被设定为常量型成员函数。第23行中的const修饰的是函数本身。 第24行对bAbsComputed的修改是合法的，因为它是mutable类型的数据成员；第25行对fReal的修改是非法的，常量型成员函数不可以导致对象属性的改变；第26行对add( )函数的调用是非法的，因为该函数不是常量型的，其预期会导致对象属性的改变；第28行按照复数的求模公式（实部虚部平方和的平方根）计算复数的模并返回。 12Complex c(2,3);c.add(Complex(1,1)); 第32 ~ 33行：c是一个非常量类型的对象，可以执行其非常量型成员函数add( )。 1234const Complex* p = &amp;c;const Complex&amp; r = c;//p-&gt;add(Complex(1,1)); //错误：不可以执行常量型对象的非常量型成员函数//r.add(Complex(1,1)); //错误：不可以执行常量型对象的非常量型成员函数 第35 ~ 38行：p指向一个常量型Complex对象；r是一个常量型Complex对象的引用。不可以通过p或者r执行对象的非常量型成员函数add( )，因为add( )预期可能会修改对象，而常量对象，不应被修改。 1cout &lt;&lt; \"abs(r) = \" &lt;&lt; r.abs() &lt;&lt; endl; 第40行：对一个常量型对象，执行其常量型成员函数，本例中为abs( )，是合法的。因为常量型成员函数的执行，不会导致对象的修改（mutable类型的数据成员除外）。 15. 代码复用不要重新发明轮子。 — 大家都这么说 优秀的程序员擅长两项工作：在设计轮子的时候，努力设计出好轮子。在设计汽车的时候，挑选出好轮子，很好地使用挑选出来的轮子。本章主要讨论后一项工作，如何利用现有的类设计出新的类型，即代码复用（code use）。 本讲义系重庆大学C/C++课程的教学笔记。 作者： 陈波 chenbo@cqu.edu.cn， All rights reserved. 未经作者许可，不允许经由互联网展示或提供下载。 不允许以纸质出版为目的进行摘抄或改编。 15.1 万物皆对象Alan Kay总结了第一种面向对象程序设计语言SmallTalk的5个特点，这些特点深刻地刻画了画向对象程序设计的精髓。对于C++, 它们也基本适用。 面向对象程序设计五大特征 ① 万物皆对象（Everything is an object）。 ② 对象皆有类型（Every object has a type）。 12int i = int(0);Person dora = Person(\"Dora Henry\") 在语法意义上，上述代码中的i和dora都是对象，只是类型不同：i为int类型，dora为Person类型。Person(“Dora Henry”)是执行Person类型的构造函数，int(0)则是执行int类型的构造函数，以字面量0为参数。当然，所谓int(0)的构造函数，仅是语法意义上的，编译器实际生成的二进制代码里不存在这样对原生数据类型的构造函数调用。 ③ 程序就是由一堆对象构成，对象间通过发送消息协同工作（ A program is a bunch of objects telling each other what to do by sending messages）。 1dora.eat(100); 在面向对象的术语体系里，执行一个对象的方法，例如执行dora对象的eat( )方法，也称为向该对象发送消息。 ④ 每个对象均有自己的存储空间，并由其它对象来构成（Each object has its own memory made up of other objects）。 本书中，我们称作为数据成员参与构成其它对象的对象为成员对象。 ⑤ 相同类型的对象可以接受相同类型的消息（All objects of a particular type can receive the same messages）。 15.2 组合 将一台发动机、4个车窗、五把座椅以及其他部件装配起来，可以组合出一台轿车。在面向对象程序设计的术语体系里，我们把使用多个不同类型的成员对象来构成新类型对象的代码重用方法，称之为组合（composition）。 下述C++代码展示了通过组合方法来构造极简版本轿车的方法，该轿车仅由一个发动机、四个轮胎及一个整数来构成。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//Project - CarComposition#include &lt;iostream&gt;using namespace std;class Wheel &#123;public: short iWheelSize; //轮胎尺寸 Wheel()&#123; cout &lt;&lt; \"Wheel Constructed.\" &lt;&lt; endl; &#125; ~Wheel()&#123; cout &lt;&lt; \"Wheel Destructed.\" &lt;&lt; endl; &#125;&#125;;class Engine &#123;private: int iCapacity; //发动机排量public: Engine(int capacity)&#123; iCapacity = capacity; cout &lt;&lt; \"Engine Constructed.\" &lt;&lt; endl; &#125; ~Engine()&#123; cout &lt;&lt; \"Engine Destructed.\" &lt;&lt; endl; &#125;&#125;;class Car &#123;public: Engine e; Wheel wheels[4]; int iWeight; //整车重量 //... Car(int weight):e(1800), iWeight(weight)&#123; //e.start() ... cout &lt;&lt; \"Car Constructed.\" &lt;&lt; endl; &#125; ~Car()&#123; cout &lt;&lt; \"Car Destructed.\" &lt;&lt; endl; //e.stop() ... &#125;&#125;;int main() &#123; printf(\"sizeof(Engine) + 4 x sizeof(Wheel) + sizeof(int)\\n\"); printf(\"= %d + 4 x %d + %d\\n\", sizeof(Engine), sizeof(Wheel), sizeof(int)); printf(\"= %d\\n\",sizeof(Car)); cout &lt;&lt; \"--------------------------------------\" &lt;&lt; endl; Car c(2300); cout &lt;&lt; \"--------------------------------------\" &lt;&lt; endl; printf(\"&amp;c = %p, &amp;c.e = %p\\nc.wheels = %p, &amp;c.iWeight = %p\\n\", &amp;c, &amp;c.e, c.wheels, &amp;c.iWeight); cout &lt;&lt; \"--------------------------------------\" &lt;&lt; endl; return 0;&#125; 上述程序的执行结果为： 1234567891011121314151617181920sizeof(Engine) + 4 x sizeof(Wheel) + sizeof(int)&#x3D; 4 + 4 x 2 + 4&#x3D; 16--------------------------------------Engine Constructed.Wheel Constructed.Wheel Constructed.Wheel Constructed.Wheel Constructed.Car Constructed.--------------------------------------&amp;c &#x3D; 000000000061fe00, &amp;c.e &#x3D; 000000000061fe00c.wheels &#x3D; 000000000061fe04, &amp;c.iWeight &#x3D; 000000000061fe0c--------------------------------------Car Destructed.Wheel Destructed.Wheel Destructed.Wheel Destructed.Wheel Destructed.Engine Destructed. 说明：在读者的计算机上，执行结果中的地址很可能与本书不同。 上述程序中，一个Car类型的对象c由：1个Engine类型的子对象e，4个Wheel类型的子对象数组wheels以及1个int类型的子对象iWeight构成。根据执行结果的第12 ~ 13行，我们绘制了c对象的内存结构，见下图。 图15- Car类型对象c的内存结构 如图15- 所示，程序第53行所构造的Car类型的对象c占据从0x0061fe00开始的连续16个字节的空间。编译器以非常节约的方式安排c的成员对象，在作者的计算机上，成员对象按定义顺序依次排列。其中，c.e占据最开始的4个字节；c.wheels占据接下来的8个字节，每个Wheel成员两个字节；c.iWeight占据最后的4个字节。 123printf(\"sizeof(Engine) + 4 x sizeof(Wheel) + sizeof(int)\\n\");printf(\"= %d + 4 x %d + %d\\n\", sizeof(Engine), sizeof(Wheel), sizeof(int));printf(\"= %d\\n\",sizeof(Car)); 第48 ~ 50行：打印各成员对象的尺寸。执行结果的第1 ~ 3行证实，Car对象的尺寸等其全部成员对象的尺寸之和。需要说明的是，由于数据对齐的关系，有时对象的尺寸可能会略大于其成员对象的尺寸之和。 1234Car(int weight):e(1800), iWeight(weight)&#123; //e.start() ... cout &lt;&lt; \"Car Constructed.\" &lt;&lt; endl;&#125; 第36 ~ 39行：根据面向对象程序设计的理论，每个对象的都需要通过构造函数来初始化，成员对象也不例外。当一个Car对象被构造时，其成员对象的构造函数由Car对象的构造函数在函数执行的最开始阶段”隐式“地逐一调用执行。执行结果的第5 ~ 10行显示了因Car的构造而间接被执行的成员对象的构造函数的输出，包括1个Engine成员对象及4个Wheel成员对象，请注意第38行的输出“Car Constructed.”位于各成员对象的构造函数输出之后。 本例中，Wheel的构造函数没有参数，Car的构造函数很容易自动调用其4个Wheel成员对象的构造函数。与此不同，Engine的构造函数有一个名为capacity（发动机排量）的形参，要执行成员对象e的构造函数，必须显式地提供其所需的实参。 语法上，在Car构造函数的函数体开始处，即本例中的第37行，Car对象的全部成员对象，包括e，应该处于已经构造完毕的可用状态。这意味着，成员对象的构造应在第37行之前执行。当成员对象存在零参数的构造函数时，编译器会自动完成这项工作。 要点🎯 当成员对象的构造函数要求提供参数时，程序员需要在构造函数初始化列表（constructor initializer list）中提供这些参数。 1Car(int weight):e(1800), iWeight(weight)&#123; ... 本例中，第36行冒号之后的部分即为Car的构造函数初始化列表。在该列表中，可以为多个成员对象提供指定构造参数，成员成象之间以逗号分隔。e(1800)表示以实参1800调用成员对象e的构造函数；iWeight(weight)表示以Car构造函数的形参weight作为实参调用成员对象iWeight的构造函数。根据定义，成员对象iWeight的类型为int，这种原生类型在事实上不存在实际的构造函数，但这种语法是允许的。 注意📢 需要为成员对象提供构造参数只是我们使用构造函数初始化列表的情形之一。当成员对象是一个引用时，也需要通过构造函数初始化列表将该引用与确定的对象相绑定，因为到了构造函数的函数体，该引用类型的成员对象应该处于初始化完毕的可用状态。 1234~Car()&#123; cout &lt;&lt; \"Car Destructed.\" &lt;&lt; endl; //e.stop() ...&#125; 第41 ~ 44行：根据面向对象程序设计的理论，每个对象的内存被释放前都需要执行其析构函数来完成“清理”，成员对象也不例外。本例中，当变量c超出作用域后，编译器生成的指令会执行c的析构函数。c的构析函数会在函数执行的最后阶段”隐式”地调用执行每个成员对象的析构函数。由于析构函数一定是零参数的，所以这里我们并不需要“析构函数析构列表”的协助。 理论上，在Car的析构函数体的最后一行，对应本例中的第43行，Car对象的全部成员对象应处于尚未被析构的可用状态。因此，Car的成员成员的析构函数的执行一定发生在析构函数的最后阶段，本例中，读者可以认为这些隐式的析构函数调用发生在第44行。 执行结果的第15 ~ 20行反应了Car类型对象c的析构函数的执行结果：先输出了”Car Destructed.”之后，各成员对象的析构函数才在c析构函数的最后阶段被“隐式”执行。在作者的计算机上，成员对象的析构顺序正好与构造顺序相反。 借助于其它类型来组合新的类型是非常有效的代码重用方法。当轿车的油门踏板被踩下时，车控计算机可能一方面增大发动机的喷油量，一方面又提高火花赛的点火频率，来达到将车加速的目的。借助于成员对象的接口及其背后隐藏的实现，站在前人的肩膀上，该任务可以简洁地完成，请参考下述伪代码。 12345678class Car &#123;... void pushSpeedPedal()&#123; e.oilPumpIncrease() //加大喷油量 e.igniteFreqIncrease() //提高点火频率 ... &#125;&#125; 一个轿车对象拥有1台发动机，拥有4个轮胎，这种关系称之为has-a关系。has-a关系最适宜的表达形式就是组合。 15.3 继承继承（inheritence）是另一种代码重用的方法。当我们试图定义一个雇员类型时，并不需要从身份证号和姓名定义起。在已经有了Person（人）类型之后，我们借助于继承来定义Employee（雇员）类型： 雇员是人， 雇员具备人的全部属性和方法； 雇员跟不是雇员的其他人有区别，比如雇员有岗位，有工资，有工号。 按照这一思路，我们画出了下述UML类图。 ·图15- 雇员类图 这个类图中，两个框之间的三角形箭头描述了Employee类与Person类之间的继承关系，按该UML类图，我们称Person为父类，Employee为子类。除了父类与子类之外，还有一些同义术语广泛应用于程序设计范畴，请见下表。 表15- 继承相关术语 术语 同义术语 父类(parent class) 超类(super class)， 基类(base class) 子类(sub class) 扩展类(derived class)， 继承类(inherited class) 本节的演示程序分三步实现。 第1步. 按照14.3节所介绍的标准类实现方法，我们首先在名为EmployeeClass的Non-Qt Project/Plain C++ Application中导入了“假装”是别人编写的类型Person，它包含person.h及person.cpp两个文件。 person.h用于存放类声明，其内容如下： 12345678910111213141516171819202122232425262728#ifndef PERSON_H#define PERSON_H#include &lt;string&gt;using namespace std;enum class GenderType&#123; male = 0, female = 1&#125;;class Person&#123;private: int iWeight &#123;50000&#125;; //体重，以克为单位protected: string sName; //姓名 string sID; //身份证号 GenderType gender = GenderType::female; //性别 void speak();public: Person(const string&amp; id, const string&amp; name); void eat(int weight); string description(); ~Person();&#125;; //注意末尾的分号不能少#endif // PERSON_H 第15 ~ 19行：上述Person类声明与第13章中的Person类相似，区别在于：sName、sID、gender被声明为保护数据成员；speak( )被声明为保护成员函数。 按照语义，保护类成员在类的外部无法访问，但可以在类的继承类/子类中访问。 第22行：Person类型的构造函数有两个形参。 person.cpp用于存放类方法定义，其内容如下： 123456789101112131415161718192021222324252627282930#include \"person.h\"#include &lt;iostream&gt;Person::Person(const string&amp; id, const string&amp; name )&#123; sID = id; sName = name; cout &lt;&lt; \"Person::Person()\" &lt;&lt; endl;&#125;Person::~Person()&#123; cout &lt;&lt; \"Person::~Person()\" &lt;&lt; endl;&#125;void Person::speak()&#123; cout &lt;&lt; \"Person::speak()\" &lt;&lt; endl; cout &lt;&lt; \"I am \" &lt;&lt; sName &lt;&lt;\", Nice to meet you here.\" &lt;&lt; endl;&#125;void Person::eat(int weight)&#123; iWeight += weight; cout &lt;&lt; \"I just ate \" &lt;&lt; weight &lt;&lt; \" gram's food.\" &lt;&lt; endl;&#125;string Person::description()&#123; char buffer[1024]; //注意缓冲区尺寸，当心溢出 sprintf(buffer,\"ID: %s\\nName: %s\\nGender: %s\\nWeight: %d\", sID.c_str(),sName.c_str(), gender==GenderType::male?\"Male\":\"Female\",iWeight); return buffer;&#125; 第2步. 在项目中新建一个C++类，名为Employee。该类是Person类的子类，由employee.h及employee.cpp两个文件构成。 employee.h包含Employee的类声明，其内容如下： 1234567891011121314151617181920#ifndef EMPLOYEE_H#define EMPLOYEE_H#include \"person.h\"class Employee:public Person&#123;public: string sEmployeeNo; string sJobTitle; string sDepartment; Employee(const string&amp; emplNo, const string&amp; id, const string&amp; name); ~Employee(); void work(); void speak(); string description();&#125;;#endif // EMPLOYEE_H 第5行：class Employee后面的public Person意为Employee类型从Person类型公有继承▲，Person是父类，Employee为子类。作为Person类型的子类，Employee类型通过继承从Person类型获得了其全部数据成员和方法。 第7 ~ 10行：除了从Person类型那里继承而得的属 性之外，Employee类型还扩展定义了雇员编号（sEmployeeNo）、岗位名称（sJobTitle）、所属部门（sDepartment）三个新的属性。 第15 ~ 17行：除了从Person类型那里继承而得的方法之外，Employee类型还扩展声明了work( )方法，这个新方法是父类型Person所不具备的。此外，Employee类型还重新声明了speak( )及description( )方法，这两个方法Person类型原本就有，Employee通过重新声明和定义这两个方法来实现雇员对象speak( )和description( )方法区别于人的不同行为。 employee.cpp包含类方法定义，其内容如下： 123456789101112131415161718192021222324252627282930313233343536#include \"employee.h\"#include &lt;iostream&gt;using namespace std;Employee::Employee(const string&amp; emplNo, const string&amp; id, const string&amp; name):Person(id,name) &#123; sEmployeeNo = emplNo; cout &lt;&lt; \"Employee::Employee()\" &lt;&lt; endl; //iWeight = 60000; //错误：不可以访问父类的私有成员&#125;Employee::~Employee()&#123; cout &lt;&lt; \"Employee::~Employee()\" &lt;&lt; endl;&#125;void Employee::work()&#123; cout &lt;&lt; \"I am a \" &lt;&lt; sJobTitle &lt;&lt; \", working in department:\" &lt;&lt; sDepartment &lt;&lt; endl;&#125;void Employee::speak()&#123; cout &lt;&lt; \"Employee::speak()\" &lt;&lt; endl; Person::speak(); //可以访问父类的保护成员函数 cout &lt;&lt; \"I am happy to work for you.\" &lt;&lt; endl;&#125;string Employee::description()&#123; char buffer[1024]; //注意缓冲区尺寸，当心溢出 sprintf(buffer,\"ID: %s\\nName: %s\\nGender: %s\\nEmployee No: %s\\n\" \"Job Title: %s\\nDepartment: %s\", sID.c_str(),sName.c_str(), gender==GenderType::male?\"Male\":\"Female\",sEmployeeNo.c_str(), sJobTitle.c_str(),sDepartment.c_str()); //可以访问gender, sID, sName等父类的保护数据成员 return buffer;&#125; 123456Employee::Employee(const string&amp; emplNo, const string&amp; id, const string&amp; name):Person(id,name) &#123; sEmployeeNo = emplNo; cout &lt;&lt; \"Employee::Employee()\" &lt;&lt; endl; //iWeight = 60000; //错误：不可以访问父类的私有成员&#125; 第5 ~ 10行：既然雇员是人的子类，那个一个雇员对象必然也是人对象。当一个雇员对象被构造时，必然伴随一个人对象的构造。当人类型存在一个零参数的构造函数时，雇员的构造函数会自动调用人的构造函数来初始化作为雇员对象一部分的“人”的对象。 与成员对象sEmployeeNo不同，一个雇员对象内部的人对象是通过继承获得的，这种通过继承获得的对象称为父对象。 回顾person.h，应注意到Person类型的构造函数需要身份证号及姓名两个形参。基于与成员对象类似的理由，为了确保雇员对象背后的“人”的部分在第7行变得可用，必须在构造函数初始化列表中为父对象提供参数。第6行的Person(id,name)将Employee构造函数的形参id（身份证号）及name（姓名）作为实参提供给父对象的构造函数。与成员对象不同，父对象没有“名字”，在构造函数初始化列表中使用父对象的类型名（Person）来指代。 第9行：iWeight是父类Person的私有成员，不可以在子类Employee中访问。 12345void Employee::speak()&#123; cout &lt;&lt; \"Employee::speak()\" &lt;&lt; endl; Person::speak(); //可以访问父类的保护成员函数 cout &lt;&lt; \"I am happy to work for you.\" &lt;&lt; endl;&#125; 第21 ~ 25行：子类的方法既可以完全重写，也可以调用执行父类的方法。第23行的Person::speak( )即调用执行了父对象的speak( )方法。Employee::speak( )的this指针的类型为Employee*，既然Employee就是Person，那么Employee*也就是Person*。在调用Person::speak( )时，编译器会把当前this指针当成Person*类型”秘密 “传递给Person::speak( )。请注意， speak( )是Person类型的保护成员，允许在子类中访问。 12345678910string Employee::description()&#123; char buffer[1024]; //注意缓冲区尺寸，当心溢出 sprintf(buffer,\"ID: %s\\nName: %s\\nGender: %s\\nEmployee No: %s\\n\" \"Job Title: %s\\nDepartment: %s\", sID.c_str(),sName.c_str(), gender==GenderType::male?\"Male\":\"Female\",sEmployeeNo.c_str(), sJobTitle.c_str(),sDepartment.c_str()); //可以访问gender, sID, sName等父类的保护数据成员 return buffer;&#125; 第27 ~ 36行：Employee类型的description( )方法也访问了Person父类的保护数据成员gender、sID及sName。 第3步. 在main.cpp中添加如下代码： 123456789101112131415161718192021222324252627282930313233//Project - EmployeeClass#include &lt;iostream&gt;#include &lt;employee.h&gt;using namespace std;int main() &#123; cout &lt;&lt; \"---------------------construct----------------\" &lt;&lt; endl; Employee dora(\"10001\",\"36040200001\",\"Dora Henry\"); dora.sDepartment = \"Marketing\"; dora.sJobTitle = \"Sales\"; cout &lt;&lt; \"---------------------memory map---------------\" &lt;&lt; endl; printf(\"sizeof(Employee) = sizeof(Person) + 3 x sizeof(string)\" \"\\n=%lld + 3 x %lld\\n=%lld\\n\", sizeof(Person),sizeof(string),sizeof(Employee)); Person* pDora = &amp;dora; //通过向上类型转换获得dora对象内的父对象地址 printf(\"&amp;dora = %p\\n&amp;(Parent Object) = %p\\n&amp;dora.sEmployeeNo = %p\" \"\\n&amp;dora.sJobTitle = %p\\n&amp;dora.sDepartment = %p\\n\", &amp;dora, pDora, &amp;dora.sEmployeeNo,&amp;dora.sJobTitle,&amp;dora.sDepartment); cout &lt;&lt; \"---------------------work---------------------\" &lt;&lt; endl; dora.work(); cout &lt;&lt; \"---------------------speak--------------------\" &lt;&lt; endl; dora.speak(); cout &lt;&lt; \"---------------------eat----------------------\" &lt;&lt; endl; dora.eat(220); cout &lt;&lt; \"---------------------description--------------\" &lt;&lt; endl; cout &lt;&lt; dora.description() &lt;&lt; endl; cout &lt;&lt; \"---------------------destruct-----------------\" &lt;&lt; endl; return 0;&#125; 上述程序的执行结果如下： 12345678910111213141516171819202122232425262728293031---------------------construct----------------Person::Person()Employee::Employee()---------------------memory map---------------sizeof(Employee) &#x3D; sizeof(Person) + 3 x sizeof(string)&#x3D;80 + 3 x 32&#x3D;176&amp;dora &#x3D; 000000000063fca0&amp;(Parent Object) &#x3D; 000000000063fca0&amp;dora.sEmployeeNo &#x3D; 000000000063fcf0&amp;dora.sJobTitle &#x3D; 000000000063fd10&amp;dora.sDepartment &#x3D; 000000000063fd30---------------------work---------------------I am a Sales, working in department:Marketing---------------------speak--------------------Employee::speak()Person::speak()I am Dora Henry, Nice to meet you here.I am happy to work for you.---------------------eat----------------------I just ate 220 gram&#39;s food.---------------------description--------------ID: 36040200001Name: Dora HenryGender: FemaleEmployee No: 10001Job Title: SalesDepartment: Marketing---------------------destruct-----------------Employee::~Employee()Person::~Person() 说明：在读者的计算机上，执行结果中的地址很可能与本书不同，执行结果中的对象大小可能与本书有差异。 上述程序创建了一个Employee类型的对象dora，借助于上述执行结果，我们可以画出dora对象的内存地图如下。 图15- Employee类型对象dora的内存结构 如图15- 所示，在一个Employee对象的内存空间内，其Person父对象虽然在逻辑上与其它成员对象有区别，但在内存分配上仍然是Employee对象的组成部分。在作者的计算机上，dora对象占据从0x0061fca0开始的连续176个字节的空间，其中，Person父对象占据最开始的80个字节，然后是Employee的其它数据成员，按定义顺序紧排其后。 12cout &lt;&lt; \"---------------------construct----------------\" &lt;&lt; endl;Employee dora(\"10001\",\"36040200001\",\"Dora Henry\"); 第7 ~ 8行：定义并构造Employee类型的对象dora。执行结果的第1 ~ 3行对应dora的构造函数的输出。由于父对象是在Employee构造函数的函数体代码之前初始化的，因此，输出结果中，Person::Person( )先于Employee::Employee( )。 123456789cout &lt;&lt; \"---------------------memory map---------------\" &lt;&lt; endl;printf(\"sizeof(Employee) = sizeof(Person) + 3 x sizeof(string)\" \"\\n=%lld + 3 x %lld\\n=%lld\\n\", sizeof(Person),sizeof(string),sizeof(Employee));Person* pDora = &amp;dora; //通过向上类型转换获得dora对象内的父对象地址printf(\"&amp;dora = %p\\n&amp;(Parent Object) = %p\\n&amp;dora.sEmployeeNo = %p\" \"\\n&amp;dora.sJobTitle = %p\\n&amp;dora.sDepartment = %p\\n\", &amp;dora, pDora, &amp;dora.sEmployeeNo,&amp;dora.sJobTitle,&amp;dora.sDepartment); 第12 ~ 20行：输出并研究dora对象的内存结构。 第17行：&amp;dora的类型为Employee*，pDora的类型为Person*，由于Employee就是Person，所以把类型为Employee*的地址赋值给Person*类型的指针是合法的。这种从子类型转换为上层父类型的类型转换，称为向上类型转换（upcasting）。与成员对象不同，父对象没有名字，作者只能通过这种方法来获取dora对象内部的Person父对象的地址。执行结果的第5 ~ 7行证实，Employee对象的尺寸等于其全部父对象、成员对象的尺寸之和。 12cout &lt;&lt; \"---------------------work---------------------\" &lt;&lt; endl;dora.work(); 第22 ~ 23行：执行dora的work( )方法。这个方法是Employee类型引入的，执行时，dora的地址会作为this指针被“秘密”传入。相关输出见执行结果的第13 ~ 14行。 12cout &lt;&lt; \"---------------------speak--------------------\" &lt;&lt; endl;dora.speak(); 第24 ~ 25行：dora对象的类型为Employee，执行Employee类型的speak( )函数，以dora的地址作为this指针。回顾employee.cpp，会发现该函数调用执行了Person::speak( )。相关输出见执行结果的第15 ~ 19行。 12cout &lt;&lt; \"---------------------eat----------------------\" &lt;&lt; endl;dora.eat(220); 第26 ~ 27行：dora对象的类型为Employee，但Employee类型没有“自己的”eat( )函数；dora对象的类型也是Person，Person类型有“自己的”eat( )函数。此处，编译器会执行Person类型的eat( )函数，以dora的地址作为this指针。由于dora的类型也是Person，所以其地址也可以视为Person*。相关输出见执行结果的第20 ~ 21行。 12cout &lt;&lt; \"---------------------description--------------\" &lt;&lt; endl;cout &lt;&lt; dora.description() &lt;&lt; endl; 第28 ~ 29行：dora类型为Employee，执行Employee的description( )函数，以dora的地址为this指针。相关输出见执行结果的第22 ~ 28行。 当dora对象超出其作用域时，编译器会在释放其内存前执行其Employee类型的析构函数。该析构函数会在函数的最后阶段“隐式”地调用执行dora的全部成员对象及父对象的析构函数。在执行结果的第29 ~ 31行中可见，Person::Person( )晚于Employee::Employee( )。 本例中，dora的父对象地址与dora自身的地址完全相同。如果一个对象有父对象，父对象总是被安排在对象内存的起始处。这种安排有益于简化对象的地址类型转换。 1Person* pDora = &amp;dora; //通过向上类型转换获得dora对象内的父对象地址 第17行：正是因为父对象位于对象内存的起始处，本行代码的执行变得十分容易，直接把dora的地址赋值给pDora即可。多重继承，通常意味着对象拥有多于一个的父对象。多重继承存在时，这种地址转换就没那么容易了。 12//dora是Employee类型的对象Person doraPerson = dora; 上述程序的第2行把Employee类型的dora对象赋值给Person类型的doraPerson对象。逻辑上，dora也是Person类型，上述赋值是合法的。物理上，doraPerson只有sizeof(Person)大，装不下整个Employee对象，所以，仅dora对象内部的Person父对象部分被复制到doraPerson，其余信息丧失。这种情况很像是从一整块的披萨饼里拿出其中一片，形象称之为对象切片（object slicing）。 雇员（Employee）是人（Person），这种关系称为is-a关系。表达is-a关系的最佳形式是继承。类似的is-a关系还有香蕉是一种水果，泰迪是一种狗，鲸鱼是哺乳动物。 15.4 公有私有及保护继承123class Employee:public Person&#123;...&#125; 前一节中，Employee对Person的继承是公有继承，这意味着：Person类型的公有成员成为Employee类型的公有成员；Person类型的保护成员成为Employee类型的保护成员。换句话说，Person类型的接口成为Employee类型接口的一部分。 除了公有继承外，语法上也允许私有继承和保护继承，三者的区别列表如下。 表15- 继承方式 公有继承 保护继承 私有继承 基类公有成员变成 派生类公有成员 派生类保护成员 派生类私有成员 基类保护成员变成 派生类保护成员 派生类保护成员 派生生私有成员 无论采用何种继承方式，基类的私有成员继承到派生类，均为私有，且无法在派生类中直接访问。 1234567891011121314151617class Base&#123;private: int iPrivate = 0;protected: void protectedMethod()&#123;&#125;public: float fPublic = 2.2;&#125;;class DerivedA:public Base &#123;&#125;;class DerivedB:protected Base&#123;&#125;;class DerivedC:private Base&#123;&#125;; 在上述代码中，基类Base有：私有成员iPrivate、保护成员protectedMethod( )以及公有成员fPublic。DerivedA、DerivedB以及DerivedC类分别以不同的方式继承了基类Base。图15- 解释了三种不同继承方式所带来的不同结果。 图15- 继承方式 图15- 中，DerivedA、DerivedB以及DerivedC中，源自基类Base的私有成员iPrivate被画上了删除线，意思是：该成员存在于派生类对象的内存中，但即便在派生类内部，也无法直接访问该成员。 123456DerivedA a;Base* b0 = &amp;a; //公有继承允许隐式向上类型转换DerivedB b;Base* b1 = (Base*)&amp;b; //保护继承只允许在派生类中进行隐式向上类型转换DerivedC c;Base* b2 = (Base*)&amp;c; //私有继承不允许隐式向上类型转换 此外，不同的继承方式还会导致与向上类型转换有关的差异。上述代码中，第2行将a的地址隐式向上类型转换为Base*，是可以的，公有继承允许隐式向上类型转换。但在第4行、第6行中，这种类型转换必须显式地进行。 15.5 多重继承**一个类型可以有多个父类，这种情况，我们称之为多重继承。请看下述类图。 图15- 多重继承 类图15- 描述了一个雇员，既是＂人＂类，也是＂纳税人＂类的情况。读者不必对这个结构感到困惑，因为广义的纳税人包括那些不是自然人的机构，比如一个有限责任公司。简明起见，作者对这些类的属性和方法进行了简化。 反应上述多重继承结构的C++示例程序如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//Project - MultiInheritence#include &lt;iostream&gt;using namespace std;class Person&#123;public: string sName; string sID; void eat(int weight)&#123; cout &lt;&lt; \"Person::eat(): \" &lt;&lt; weight &lt;&lt; \" grams of food.\\n\"; &#125; Person(const string&amp; id, const string&amp; name)&#123; sID = id; sName = name; cout &lt;&lt; \"Person::Person()\" &lt;&lt; endl; &#125;&#125;;class TaxPayer&#123;public: string sTaxNo; bool payTax(float fAmount)&#123; cout &lt;&lt; \"TaxPayer::payTax(): \" &lt;&lt; fAmount &lt;&lt; endl; return true; &#125; TaxPayer()&#123; cout &lt;&lt; \"TaxPayer::TaxPayer()\" &lt;&lt; endl; &#125;&#125;;class Employee: public Person, public TaxPayer &#123;public: string sEmployeeNo; int iWeekSalary = 0; void work()&#123; cout &lt;&lt; \"Employee::work()\" &lt;&lt; endl; &#125; Employee(const string&amp; id, const string&amp; name, const string&amp; emplNo) :Person(id,name), sEmployeeNo(emplNo)&#123; //构造函数初始化列表 cout &lt;&lt; \"Employee::Employee()\" &lt;&lt; endl; &#125;&#125;;int main()&#123; cout &lt;&lt; \"------------------construct----------------------\\n\"; Employee dora(\"3604020001\",\"Dora Henry\", \"10000\"); cout &lt;&lt; \"------------------memory map---------------------\\n\"; printf(\"sizeof(Employee) = sizeof(Person) + sizeof(TaxPayer)\\n\" \"+ sizeof(string) + sizeof(int)\\n\" \"= %lld + %lld + %lld + %lld\\n= %lld\\n\", sizeof(Person),sizeof(TaxPayer),sizeof(string), sizeof(int),sizeof(Employee)); Person* p = &amp;dora; TaxPayer* t = &amp;dora; printf(\"&amp;dora = %p, &amp;(Person Object) = %p\\n\" \"&amp;(TaxPayer Object) = %p, &amp;dora.sEmployeeNo = %p\\n\" \"&amp;dora.iWeekSalary = %p\\n\", &amp;dora,p,t,&amp;dora.sEmployeeNo,&amp;dora.iWeekSalary); cout &lt;&lt; \"------------------eat----------------------------\\n\"; dora.eat(320); cout &lt;&lt; \"------------------work---------------------------\\n\"; dora.work(); cout &lt;&lt; \"------------------payTax-------------------------\\n\"; dora.payTax(1000.00); return 0;&#125; 上述程序的执行结果为： 123456789101112131415161718------------------construct----------------------Person::Person()TaxPayer::TaxPayer()Employee::Employee()------------------memory map---------------------sizeof(Employee) &#x3D; sizeof(Person) + sizeof(TaxPayer)+ sizeof(string) + sizeof(int)&#x3D; 64 + 32 + 32 + 4&#x3D; 136&amp;dora &#x3D; 000000000062fce0, &amp;(Person Object) &#x3D; 000000000062fce0&amp;(TaxPayer Object) &#x3D; 000000000062fd20, &amp;dora.sEmployeeNo &#x3D; 000000000062fd40&amp;dora.iWeekSalary &#x3D; 000000000062fd60------------------eat----------------------------Person::eat(): 320 grams of food.------------------work---------------------------Employee::work()------------------payTax-------------------------TaxPayer::payTax(): 1000 说明：在读者的计算机上，执行结果中的地址很可能与本书不同；执行结果中的对象大小可能与本书不同。 上述程序创建了一个Employee类型的对象dora，借助于上述执行结果，我们可以画出dora对象的内存地图如下。 图15- 多重继承下的子对象内存结构 本例中，dora对象有两个类型分别为Person和TaxPayer的父对象。如图15- 所示，在作者的计算机上，dora对象占据了起始于0x0062fce0的连续136个字节的内存空间。其中，Person父对象及TaxPayer父对象位于最前端，成员对象sEmployeeNo及iWeekSalary排在后面。出于”数据对齐”的原因，作者的编译器还在末尾留出了4个字节的空白区域。 12cout &lt;&lt; \"------------------construct----------------------\\n\";Employee dora(\"3604020001\",\"Dora Henry\", \"10000\"); 第46 ~ 47行：定义并构造dora对象。执行结果的第1 ~ 4行中，可见因dora的构造而导致的Person父对象、TaxPayer父对象的构造的输出。 1Person* p = &amp;dora; 第55行：&amp;dora的类型为Employee*，p的类型为Person*，此处的赋值隐含了向上类型转换。由于Person父对象排在dora对象的最开头，因此p的地址与dora的地址完全相同，见执行结果第10行（0x0062fce0）。 1TaxPayer* t = &amp;dora; 第56行：dora是Employee，也是TaxPayer，因此此处的向上类型转换是合法的。回顾图15- 可以发现，dora对象内部的TaxPayer父对象并不是位于dora对象的最开头，因此，上述赋值并不是简单地把&amp;dora的值“传递”给t，智慧的编译器自动给&amp;dora加上了一个偏移量，再赋值给t，使得t指向dora对象内部的TaxPayer父对象。执行结果的第11行可见，t值为0x0062fd20，而dora的地址为0x0062fce0。 由于Employee对象的内存布局是由编译器安排的，所以编译器非常清楚TaxPayer父对象在Employee对象内的位置及其相对于对象启始位置的偏移量。 同样，如果把Employee类型的dora赋值给一个TaxPayer类型的对象，也会发生对象切片，仅对象内的TaxPayer父对象部分会被复制。 123456cout &lt;&lt; \"------------------eat----------------------------\\n\";dora.eat(320);cout &lt;&lt; \"------------------work---------------------------\\n\";dora.work();cout &lt;&lt; \"------------------payTax-------------------------\\n\";dora.payTax(1000.00); 第63行：dora的eat( )方法继承自Person类型，编译器会把Person父对象的地址作为this指针传入。 第65行：dora的work( )方法来自Employee类型，编译器会把dora的地址作为this指针传入。 第67行：dora的payTax( )方法来自TaxPayer类型，编译器会把TaxPayer父对象的地址作为this指针传入。同样地，TaxPayer父对象的地址由dora的地址再加上偏移量获得，编译器会主动处理好这些细节。 本节仅讨论了多重继承的最简单应用场景，事实上多重继承极其复杂。【？未写完】 【? name hiding】 16. 对象复制本讲义系重庆大学C/C++课程的教学笔记。 作者： 陈波 chenbo@cqu.edu.cn， All rights reserved. 未经作者许可，不允许经由互联网展示或提供下载。 不允许以纸质出版为目的进行摘抄或改编。 12int a = 3;int b = a; 根据语义，上述第2行是把a对象的内容复制到b对象。当对象的类型是原生数据类型（primitive data type）时，只要把a对象的内存内容按比特原封不动地拷贝到b对象的内存即可。当对象是自定义的复合类型时，问题则要复杂得多。 16.1 赋值与传值我们通过下述C++程序来研究当复合类型对象被赋值或者传值（pass by value）时的复制行为。 123456789101112131415161718192021222324252627282930313233//Project - Copy#include &lt;iostream&gt;using namespace std;class Circle&#123;public: int x = 0; int y = 0; float fRadius = 3.2F; Circle() &#123; cout &lt;&lt; \"Circle::Circle()\" &lt;&lt; endl; &#125; ~Circle() &#123; cout &lt;&lt; \"Circle::~Circle()\" &lt;&lt; endl; &#125;&#125;;void drawCircle(Circle x)&#123; printf(\"drawCircle: (%d,%d), r = %f\\n\", x.x,x.y,x.fRadius);&#125;int main() &#123; Circle c1; Circle c2(c1); Circle c3 = c1; cout &lt;&lt; \"--------------------------------------------------\\n\"; drawCircle(c1); cout &lt;&lt; \"--------------------------------------------------\\n\"; return 0;&#125; 上述程序的执行结果为： 12345678Circle::Circle()--------------------------------------------------drawCircle: (0,0), r &#x3D; 3.200000Circle::~Circle()--------------------------------------------------Circle::~Circle()Circle::~Circle()Circle::~Circle() 上述程序中，我们总共创建了4个Circle类型的对象，分别是：c1、c2、c3以及drawCircle( )的形参对象x。在执行结果中，我们观察到4次析构函数的执行， 但却只观察到构造函数的1次执行。这不符合我们一直强调的对象的创建必然经过构造初始化的理论。接下来我们一边解释代码一边分析。 1Circle c1; 第24行：定义并构建Circle类型对象c1。按照常规，c1的内存被分配在栈里，然后编译器调用Circle构造函数来初始化c1。对应执行结果的第1行。 1Circle c2(c1); 第25行：定义并构建Circle类型的对象c2，与第24行不同，这行代码要求c2对象的内容从c1对象复制。“聪明“的编译器通过下述步骤达成目标。 为c2对象分配sizeof(Circle)的内存空间； 执行Circle的拷贝构造函数（copy constructor），以c2的地址为this指针，以c1的引用作为参数。 拷贝构造函数是一种特殊的构造函数，它通过从其它对象复制数据的方法来初始化对象。本例中，c2对象的构造函数并没有执行，c2事实上是通过拷贝构造函数来完成初始化的。所以本行代码没有在执行结果中产生输出。拷贝构造函数我们在下一节中详细讨论。 1Circle c3 = c1; 第26行：同理，先构造c3，再从c1复制内容是不必要且愚蠢的。所以，编译器仍然选择在c3的内存分配好后，通过执行c3的拷贝构造函数来复制并初始化c3。本行代码在执行结果中没有产生输出。 1drawCircle(c1); 第29行：以c1为实参，调用drawCirlce( )函数。 123void drawCircle(Circle x)&#123; printf(\"drawCircle: (%d,%d), r = %f\\n\", x.x,x.y,x.fRadius);&#125; 第19 ~ 21行：如代码所示，实参c1到形参x需要传值（pass by value），在分配好形参x的栈内存后，x的拷贝构造函数将被执行，以c1的引用作为参数。第20行的printf( )输出见执行结果的第3行。输出结果可见，从c1到x的拷贝构造是成功的，x的值与c1完全相同。到了drawCircle( )函数的末尾，局部变量x超出作用域，其析构函数被编译器自动调用，析构的输出见执行结果的第4行。 上述程序执行到main( )函数的结尾，c1、c2及c3被析构，析构的输出对应执行结果的第6 ~ 8行。综上所述，程序所创建的4个Circle对象，只有c1是被正常构造的，其余c2、c3以及x都是通过拷贝构造函数构造的，所以执行结果中只可见1次构造，却存在4次析构。 16.2 拷贝构造接下来我们给前节中的Circle类型添加拷贝构造函数，来观察拷贝构造的执行过程。C++程序如下： 1234567891011121314151617181920212223242526272829303132333435363738//Project - CircleCopy#include &lt;iostream&gt;using namespace std;class Circle&#123;public: int x = 0; int y = 0; float fRadius = 3.2F; Circle() &#123; cout &lt;&lt; \"Circle::Circle()\" &lt;&lt; endl; &#125; Circle(const Circle&amp; r):x(r.x),y(r.y)&#123; fRadius = r.fRadius; cout &lt;&lt; \"Circle::Circle(const Circle&amp;)\" &lt;&lt; endl; &#125; ~Circle() &#123; cout &lt;&lt; \"Circle::~Circle()\" &lt;&lt; endl; &#125;&#125;;void drawCircle(Circle x)&#123; printf(\"drawCircle: (%d,%d), r = %f\\n\", x.x,x.y,x.fRadius);&#125;int main() &#123; Circle c1; Circle c2 = c1; cout &lt;&lt; \"--------------------------------------------------\\n\"; c1.fRadius = 999.01F; drawCircle(c1); cout &lt;&lt; \"--------------------------------------------------\\n\"; return 0;&#125; 上述程序的执行结果为： 123456789Circle::Circle()Circle::Circle(const Circle&amp;)--------------------------------------------------Circle::Circle(const Circle&amp;)drawCircle: (0,0), r &#x3D; 999.010010Circle::~Circle()--------------------------------------------------Circle::~Circle()Circle::~Circle() 第14 ~ 17行：为Circle类型定义了拷贝构造函数。 1234Circle(const Circle&amp; r):x(r.x),y(r.y)&#123; fRadius = r.fRadius; cout &lt;&lt; \"Circle::Circle(const Circle&amp;)\" &lt;&lt; endl;&#125; 同构造函数一样，拷贝构造函数的函数名与类名相同，且没有返回值。同构造函数不一样，拷贝构造函数有一个形参，其类型为该类的常量型引用。一般地，拷贝构造函数的任务是：从形参r复制其全部数据成员至本对象的对应成员。本例中，作者故意通过构造函数初始化列表来拷贝复制对象的x及y成员，以便提醒读者：拷贝构造函数也有构造函数初始化列表，对象的父对象如果有形参，可以在构造函数初始化列表中提供实参。 1Circle c1; 第29行：c1通过构造函数初始化，对应执行结果的第1行。 1Circle c2 = c1; 第30行：c2通过拷贝构造函数初始化，其形参r即为c1的引用。相关输出对应执行结果的第2行。 12c1.fRadius = 999.01F;drawCircle(c1); 第33 ~ 34行：传值调用drawCircle( )函数。如前所述，drawCircle( )的形参对象x通过拷贝构造函数从c1复制内容。x的拷贝构造对应执行结果的第4行。从执行结果的第5行可见，我们自定义的拷贝构造函数成功复制了c1的内容（r = 999.01）。在drawCircle( )函数的末尾，x被析构，对应执行结果的第6行。 上述事实提醒我们，对于非原始数据类型，在传参时应尽量传递常量型引用，而不是传值。因为传值本身会带来至少两次额外的函数调用：拷贝构造以及析构。当对象本身较大时，例如包含一幅图像的对象，传值的代价非常高。 上述程序执行到main( )函数的结尾，c1、c2被析构，析构的输出对应执行结果的第8 ~ 9行。 16.3 默认拷贝构造函数在16.1节当中，我们并没有为Circle类型定义拷贝构造函数，但从程序执行结果看，对象仍然获得了正确的复制。当自定义类型没有定义拷贝构造函数时，编译器会为其生成一个默认的拷贝构造函数，该拷贝构造函数会：逐一通过拷贝构造来复制对象的全部成员对象及父对象；当成员对象是原生数据类型时，则按比特复制。 我们通过下述C++程序来观察默认拷贝构造函数的行为： 123456789101112131415161718192021222324252627282930//Project - DefaultCopyConstructor#include &lt;iostream&gt;using namespace std;class Point &#123; //点类public: int x = 0; int y = 0; Point(const Point&amp; r)&#123; x = r.x; y = r.y; printf(\"Point::Point(const Point&amp;) - (%d,%d)\\n\",x,y); &#125; Point()&#123;&#125; //显式定义构造函数&#125;;class Rectangle &#123; //矩形类public: Point ptTL; //左上角坐标点 Point ptBR; //右下角坐标点&#125;;int main()&#123; Rectangle r1; r1.ptTL.x = r1.ptTL.y = 100; r1.ptBR.x = r1.ptBR.y = 900; Rectangle r2 = r1; return 0;&#125; 上述程序的执行结果为： 12Point::Point(const Point&amp;) - (100,100)Point::Point(const Point&amp;) - (900,900) 上述代码中，我们描述了一个矩形类Rectangle，该类包含两个Point类型的成员对象ptTL以及ptBR，分别代表矩形的左上（Top Left）角及右下（Bottom Right）角坐标。 我们没有为Rectangle类型定义拷贝构造函数，当Rectangle对象被拷贝构造时，默认拷贝构造函数将被执行。 我们为Point类型自定义了拷贝构造函数，以便于观察当Rectangle对象被拷贝构造时，其成员对象的复制行为。 1Point()&#123;&#125; //显式定义构造函数 第14行：当Point类存在自定义拷贝构造函数时，出乎我们的意料，编译器选择不为Point生成默认构造函数（或者说编译器为Point生成了一个私有的默认构造函数）。与此同时，Rectangle的默认构造函数需要借助于Point的构造函数来初始化ptTL及ptBR。为了保证程序的正确编译，我们不得不为Point手工定义一个零参数公有构造函数。 1Rectangle r1; 第24行：通过默认构造函数构建对象r1。 1Rectangle r2 = r1; 第28行：通过Rectangle的默认拷贝构造函数从r1拷贝构造r2。执行结果中，我们可以看到：r2的两个成员对象ptTL、ptBR的拷贝构造函数被依次执行。 考虑下述代码： 123Rectangle r1;Rectangle r2;r2 = r1; 在第3行执行之前的第2行，r2已经被构造。在第3行，编译器不可能对一个已经存在且初始化完毕的对象r2再次执行拷贝构造函数，从r1到r2的赋值就是普通的对成员对象的逐一赋值。在后续的”操作符重载”章节，我们将深入讨论这种赋值行为。 16.4 深拷贝编译器为类型生成的默认拷贝构造函数大多数时候符合我们的需要。但是，当对象内部存在动态成员对象时，默认的拷贝构造函数则十分危险。 如前所述，C++的标准模板库中的string对象仅有32个字节大小（其它编译器下可能是其它值），其包含的字符串事实上存储在动态申请的堆空间内，string对象内部包含一个指针指向申请的堆空间。这种结构使得string类型的对象可以“容纳”几乎无限大的字符串。 下述C++程序中，我们自定义了UserString类型来存储字符串，其结构模仿string类型。 警告🚩 UserString程序的执行可能会异常中止！读者如果无法得到与本书类似的执行结果，请删除代码的第30 ~ 31行。 123456789101112131415161718192021222324252627282930313233343536373839404142434445//Project - UserString#include &lt;iostream&gt;#include &lt;string.h&gt;using namespace std;class UserString &#123;private: char* buffer = nullptr; //缓冲区指针 unsigned long long size = 0; //缓冲区大小public: void assign(const char* s)&#123; unsigned long long sizeNeeded = strlen(s) + 1; if (size &gt;= sizeNeeded) //缓冲区够用，直接复制 strcpy(buffer,s); else &#123; if (buffer!=nullptr) //缓冲区不够用，重新申请后再复制 free(buffer); size = sizeNeeded; buffer = (char*)calloc(size,1); strcpy(buffer,s); &#125; &#125; const char* content()&#123; return buffer; //返回字符数组的地址 &#125; ~UserString()&#123; if (buffer!=nullptr) free(buffer); //释放缓冲区,危险！ &#125;&#125;;int main() &#123; UserString s1; s1.assign(\"New coronavirus believed to be derived from bats.\"); UserString s2 = s1; //默认拷贝构造 s2.assign(\"Human beings will win!\"); cout &lt;&lt; \"s1 = \" &lt;&lt; s1.content() &lt;&lt; endl; cout &lt;&lt; \"s2 = \" &lt;&lt; s2.content() &lt;&lt; endl; return 0;&#125; 上述程序的执行结果为： 12s1 &#x3D; Human beings will win!s2 &#x3D; Human beings will win! 我们先解释UserString类型的实现。 12345class UserString &#123;private: char* buffer = nullptr; //缓冲区指针 unsigned long long size = 0; //缓冲区大小 ... 第6 ~ 9行：私有指针buffer指向申请的堆空间，该空间称为缓冲区，用于存储实际的字符串。该指针为空时，表示对象尚未申请堆空间。在物理上，存储实际字符串的缓冲区不在对象内部，但逻辑上，我们应认为缓冲区是对象的构成部分。私有无符号长整数size表示“拥有”的堆空间的字节数，默认值为0。 12345678910111213public: void assign(const char* s)&#123; unsigned long long sizeNeeded = strlen(s) + 1; if (size &gt;= sizeNeeded) //缓冲区够用，直接复制 strcpy(buffer,s); else &#123; if (buffer!=nullptr) //缓冲区不够用，重新申请后再复制 free(buffer); size = sizeNeeded; buffer = (char*)calloc(size,1); strcpy(buffer,s); &#125; &#125; 第11 ~ 23行：assign( )成员函数负责把参数字符串赋值给对象。 第13行：通过求参数字符串的长度再加1得到需要的存储空间字节数sizeNeeded。 第14 ~ 22行：如果当前对象拥有的缓冲区尺寸大于等于sizeNeeded，直接复制参数字符串至缓冲区。否则，释放已有的缓冲区，重新申请后再行复制。 123const char* content()&#123; return buffer; //返回字符数组的地址&#125; 第25 ~ 27行：content( )成员函数用于获取私有的缓冲区地址。程序的42 ~ 43行利用该函数所返回的缓冲区地址来打印字符串。 1234~UserString()&#123; if (buffer!=nullptr) free(buffer); //释放缓冲区,危险！&#125; 第29 ~ 32行：析构函数进行对象清理，如果发现存在缓冲区，进行释放。在本例中，这种释放行为可能会导致程序崩溃，原因稍后解释。 接下来解释main( )函数。 12UserString s1;s1.assign(\"New coronavirus believed to be derived from bats.\"); 第36 ~ 37行：定义并构建UserString类型的对象s1。执行s1的assign( )成员函数将参数字符串赋值给s1。 1UserString s2 = s1; //默认拷贝构造 第39行：UserString没有定义拷贝构造函数，本行执行UserString的默认拷贝构造函数完成从s1到s2的复制。按照期望，完成复制以后，s2应满足如下要求： 内容与s1相同； 与s1相互独立，互不相关。 图16- 期望的拷贝构造结果 图16- 展示了作者期望的拷贝结果：物理上不属于逻辑上属于s1的缓冲区部分也被完整复制，拷贝构造完成后，s1和s2相互独立。 但事实上，默认的拷贝构造函数的行为是逐一就对象的每个成员对象（包括父对象）进行拷贝构造。其中，char*类型的buffer就是一个地址，该地址被直接从s1复制到s2。 图16- 事实上的拷贝构造结果 图16- 展示了事实上的拷贝构造结果：s1和s2的buffer指针指向同一块堆内存，两者并不独立。 1s2.assign(\"Human beings will win!\"); 第40行：执行s2的assign( )函数将参数字符串赋值给s2。由于新字符串的长度比s2.buffer指向的内存块要小，因此，assign( )函数直接把参数字符串拷贝到s2.buffer指向的内存块。请注意，由于s1.buffer等于s2.buffer，所以上述函数执行后，从s1的角度看，它的缓冲区也被修改了。 12cout &lt;&lt; \"s1 = \" &lt;&lt; s1.content() &lt;&lt; endl;cout &lt;&lt; \"s2 = \" &lt;&lt; s2.content() &lt;&lt; endl; 第42 ~ 43行：输出s1和s2所包含的“字符串”。执行结果的证实，s2的assign( )同时导致了s1的被修改。这不是我们期望的。 程序更大的危险来自于s1和s2的析构。按照顺序，s2先被析构，其析构函数将会释放s2.buffer。接下来，s1被析构，由于s1的buffer指针与s2相同且不为空，s1的析构函数将释放s1.buffer，这意味着，我们先后两次释放同一块堆内存，这很可能导致程序崩溃。 这种由默认拷贝构造函数所主导的对象复制称之为浅拷贝（shallow copy），对于那些包含动态成员对象的对象，深拷贝（deep copy）是必要的。深拷贝的基本方法，就是自定义拷贝构造函数，将对象的动态部分也进行复制。 下面是修改过后的正确程序： 1234567891011121314151617181920212223242526272829303132333435//Project - DeepCopy...class UserString &#123;private: char* buffer = nullptr; //缓冲区指针 unsigned long long size = 0; //缓冲区大小public: void assign(const char* s)&#123; ... &#125; const char* content()&#123; ... &#125; ~UserString()&#123; ... &#125; UserString(const UserString&amp; r)&#123; size = r.size; if (size&gt;0 &amp;&amp; r.buffer!=nullptr)&#123; buffer = (char*)calloc(size,1); strcpy(buffer,r.buffer); &#125; &#125; //自定义拷贝构造函数导致编译器放弃为类型准备公有的默认构造函数 UserString()&#123;&#125; //不可或缺&#125;;int main() &#123; UserString s1; s1.assign(\"New coronavirus believed to be derived from bats.\"); UserString s2 = s1; //默认拷贝构造 s2.assign(\"Human beings will win!\"); cout &lt;&lt; \"s1 = \" &lt;&lt; s1.content() &lt;&lt; endl; cout &lt;&lt; \"s2 = \" &lt;&lt; s2.content() &lt;&lt; endl; return 0;&#125; 上述程序的执行结果为： 12s1 &#x3D; New coronavirus believed to be derived from bats.s2 &#x3D; Human beings will win! 第13 ~ 19行：自定义的拷贝构造函数并没有直接从被拷贝对象复制buffer指针，而是新申请了一块同等大小的内存，并从被拷贝对象复制了字符串内容。 s1到s2的拷贝构造完成后，两者完全独立，对s2的修改不再影响s1，执行结果可见：两个对象包含着不一样的字符串。当两个对象各自析构时，也是安全的，因为各自释放各自的buffer，互不相干。 警告🚩 UserString类型的深拷贝做得并不完美，还缺少一个自定义operator=操作符成员函数。相关内容见17.4节。 16.5 私有拷贝构造函数读者可能会问：何时应该给自定义类型设计拷贝构造函数？ 如果类型不包含动态成员对象，直接使用默认的拷贝构造函数是安全的。如果包含动态成员对象，则最好为其设计拷贝构造函数。当然，也可以不设计，前提是将拷贝构造函数私有化，以避免对象的传值及其它拷贝构造行为。 C++示例程序如下： 12345678910111213141516171819202122232425//Project - PrivateCopyConstructor#include &lt;iostream&gt;using namespace std;class UserString&#123;public: //... UserString()&#123;&#125;private: UserString(const UserString&amp; r)&#123;&#125;&#125;;void output(const UserString&amp; s)&#123; //... return;&#125;int main()&#123; UserString s1; //UserString s2 = s1; //错误：不可以调用私有的拷贝构造函数 UserString&amp; s2 = s1; output(s1); //传引用，不导致拷贝构造 return 0;&#125; 第10行：设计了一个函数体为空的私有的拷贝构造函数。因其私有不可能被调用，函数体为空是合理的。 第20行：这种行为将导致s2的拷贝构造函数被执行，但私有的拷贝构造函数不可调用，编译器会拒绝。 第21行：对s1进行引用是合法的。 第23行：如果传值给output( )，将导致非法的拷贝构造，但传引用是允许的。 17. 操作符重载本讲义系重庆大学C/C++课程的教学笔记。 作者： 陈波 chenbo@cqu.edu.cn， All rights reserved. 未经作者许可，不允许经由互联网展示或提供下载。 不允许以纸质出版为目的进行摘抄或改编。 终于到了解开cout &lt;&lt; “Hello World”之谜的时间。请阅读下述C++程序： 123456789//Project - COUT#include &lt;iostream&gt;using namespace std;int main() &#123; cout &lt;&lt; \"pi = \" &lt;&lt; 3.14159 &lt;&lt; endl; operator&lt;&lt;(cout,\"pi = \").operator&lt;&lt;(3.14159).operator&lt;&lt;(endl); return 0;&#125; 上述程序的执行结果为： 12pi &#x3D; 3.14159pi &#x3D; 3.14159 程序的第6行与第7行完全等价。相关代码的执行过程如下： cout &lt;&lt; “pi = “的实质是执行了一个名为operator&lt;&lt;( )的函数，其中，第1个参数是cout对象，第2个参数是”pi = “。这个函数把第2个参数的字符串输出到第1个参数所代表的控制台中。同时，该函数返回了cout的引用作为函数执行的结果。 … &lt;&lt; 3.141519则以前述函数调用所返回的cout引用作为基础，执行其成员函数operator&lt;&lt;( )。该成员函数存在多个函数名重载的版本，其中一个版本接受一个double作为参数，并将double的值输出到cout。同样地，本次函数调用也返回了cout的引用作为结果。 类似地，… &lt;&lt; endl同样对应cout.operator&lt;&lt;( )函数的一次执行，该成员函数的一个重载版本接受endl作为参数，并向cout所代表的控制台输出一个换行符。 &lt;&lt;操作符在C语言里用作左移位操作，C++的标准模板库通过定义与该操作符“同名”的函数，扩展了该操作符的功能：向cout输出对象内容。 要点🎯 通过定义操作符函数来扩展操作符功能的方法，称之为操作符重载（operator overloading）。 17.1 复数类为讲解方便，我们设计了如下的复数类型。该复数类型包含两个成员对象：dReal（实部）及dImage（虚部）。在数学上，我们知道复数的加法就是实部加实部，虚部加虚部。在C++里，作为代码“介绍”给编译器的新类型，编译器并不知道如何把两个复数相加。 1234567891011121314151617181920212223242526//Project - ComplexClass#include &lt;iostream&gt;using namespace std;class Complex &#123;public: double dReal; double dImage; Complex(double real, double image)&#123; dReal = real; dImage = image; &#125; Complex add(const Complex&amp; r)&#123; return Complex(dReal+r.dReal,dImage+r.dImage); &#125;&#125;;int main() &#123; Complex a(1,3); Complex b(2,4); Complex c = a.add(b); printf(\"a + b = %.2f + %.2fi\\n\", c.dReal,c.dImage); return 0;&#125; 上述程序的执行结果为： 1a + b &#x3D; 3.00 + 7.00i 为了解决复数间加法运算的问题，上述代码为Complex类型设计了一个add( )成员函数，a.add(b)将复数a与b相加，返回一个结果复数。 123Complex add(const Complex&amp; r)&#123; return Complex(dReal+r.dReal,dImage+r.dImage);&#125; 第14 ~ 16行：成员函数add( )。第15行生成的Complex对象是一个临时对象，在函数调用完成后， 该临时对象会被销毁。所以add( )函数选择通过传值来返回执行结果，其返回类型为Complex，而不是Complex的引用。 警告🚩 永远不要返回函数内局部变量或者临时对象的地址或者引用。 17.2 +操作符复数类的使用者更喜欢使用下述格式来进行复数的加法运算： 1c = a + b; 这可以通过重载+号操作符来实现，其中一种方法就是为Complex类定义一个名为operator+的函数。 相关C++代码如下： 123456789101112131415161718192021//Project - ComplexAdd#include &lt;iostream&gt;using namespace std;class Complex &#123;public: ... Complex operator+(const Complex&amp; r) const&#123; cout &lt;&lt; \"Complex::operator+()\" &lt;&lt; endl; return Complex(dReal+r.dReal,dImage+r.dImage); &#125;&#125;;int main() &#123; Complex a(1,3); Complex b(2,4); Complex c = a + b; printf(\"a + b = %.2f + %.2fi\\n\", c.dReal, c.dImage); return 0;&#125; 上述程序的执行结果为： 12Complex::operator+()a + b &#x3D; 3.00 + 7.00i 第8 ~ 11行：为Complex类型定义名为operator+的重载操作符函数。 +号操作符是所谓二元操作符，其典型语法格式为a + b，它应该有两个操作数。作为成员函数的operator+( )的执行，必然是以某个对象的基础的，被执行该函数的对象，被视为左操作数，即典型语法中的a。所以，operator+( )的形参只要定义右操作符即可，考虑到在加法运算过程中，右操作符不应该被修改，所以形参的类型被定义为const Complex&amp;。同样地，该函数的执行预期也不应该修改对象本身（左操作符），故将其定义成常量型成员函数。 第9行：向控制台输出一行文字，提示函数的执行。 第10行：将对象（左操作数）的实部与形参r（右操作数）的实部相加，得结果复数的实部；将对象的虚部与形参r的虚部相加，得结果复数的虚部。然后再构造一个临时的Complex对象并返回。 1Complex c = a + b; 第18行：a + b被编译器解释为a.operator+(b)，即把a当成左操作数，执行a的operator+( )成员函数，以b的引用为参数。该函数的返回值通过拷贝构造复制到c。 执行结果证明，a的operator+( )成员函数被成功执行，结果正确。 要点🎯 重载的操作符函数既可以设计为类的成员函数，也可以设计为全局函数。 全局的重载操作符函数请见下述C++示例。 12345678910111213141516171819//Project - GlobalOperatorPlus#include &lt;iostream&gt;using namespace std;class Complex &#123; ... &#125;;Complex operator+(const Complex&amp; op1, const Complex&amp; op2)&#123; cout &lt;&lt; \"operator+(const Complex&amp;, const Complex&amp;)\" &lt;&lt; endl; return Complex(op1.dReal+op2.dReal,op1.dImage+op2.dImage);&#125;int main() &#123; Complex a(1,3); Complex b(2,4); Complex c = a + b; printf(\"a + b = %.2f + %.2fi\\n\", c.dReal, c.dImage); return 0;&#125; 上述程序的执行结果为： 12operator+(const Complex&amp;, const Complex&amp;)a + b &#x3D; 3.00 + 7.00i 第7 ~ 10行：定义了一个名为operator+的全局函数，该函数接受两个const Complex&amp;作为参数。在函数体内，将两个参数相加，并返回结果复数。 1Complex c = a + b; 第16行：a + b被编译器解释为operator+(a,b)，该函数的执行结果被拷贝构造给c。 执行结果佐证了operator+(a,b)的执行以及结果的正确。 读者可能会问：如果前述例子中作为成员函数的operator+( )与作为全局函数的operator+( )同时存在，编译器会选择哪一个呢？ 作者的建议是，不必关心。一个优秀程序员需要关心的是在程序编写过程中避免这种歧义状况的发生。 要点🎯 同加法操作符类似，减法、乘法、除法也是二元操作符，其重载方法与operator+类似，它们对应的操作符重载函数名分别是operator-、operator*以及operator/。+=、-=、/=、*=也是二元操作符，重载方法大体相同，它们对应的操作符重载函数名分别为operator+= 、operator-= 、operator/= 、operator*=。 17.3 &lt;&lt;操作符1printf(\"a + b = %.2f + %.2fi\\n\", c.dReal, c.dImage); 前两节的示例中， 我们使用printf( )函数来完成复数输出，这不够方便。现在Complex类型的使用者提出了新的要求，他希望下述代码能将复数c输出至控制台： 12Complex c;cout &lt;&lt; c &lt;&lt; endl; cout对象的类型为ostream，它是由iostream头文件引入的，而iostream是C++标准模板库的组成部分。显然，我们不太可能也不应该去修改标准模板库，为ostream类型增加一个接受Complex对象的operator&lt;&lt;成员函数。所以，我们选择添加一个全局函数operator&lt;&lt;(ostream&amp; o, const Complex&amp; c)。 C++程序如下： 1234567891011121314151617//Project - ComplexOutput#include &lt;iostream&gt;using namespace std;class Complex &#123; ... &#125;;ostream&amp; operator&lt;&lt;(ostream&amp; o, const Complex&amp; c)&#123; o &lt;&lt; c.dReal &lt;&lt; \" + \" &lt;&lt; c.dImage &lt;&lt; \"i\"; return o;&#125;int main() &#123; Complex a(1,3); cout &lt;&lt; a &lt;&lt; endl; operator&lt;&lt;(cout,a).operator&lt;&lt;(endl); return 0;&#125; 上述程序的执行结果为： 121 + 3i1 + 3i 第7 ~ 10行：除了将形参复数c输出到ostream&amp;类型的形参o之外，全局操作符函数operator&lt;&lt;(ostream&amp; o, const Complex&amp; c)还将形参o作为返回值返回。 第14行：cout并不存在一个接受Complex对象为参数的operator&lt;&lt;成员函数。编译器将cout &lt;&lt; a解释为operator&lt;&lt;(cout, a)。该函数返回cout自身的引用作为返回值，以该返回值为基础，ostream的operator&lt;&lt;成员函数被执行，以endl为参数。 第15行：与第14行完全等价。 17.4 =操作符1234Complex a(1,3); //构造函数被执行Complex b(a); //拷贝构造函数被执行Complex c = a; //拷贝构造函数被执行c = a; //operator=操作符函数被执行 上述代码的第4行与第2 ~ 3行有一个重大区别：在赋值操作执行前，被赋值对象已经存在了。显然，对一个已经存在的对象再次应用拷贝构造函数进行复制初始化是不恰当的，编译器会执行c对象的operator=操作符函数，以a为参数。 要点🎯 当一个对象不存在适用的自定义的operator=操作符函数时，编译器会执行默认operator=操作符函数。该函数：逐一通过operator=操作符函数来复制对象的全部成员对象及父对象；当成员对象是原生数据类型时，则按比特复制。 要点🎯 当赋值行为发生时，如果=操作符的左值对象已构造完毕（上述代码第4行），编译器会执行operator=操作符函数；如果左值对象尚未构造（上述代码第3行），编译器会执行拷贝构造函数。 下述C++程序演示了Complex类型的自定义operator=成员函数： 1234567891011121314151617181920//Project - ComplexAssignment#include &lt;iostream&gt;using namespace std;class Complex &#123;public: ... const Complex&amp; operator=(const Complex&amp; r)&#123; cout &lt;&lt; \"Complex::operator=()\" &lt;&lt; endl; dReal = r.dReal; dImage = r.dImage; return *this; &#125;&#125;;int main() &#123; Complex a(1,3), b(2,3), c(1,5); c = b = a; c.operator=(b.operator=(a)); return 0;&#125; 上述程序的执行结果为： 1234Complex::operator&#x3D;()Complex::operator&#x3D;()Complex::operator&#x3D;()Complex::operator&#x3D;() 第8 ~ 12行：如本书第3章所述，赋值操作符除了赋值外，还会返回一个对象作为赋值表达式的值，该返回对象可以做为另一个赋值操作符的右值对象。Complex的operator=成员函数返回值类型被设定为const Complex&amp;，函数体试图返回对象自身作为返回值，但由于this指针的类型是Complex*，需要加上*操作符以便符合返回值的类型要求。 第17行：c = b = a的执行过程分为两步。 b = a部分先被执行，其对应代码为b.operator=(a)。按照operator=操作符函数的代码，该次执行返回b自身的引用。 上一步返回的引用作为右值赋值给c对象，其对应代码为c.operator=(上一步返回值)。 两次operator=函数的调用输出对应执行结果的第1 ~ 2行。 第18行：与第17行完全等价，对应执行结果的第3 ~ 4行。 上述operator=成员函数的返回类型也可以定义为void，即只进行赋值操作，不返回赋值表达式的值。此时，下述代码的第1行合法，第2行非法。 12b = a; //合法，执行b.operator=(a)c = b = a; //非法，b = a没有返回值，c = 部分缺少右值对象 如果期望把一个double对象赋值给一个Complex对象，第1种方法是对operator=操作符函数进行函数名重载，见下述C++示例： 123456789101112131415161718192021//Project - ComplexDouble#include &lt;iostream&gt;using namespace std;class Complex &#123;public: ... const Complex&amp; operator=(const Complex&amp; r)&#123; ... &#125; const Complex&amp; operator=(const double r)&#123; cout &lt;&lt; \"Complex::operator=(const double)\" &lt;&lt; endl; dReal = r; dImage = 0; return *this; &#125;&#125;;int main() &#123; Complex c(1,5); c = 3.14; return 0;&#125; 上述程序的执行结果为： 1Complex::operator&#x3D;(const double) 可见，Complex类有两个operator=成员函数，其中一个接受const Complex&amp;作为参数，另一个接受const double作为参数。 第19行：将double类型的字面量3.14赋值给c，编译器选择执行c.operator=(const double)。执行结果做出了佐证。 可以想象，如果第19行改为c = 3，3是一个整数字面量，编译器会将3隐式类型转换成double，再执行对应的operator=(const double)成员函数。 17.5 构造函数类型转换将一个double类型对象赋值给一个Complex类型对象的第2种方法是为Complex类型定义一个参数为double的构造函数，请见下述C++示例： 1234567891011121314151617181920//Project - ConstructorTypeConversion#include &lt;iostream&gt;using namespace std;class Complex &#123;public: ... Complex(double real, double image)&#123; ... &#125; Complex(const double r)&#123; cout &lt;&lt; \"Complex::Complex(const double)\" &lt;&lt; endl; dReal = r; dImage = 0; &#125; const Complex&amp; operator=(const Complex&amp; r)&#123; ... &#125;&#125;;int main() &#123; Complex c(1,5); c = 3.14;&#125; 上述程序的执行结果为： 12Complex::Complex(const double)Complex::operator&#x3D;(const Complex&amp;) 第19行：试图把3.14赋值给c，Complex类型并不存在接受double对象的oeprator=成员函数，但有一个接受double对象的构造函数以及一个接受Complex对象的operator=成员函数。“聪明”的编译器作出了下述安排： 先执行Complex(const double)，以3.14为参数，构造一个临时的Complex对象； 将临时Complex对象作为参数，执行c.operator=(const Complex&amp;)成员函数，完成赋值； 临时对象析构。 执行结果反应了上述执行过程。因为没有为Complex类型自定义析构函数，所以执行结果没有反应临时对象的析构过程。 17.6 UserString的深拷贝16.4节中UserString的深拷贝是有缺陷的： 没有考虑到operator=操作符函数； 将字符串字面量赋值给UserString对象需要借助assign( )成员函数，不够直观。 完善后的UserString类型及演示程序如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//Project - UserStringDeepCopy#include &lt;iostream&gt;#include &lt;string.h&gt;using namespace std;class UserString &#123;private: char* buffer = nullptr; //缓冲区指针 unsigned long long size = 0; //缓冲区大小public: const UserString&amp; operator=(const char* s)&#123; unsigned long long sizeNeeded = strlen(s) + 1; if (size &gt;= sizeNeeded) //缓冲区够用，直接复制 strcpy(buffer,s); else &#123; if (buffer!=nullptr) //缓冲区不够用，重新申请后再复制 free(buffer); size = sizeNeeded; buffer = (char*)calloc(size,1); strcpy(buffer,s); &#125; return *this; &#125; const UserString&amp; operator=(const UserString&amp; r)&#123; if (buffer!=nullptr) free(buffer); size = r.size; if (size&gt;0 &amp;&amp; r.buffer!=nullptr)&#123; buffer = (char*)calloc(size,1); strcpy(buffer,r.buffer); &#125; return *this; &#125; ~UserString()&#123; if (buffer!=nullptr) free(buffer); //释放缓冲区,现在安全了 &#125; UserString(const UserString&amp; r)&#123; size = r.size; if (size&gt;0 &amp;&amp; r.buffer!=nullptr)&#123; buffer = (char*)calloc(size,1); strcpy(buffer,r.buffer); &#125; &#125; UserString()&#123;&#125; //不可或缺 friend ostream&amp; operator&lt;&lt;(ostream&amp;, const UserString&amp;);&#125;;ostream&amp; operator&lt;&lt;(ostream&amp; o, const UserString&amp; r)&#123; o &lt;&lt; r.buffer; return o;&#125;int main() &#123; UserString s1,s2; s1 = \"New coronavirus believed to be derived from bats.\"; s2 = s1; //operator=操作符函数 s2 = \"Human beings will win!\"; cout &lt;&lt; \"s1 = \" &lt;&lt; s1 &lt;&lt; endl; cout &lt;&lt; \"s2 = \" &lt;&lt; s2 &lt;&lt; endl; return 0;&#125; 上述程序的执行结果为： 12s1 &#x3D; New coronavirus believed to be derived from bats.s2 &#x3D; Human beings will win! 相较于16.4中的UserString，本例中的UserString做了如下改进。 第12 ~ 24行：将原有的assign(const char*)函数修改为operator=(const char*)成员函数。第61行、第63行的赋值实际调用了UserString对象的operator=(const char*)成员函数。 第26 ~ 35行：增加了operator=(const UserString&amp;)成员函数，修补了UserString对象赋值时的浅拷贝漏洞。第62行的赋值实际调用了s2对象的operator=(const UserString&amp;)成员函数，以s1为参数。 第54 ~ 57行：增加了全局函数operator&lt;&lt;(ostream&amp;, const UserString&amp;)，赋予了程序通过&lt;&lt;操作符将UserString输出给cout的能力。第64 ~ 65行可见，程序直接把s1和s2通过&lt;&lt;输出给cout。 执行结果证实，第62行s1到s2的赋值成功进行了s1到s2的深拷贝，后续第63行对s2的修改没有影响到s1。 17.7 ++操作符如第3章所述，递增操作符完成两件工作： 将操作数，例如v，增加1； 返回递增之前的v（v++）或递增之后的v（++v）作为表达式的值。 要点🎯 C++以非常特别的方式来区分v++和++v： operator++( )对应++v，先++，后取值； operator++(int)对应v++，先取值，后++。 【？缺：需要理由吗？】 请见下述C++示例程序： 123456789101112131415161718192021222324252627//Project - ComplexDoublePlus#include &lt;iostream&gt;using namespace std;class Complex &#123;public: ... const Complex&amp; operator++()&#123; //对应++c，先++，后取值 dReal += 1.0; return *this; &#125; const Complex operator++(int)&#123; //对应c++，先取值，后++ Complex t = *this; dReal += 1.0; return t; &#125;&#125;;ostream&amp; operator&lt;&lt;(ostream&amp; o, const Complex&amp; c)&#123; ... &#125;int main() &#123; Complex c(1,3); cout &lt;&lt; c &lt;&lt; \" --&gt; \" &lt;&lt; ++c &lt;&lt; endl; //先++,后取值 cout &lt;&lt; c++ &lt;&lt; \" --&gt; \" &lt;&lt; c &lt;&lt; endl; //先取值，后++ return 0;&#125; 上述程序的执行结果为： 121 + 3i --&gt; 2 + 3i2 + 3i --&gt; 3 + 3i 第8 ~ 11行：operator++( )成员函数，对应++c。第24行的++c调用执行了该函数，返回c被递增之后值，对应执行结果的第1行。 第13 ~ 17行：operator++(int)成员函数，对应c++。第25行的c++调用执行了该函数，返回c被递增之前的值，对应执行结果的第2行。 为了返回对象被递增之前的值，第14行先将对象的值保存在临时对象t中，第15行递增对象，第16行返回临时对象t。 注意📢 返回临时对象的引用是十分危险的，安全起见，operator++(int)函数的返回类型为const Complex，返回方式为传值（return by value）。 递减操作符的重载方式与递增类似。 17.8 智能指针在C++里，动态对象的创建是通过new操作符进行的，在恰当的时候通过delete操作符释放动态对象的空间并执行其析构函数是程序员的职责。遗憾的是，多数新手程序员都做不好这项工作，相关的疏失导致了巨量的软件缺陷： 未能释放动态对象，导致内存泄漏。 在内存释放后再次访问指针所指向的动态对象。在释放指针所指向的智能指针后，及时将指针置为空对避免该问题的发生有帮助。 多次释放同一个动态对象。这种情况多发生在两个以上的指针指向同一个动态对象时。 智能指针可以部分解决此问题，以少许效率抽失为代价。本节以shared_ptr为例，简要描述智能指针的使用方法及基本工作原理。请阅读下述C++代码。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//Project - SharedPointer#include &lt;iostream&gt;#include &lt;memory&gt;using namespace std;class Fish &#123;public: string sName; Fish(const string&amp; name)&#123; sName = name; cout &lt;&lt; \"Fish Constructor called: \" &lt;&lt; sName &lt;&lt; endl; &#125; void sayHello()&#123; cout &lt;&lt; \"Aloha: \" &lt;&lt; sName &lt;&lt; endl; &#125; ~Fish()&#123; cout &lt;&lt; \"Fish Destructor called: \" &lt;&lt; sName &lt;&lt; endl; &#125;&#125;;void sayHello(shared_ptr&lt;Fish&gt; f)&#123; f-&gt;sayHello(); //对智能指针使用指向操作符-&gt;&#125;void sayHello(Fish&amp; f)&#123; f.sayHello();&#125;int main()&#123; shared_ptr&lt;Fish&gt; dora1(new Fish(\"Dora\")); shared_ptr&lt;Fish&gt; tom1 = make_shared&lt;Fish&gt;(\"Tom\"); cout &lt;&lt; \"-----------------------------------------\" &lt;&lt; endl; sayHello(tom1); auto tom2 = tom1; //智能指针对象的复制 sayHello(*tom2); //对智能指针使用解引用操作符* cout &lt;&lt; \"-----------------------------------------\" &lt;&lt; endl; dora1-&gt;sayHello(); Fish* dora2 = dora1.get(); //获取智能指针内的原始指针 dora2-&gt;sayHello(); cout &lt;&lt; \"-----------------------------------------\" &lt;&lt; endl; return 0;&#125; 上述程序的执行结果为： 1234567891011Fish Constructor called: DoraFish Constructor called: Tom-----------------------------------------Aloha: TomAloha: Tom-----------------------------------------Aloha: DoraAloha: Dora-----------------------------------------Fish Destructor called: TomFish Destructor called: Dora &lt;memory&gt;头文件引入了共享的智能指针模板类shared_ptr。 要点🎯 shared_ptr&lt;T&gt; 表明一个指向T类型对象的智能指针对象。智能指针对象不是一个平凡的指针，而是一个包含平凡指针的对象，它通过引用计数来记录指针所指向的对象的被引用次数，当被指向对象的引用计数降到0时（意味着动态对象不再被需要），智能指针对象会通过delete操作符或者指定deleter函数释放动态对象。 第6 ~ 21行：为了演示智能指针所管理的动态对象的生命周期，我们设计了Fish类。Fish的构造及析构函数都会向控制台报告构造或析构的消息。 123void sayHello(shared_ptr&lt;Fish&gt; f)&#123; f-&gt;sayHello(); //对智能指针使用指向操作符-&gt;&#125; 第23 ~ 25行：sayHello( )函数接受一个智能指针对象f为参数，然后对f使用指向操作符访问Fish对象的sayHello( )方法。请注意：f是一个智能指针对象，此处的参数传递为传值；第24行的指向操作符事实上执行的是f对象的重载operator-&gt;( )函数。 123void sayHello(Fish&amp; f)&#123; f.sayHello();&#125; 第27 ~ 29行：函数名重载的sayHello( )接受Fish的引用f作为参数，然后执行f的sayHello( )成员函数。 1shared_ptr&lt;Fish&gt; dora1(new Fish(\"Dora\")); 第32行：定义并构建了指向Fish对象的智能指针对象dora1，以动态Fish对象”Dora”的地址作为参数。该行代码执行过程包含如下几步。 dora1是一个自动对象，在栈内为其分配空间； new Fish(“Dora”)在堆内分配对象空间并构造初始化，返回“Dora鱼”的地址； 以new Fish(“Dora”)返回的地址为参数，执行dora1的构造函数。该构造函数将动态对象的地址保存在dora1内部，并将引用计数置为1 - 表明该动态对象当前被1个智能指针对象所“引用”。 执行结果的第1行对应”Dora鱼”的构造输出。 1shared_ptr&lt;Fish&gt; tom1 = make_shared&lt;Fish&gt;(\"Tom\"); 第33行：该行代码的执行包含如下几步。 tom1是一个自动对象，在栈内为其分配空间； make_shared&lt;Fish&gt;(“Tom”)函数创建并构造一个Fish类型的堆对象（以”Tom”为参数），然后构造并返回一个指向该动态对象的shared_ptr&lt;Fish&gt;类型的智能指针； 上述返回的智能指针被拷贝构造给tom1。 注意📢 由于编译器优化的原因，编译器有可能会省掉先构造智能指针再拷贝构造智能指针的不必要步骤，而直接执行tom1的构造函数，以动态Fish对象的指针作为参数。 执行结果的第2行对应”Tom鱼”的构造输出。 1sayHello(tom1); 第36行：将智能指针对象tom1传值给sayHello( )函数（第23行）的形参f，该函数对f应用指向操作符，执行”Tom鱼”的sayHello( )方法。可以想象：当f对象被拷贝构造时，“Tom鱼”的引用计数将由1变2，因为此时tom1和f两个智能指针都指向”Tom鱼“；在sayHello( )函数结束执行前，局部对象f被析构，”Tom鱼“的引用计数则会由2变1。本行的输出见执行结果的第4行。 1auto tom2 = tom1; //智能指针对象的复制 第37行：从tom1拷贝构造tom2。”Tom鱼”的引用计数将由1变2，因为智能指针tom1和tom2都指向”Tom鱼“。 1sayHello(*tom2); //对智能指针使用解引用操作符* 第38行：第27行的sayHello( )函数接受一个Fish&amp;作为参数，通过对tom2使用解引用操作符*，可以获得Fish类型的对象。tom2的类型可以视为Fish*，*tom2的类型则为Fish。事实上，*tom2是通过执行tom2对象的operator*( )操作符函数来实现”解引用“的功能的。本行的输出见执行结果的第5行。 1dora1-&gt;sayHello(); 第41行：对智能指针dora1使用指向操作符，执行”Dora鱼“的sayHello( )方法。如前所述，该指向操作符事实上是通过dora1的operator-&gt;( )操作符函数发挥作用的。本行的输出见执行结果的第7行。 12Fish* dora2 = dora1.get(); //获取智能指针内的原始指针dora2-&gt;sayHello(); 第42 ~ 43行：执行dora1对象的get( )成员函数获取智能指针内部的“原始”指针，然后通过原始指针执行”Dora鱼”的sayHello( )方法。成员操作符”.”证实，dora1是一个对象，而不是一个平凡的指针。相关输出见执行结果的第8行。 到了main( )函数的结尾，自动对象tom2的析构导致“Tom鱼”的引用计数由2变1、tom1的析构则进一步导致引用计数由1变0，这表明”Tom鱼“不再被任何智能指针所引用。在tom1的析构函数里，delete操作符被执行，”Tom鱼”动态对象被释放。执行结果的第10行可见”Tom鱼”的析构输出。 同理，dora1的析构导致”Dora鱼”的释放，执行结果的第11行可见”Dora鱼“的析构输出。 智能指针的使用简化了动态对象的生命周期管理，程序员不必再手动释放动态对象。当最后一个指向该动态对象的智能指针对象被析构时，该动态对象会被释放。大多数情况下，由此所导致的性能损失是可以接受的。 1234567shared_ptr&lt;Fish&gt; p1(new Fish(\"1\")); //1号鱼及其指针p1auto p2 = make_shared&lt;Fish&gt;(\"2\"); //2号鱼及其指针p2p2 = p1; //p2与原引用对象解绑，改为绑定p1所指向的对象p1.reset(); //p1与对象解绑if (p1.get() == nullptr) //解绑后的p1是空指针 cout &lt;&lt; \"p1 is nullptr.\" &lt;&lt; endl;p1.reset(p2.get()); //p1与原对象解绑，改为绑定p2所指向的对象 上述代码进一步演示了shared_ptr的使用方法。 第3行：将p1赋值给p2，这将导致如下结果。 p2与原对象解除绑定，本例中p2是指向原对象的唯一智能指针，原对象即2号鱼被释放； p2改为指向p1所指向的对象。 第4行：p1的reset( )成员函数将解除p1与对象的绑定，解绑后，p1成为“空指针”。 第7行：p1.reset(p2.get( ))的执行导致如下结果。 p1与原绑定对象解绑； p1改为指向p2所指向的对象。 警告🚩 智能指针仅适用于动态（堆）对象，不要对栈对象或者静态对象创建智能指针，因为栈对象和静态对象的生命周期是由编译器自动管理的。 不要通过动态对象的原始指针创建多个互不相关的智能指针。 智能指针的get( )方法所返回的原始指针只可使用，不可应用delete进行释放。如果这样做了，当智能指针析构时，会对同一个动态对象进行第2次释放。 下述代码演示了一些常见的智能指针的错误使用方法： 1234Fish* f = new Fish(\"Peter\"); shared_ptr&lt;Fish&gt; p1(f); auto p2 = p1; //正确 shared_ptr&lt;Fish&gt; p3(f); //错误 第3行：正确，p2的出现仅会导致动态对象引用计数的增加，当且仅当p2和p1都被析构时，“Peter鱼”才会被释放。 第4行：错误，智能指针p3与p1/p2互不相关，它会为”Peter鱼”创建一个新的引用计数。本例中，p1&amp;p2会释放”Peter鱼”，p3也会释放“Peter鱼”，显然，我们不可以杀死同一条鱼两次。 12Fish* p = p3.get(); //p3是个指向Fish对象的智能指针delete p; //错误 第2行：错误，释放p指针所指向的对象后，智能指针p3以及他的表兄弟们，还会再释放一次。同理，不能两次杀死同一条鱼。 读者如果对智能指针的工作机制感到疑惑，请仔细阅读下一节 - 智能指针的实现。 扩展阅读📕 除了shared_ptr，C++标准模板库还实现了unique_ptr、weak_ptr等其它智能指针类型，详情请扫码阅读。【？unique_ptr、weak_ptr】 普通的指针可以指向一个使用new [ ]操作符创建的动态数组，智能指针也可以。 1shared_ptr&lt;float&gt; a(new float[1024]); 无论是new float，还是new float[1024]，所得到的都是float*，也就是说，上述代码中的智能指针a并不知晓其指向的是一个动态对象，还是由多个动态对象构成的数组。根据第8章的讨论，new [ ]所返回的指针必须通过delete [ ]操作符进行释放，显然，上述智能指针a并不知道它所指向是一个动态数组，它只能使用delete而不是delete [ ]来释放对象，这样做有风险。 警告🚩 当使用shared_ptr管理动态对象数组时，要么指定类型为对象数组，要么提供一个删除者（deleter）函数通过delete [ ]释放数组，该函数将在智能指针释放对象时被调用。 下述C++代码演示了确保智能指针安全释放对象数组的方法： 12345678910111213141516171819202122232425262728293031//Project - SharedPtrArray#include &lt;iostream&gt;#include &lt;memory&gt;using namespace std;template &lt;typename T&gt;void delete_array(T* p)&#123; cout &lt;&lt; \"delete_array\" &lt;&lt; endl; delete[] p;&#125;class Fish&#123;public: ~Fish()&#123; cout &lt;&lt; \"Fish::Fish~()\" &lt;&lt; endl; &#125;&#125;;int main()&#123; shared_ptr&lt;Fish[]&gt; a(new Fish[4]); a = nullptr; //a指针指向的数组被释放 shared_ptr&lt;Fish&gt; b(new Fish[2],delete_array&lt;Fish&gt;); b.reset(); //b指针指向的数组被释放 shared_ptr&lt;float&gt; c(new float[512], [](float*p)&#123;cout &lt;&lt; \"lambda function\\n\"; delete[] p;&#125;); *c = 4.4F; //c++; //错误：智能指针不支持指针运算 //c[1] = 99.2F; //错误：智能指针不支持[]操作符 cout &lt;&lt; *c &lt;&lt; endl; return 0;&#125; 上述代码的执行结果为： 123456789Fish::Fish~()Fish::Fish~()Fish::Fish~()Fish::Fish~()delete_arrayFish::Fish~()Fish::Fish~()4.4lambda function 12shared_ptr&lt;Fish[]&gt; a(new Fish[4]);a = nullptr; //a指针指向的数组被释放 第18 ~ 19行：智能指针a的类型中的模板参数被指定为Fish [ ]，这相当于告知a对象，其所管理的是一个元素类型为Fish的动态数组。第19行给指针a赋值为nullptr，将导致a指针释放对象数组。从执行结果的第1 ~ 4行可见，共有4次Fish对象的析构函数执行，这间接说明，对象数组是通过delete [ ]操作符进行的。 12shared_ptr&lt;Fish&gt; b(new Fish[2],delete_array&lt;Fish&gt;);b.reset(); //b指针指向的数组被释放 第21 ~ 22行：智能指针b的构造函数的第2个参数为自定义的删除者函数。该函数是一个通用的模板函数，其通过delete [ ]操作符释放对象数组。执行结果的第5 ~ 7行显示，该函数成功执行，并析构了两个Fish对象。 12shared_ptr&lt;float&gt; c(new float[512], [](float*p)&#123;cout &lt;&lt; \"lambda function\\n\"; delete[] p;&#125;); 第24 ~ 25行：程序为智能指针c提供了一个匿名（lambda）函数作为删除者函数。执行结果的第9行对应该lambda函数的执行输出。自动对象c在main( )函数的结尾被释放并引发了删除者函数的执行。 1//c++; //错误：智能指针不支持指针运算 第27行：如注释所言，智能指针不支持象普通指针那样的指针运算。如果确实需要，只能通过get( )方法获取原始指针后进行。 1//c[1] = 99.2F; //错误：智能指针不支持[]操作符 第28行：同样地，智能指针也不支持普通指针那样的[ ]操作符。 17.9 智能指针的实现本节将实现一个名为SmartPointer的简化版本的shared_ptr模板类。相关C++代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384//Project - SmartPointer#include &lt;iostream&gt;using namespace std;class Fish &#123; ... &#125;; //与前节Fish类实现完全相同template &lt;typename T&gt;class SmartPointer &#123;private: T* ptr; //原始指针 int* refCount; //指向引用计数的指针 void releaseReference()&#123; //释放引用 if (!ptr) return; (*refCount)--; if (*refCount==0)&#123; delete ptr; ptr = nullptr; delete refCount; refCount = nullptr; &#125; &#125;public: SmartPointer(T* p=nullptr)&#123; ptr = p; refCount = new int; *refCount = ptr?1:0; &#125; ~SmartPointer()&#123; releaseReference(); &#125; //拷贝构造函数 SmartPointer(const SmartPointer&amp; r) &#123; cout &lt;&lt; \"Copy constructor of SmartPointer.\" &lt;&lt; endl; ptr = r.ptr; refCount = r.refCount; (*refCount)++; &#125; //重载=操作符 SmartPointer&amp; operator=(const SmartPointer&amp; r)&#123; cout &lt;&lt; \"operator=(const SmartPointer&amp;).\" &lt;&lt; endl; if (&amp;r == this) return *this; releaseReference(); ptr = r.ptr; refCount = r.refCount; (*refCount)++; return *this; &#125; //重载*操作符 T&amp; operator*()&#123; cout &lt;&lt; \"operator*() of SmartPointer.\" &lt;&lt; endl; if (ptr) return *ptr; throw exception(); &#125; //重载-&gt;操作符 T* operator-&gt;()&#123; cout &lt;&lt; \"operator-&gt;() of SmartPointer.\" &lt;&lt; endl; if (ptr) return ptr; throw exception(); &#125; //查询引用计数 int referenceCount()&#123; return *refCount; &#125;&#125;;int main() &#123; SmartPointer&lt;Fish&gt; f1(new Fish(\"Dora\")); SmartPointer&lt;Fish&gt; f2(new Fish(\"Tom\")); auto f3 = f1; //调用f3的拷贝构造函数，以f1为实参 f2 = f1; //调用f2的operator=()函数，以f1为实参，间接导致Tom鱼被释放 (*f2).sayHello(); //调用f2的operator*()函数 f2-&gt;sayHello(); //调用f2的operator-&gt;()函数 cout &lt;&lt; \"Refernce count of Dora fish: \" &lt;&lt; f2.referenceCount() &lt;&lt; endl; return 0;&#125; 上述代码的执行结果为： 1234567891011Fish Constructor called: DoraFish Constructor called: TomCopy constructor of SmartPointer.operator&#x3D;(const SmartPointer&amp;).Fish Destructor called: Tomoperator*() of SmartPointer.Aloha: Doraoperator-&gt;() of SmartPointer.Aloha: DoraRefernce count of Dora fish: 3Fish Destructor called: Dora 类似于第7章中介绍的模板函数，SmartPointer被设计为一个模板类，其类型参数T需要在使用该类时于&lt;&gt;内提供。 123456template &lt;typename T&gt;class SmartPointer &#123;private: T* ptr; //原始指针 int* refCount; //指向引用计数的指针 ... 第7 ~ 11行：SmartPointer对象包含两个私有属性，其中，ptr为指向动态对象的原始指针；refCount则为指向引用计数的指针。如前所述，该引用计数用于记录指向动态对象的存活智能指针对象的个数。 123456789void releaseReference()&#123; //释放引用 if (!ptr) return; (*refCount)--; if (*refCount==0)&#123; delete ptr; ptr = nullptr; delete refCount; refCount = nullptr; &#125;&#125; 第12 ~ 20行：下述情况之一，releaseReference( )成员函数将被调用，以释放该指针对动态对象的引用。 智能指针对象析构时； 智能指针准备绑定其它动象前。 第13 ~ 14行：如果智能指针是空指针，直接返回。 第15行：引用计数递减。 第16 ~ 19行：如果引用计数归零，说明该指针所指向的动态对象已经不被需要，将其释放， 同时释放引用计数。 12345SmartPointer(T* p=nullptr)&#123; ptr = p; refCount = new int; *refCount = ptr?1:0;&#125; 第23 ~ 27行：构造函数接受一个动态对象的指针作为参数。函数体内，原始指针得到保存，引用计数被创建。当ptr是一个空指针时，引用计数置0，否则置1。 123~SmartPointer()&#123; releaseReference();&#125; 第29 ~ 31行：析构函数内调用releaseReference( )函数释放指针对动态对象的引用。如果该智能指针是指向该动态对象的最后一个存活指针，该函数会释放动态对象。 123456SmartPointer(const SmartPointer&amp; r) &#123; cout &lt;&lt; \"Copy constructor of SmartPointer.\" &lt;&lt; endl; ptr = r.ptr; refCount = r.refCount; (*refCount)++;&#125; 第34 ~ 49行：拷贝构造函数。该函数通过复制来初始化一个新的智能指针对象。函数体完成了下述工作： 从源对象复制原始指针及引用计数指针。 引用计数递增，因为又产生了一个新的指向该动态对象的智能指针。 12345678910SmartPointer&amp; operator=(const SmartPointer&amp; r)&#123; cout &lt;&lt; \"operator=(const SmartPointer&amp;).\" &lt;&lt; endl; if (&amp;r == this) return *this; releaseReference(); ptr = r.ptr; refCount = r.refCount; (*refCount)++; return *this;&#125; 第42 ~ 51行：operator=( )操作符函数用于对一个已经存在的智能指针对象进行赋值。 第44 ~ 45行：如果智能指针对象自己赋值给自己，什么也不做，直接返回*this做为表达式的值。请读者注意，a = a这种表达式在语法上是合法的，虽然多数编译器会给出警告信息。 第46行：在绑定到新的动态对象之前，先释放对原动态对象的引用。 第47 ~ 49行：绑定至新的动态对象，递增引用计数。 第50行：返回*this作为表达式的值。 123456T&amp; operator*()&#123; cout &lt;&lt; \"operator*() of SmartPointer.\" &lt;&lt; endl; if (ptr) return *ptr; throw exception();&#125; 第54 ~ 59行：间接操作符*的重载函数。当对一个智能指针使用间接操作符时，该函数会被调用，以获得其所指向的动态对象的引用。 第56 ~ 57行： 如果原始指针不为空，返回所指向的动态对象的引用。 第58行：对一个空指针使用间接操作符是非法的，抛出异常（exception）▲。 123456T* operator-&gt;()&#123; cout &lt;&lt; \"operator-&gt;() of SmartPointer.\" &lt;&lt; endl; if (ptr) return ptr; throw exception();&#125; 第62 ~ 67行：指向操作符-&gt;的重载函数。当对一个智能指针使用指向操作符时，该函数会被调用。该函数预期返回原始指针。 第64 ~ 65行：如果原始指针非空，返回原始指针。 第66行：对一个空指针应用指向操作符是非法的，抛出异常。 123int referenceCount()&#123; return *refCount;&#125; 第70 ~ 72行：查询智能指针所指向的动态对象的引用计数，该引用计数表明当前指向该动态对象的智能指针的数量。 接下来，main( )函数演示了上述SmartPointer类型的使用方法。 12SmartPointer&lt;Fish&gt; f1(new Fish(\"Dora\"));SmartPointer&lt;Fish&gt; f2(new Fish(\"Tom\")); 第76 ~ 77行：创建Dora鱼、Tom鱼及相关智能指针。执行结果的第1 ~ 2行对应两条鱼的构造输出。 1auto f3 = f1; //调用f3的拷贝构造函数，以f1为实参 第78行：f3的拷贝构造函数被执行，以f1为实参。执行结果的第3行对应拷贝构造函数的输出。 1f2 = f1; //调用f2的operator=()函数，以f1为实参，间接导致Tom鱼被释放 第79行：该行代码执行前f2已存在，故f2的operator=( )函数被执行，以f1为实参。执行结果的第4行对应operator=( )函数的输出。当前，f2是指向Tom鱼的唯一智能指针，f2的被赋值将间接导致Tom鱼被释放，执行结果的第5行对应Tom鱼的析构输出。 1(*f2).sayHello(); //调用f2的operator*()函数 第80行：对智能指针f2应用间接操作符以获取f2所指向的动态对象的引用，本行事实上导致了f2的operator*( )函数的执行，该函数出的输出见执行结果的第6行。以返回的Dora鱼对象的引用为基础，sayHello( )成员函数被执行，执行结果的第7行可以看到来自Dora鱼的问候。 1f2-&gt;sayHello(); //调用f2的operator-&gt;()函数 第81行：对智能指针f2应用指向操作符，本行事实上导致了f2的operator-&gt;( )函数的执行，其输出对应执行结果的第8行。以该函数返回的Dora鱼的原始指针为基础，sayHello( )成员函数被执行，执行结果的第9行可再次看到来自Dora鱼的问候。 1cout &lt;&lt; \"Refernce count of Dora fish: \" &lt;&lt; f2.referenceCount() &lt;&lt; endl; 第82行：目前为止，共有f1、f2和f3共三个智能指针指向Dora鱼，referenceCount( )返回Dora鱼的引用计数，其值应为3，见执行结果的第10行。 到了main( )函数的结尾，智能指针f1、f2和f3作为栈对象，相继被析构并释放对Dora鱼的引用。其中，最后一个被析构的智能指针发现Dora鱼的引用计数归零，将其释放。执行结果的第11行，对应Dora鱼的析构输出。 17.10 [ ]操作符我们借助于16.4节中的UserString类型来说明[ ]操作符的重载方法。UserString既然是个字符串，那么通过下标按位置访问字符串中的字符符合类使用者的期望。这可以通过重载[ ]操作符来实现，相关C++程序如下： 12345678910111213141516171819202122232425262728293031323334353637//Project - Subscript...class UserString &#123;private: char* buffer = nullptr; //缓冲区指针 unsigned long long size = 0; //缓冲区大小public: const UserString&amp; operator=(const char* s)&#123; ... &#125; ~UserString()&#123; ... &#125; char&amp; operator[](size_t idx)&#123; return buffer[idx]; &#125; size_t getSize()&#123; return buffer?strlen(buffer):0; &#125; ...&#125;;ostream&amp; operator&lt;&lt;(ostream&amp; o, const UserString&amp; r)&#123; o &lt;&lt; r.buffer; return o;&#125;int main() &#123; UserString s; s = \"Aloha\"; cout &lt;&lt; \"before: \" &lt;&lt; s &lt;&lt; endl; for (size_t i=0;i&lt;s.getSize();i++)&#123; char&amp; c = s[i]; //s[i] 等价于 s.operator[](i) if (c &lt;= 'z' &amp;&amp; c &gt;= 'a') c += 'A' - 'a'; &#125; cout &lt;&lt; \"after: \" &lt;&lt; s &lt;&lt;endl; return 0;&#125; 上述程序的执行结果为： 12before: Alohaafter: ALOHA 本例中，我们为UserString类型定义了两个新的成员函数。 123size_t getSize()&#123; return buffer?strlen(buffer):0;&#125; 第15 ~ 17行：getSize( )函数用于获取UserString对象包含的字符串的长度，当buffer为空时，长度为0。 123char&amp; operator[](size_t idx)&#123; return buffer[idx];&#125; 第11 ~ 13行：重载的operator[ ]操作符函数，形参idx对应[ ]中的下标。该函数返回指定下标的字符的引用。char&amp;的返回类型使用通过[ ]操作符修改字符串内容成为可能。 12345for (size_t i=0;i&lt;s.getSize();i++)&#123; char&amp; c = s[i]; //s[i] 等价于 s.operator[](i) if (c &lt;= 'z' &amp;&amp; c &gt;= 'a') c += 'A' - 'a';&#125; 第30 ~ 34行：通过[ ]操作符逐一访问s字符串内的每一个字符，如果是小写字母，将其修改成大写。 第31行：s[i]对s对象应用[ ]操作符，编译器将其解释为s.operator[ ](i)。由于s[i]返回的是字符的引用，后续对c的修改就是对s[i]的修改。 执行结果证实，上述操作是成功的。 总结🍵 操作符重载并不能给我们带来新的能力，所有通过操作符重载能够完成的工作，都可以通过普通函数来完成。操作符重载能够带给我们的是：更好的代码可读性；更直接的类接口。 要点🎯 操作符重载并不能改变操作符使用的优先级及其基本语法。比如，无论如何重载，+操作符都需要两个操作数，其优先级总是低于乘法操作符。 17.11 类型转换操作符函数事实上，不通过重载&lt;&lt;操作符，也可以将前述UserString对象输出给cout，方法是：为UserString定义一个类型转换操作符函数，允许编译器隐式将其转换成char*类型。而char*类型，正好可以被cout的某个operator&lt;&lt;( )成员函数所接受。示例C++代码如下： 1234567891011121314151617181920212223//Project - TypeConversionOperator...class UserString &#123;private: char* buffer = nullptr; //缓冲区指针 unsigned long long size = 0; //缓冲区大小public: const UserString&amp; operator=(const char* s)&#123; ... &#125; ~UserString() &#123; ... &#125; //将对象转换成char*的操作符函数 operator char*()&#123; return buffer; &#125;&#125;;int main() &#123; UserString s; s = \"Aloha\"; cout &lt;&lt; s &lt;&lt; endl; cout &lt;&lt; s.operator char *() &lt;&lt; endl; return 0;&#125; 上述程序的执行结果为： 12AlohaAloha 第12 ~ 14行：定义了一个类型换转操作符函数，该函数可以将UserString对象转换成char*类型。 第20行：编译器没有发现cout存在接受一个UserString类型参数的operator&lt;&lt;( )函数，但是发现： cout存在一个operator&lt;&lt;(char *)成员函数； s存在一个operator char *( )函数，可以把s转换成char *。 最终，“聪明”的编译器对s进行隐式类型转换，将第20行代码解释成了第21行的样子，这两行代码完全等价，执行结果相同。 一般地， 类型转换操作符函数的语法格式为： 1234operator 类型名()&#123; ... return v; //v必须是要求的类型或者可以隐式类型转换至要求的类型&#125; 下述C++示例为Complex类型增加了一个double类型转换操作符函数： 12345678910111213141516171819202122232425//Project - ComplexToDouble#include &lt;iostream&gt;#include &lt;math.h&gt;using namespace std;class Complex &#123;public: double dReal; double dImage; Complex(double real, double image)&#123; dReal = real; dImage = image; &#125; operator double()&#123; cout &lt;&lt; \"operator double()\" &lt;&lt; endl; return sqrt(dReal*dReal + dImage*dImage); //返回复数的模 &#125;&#125;;int main() &#123; Complex c(1,5); double r = 3 + c; //3 + c等价于3 + c.operator double() cout &lt;&lt; r &lt;&lt; endl;&#125; 上述程序的执行结果为： 12operator double()8.09902 第23行：3 + c试图把一个整数与复数c相加。几乎波折，编译器通过下述方式实现了目标： 将整数3转换成double类型； 通过c的operator double( )类型转换函数，将c隐式转换成double； 两个double对象相加，结果赋值给r。 执行结果证实了operator double( )函数的“隐式”执行。 18. 多态本讲义系重庆大学C/C++课程的教学笔记。 作者： 陈波 chenbo@cqu.edu.cn， All rights reserved. 未经作者许可，不允许经由互联网展示或提供下载。 不允许以纸质出版为目的进行摘抄或改编。 工厂里，生产计划员审核并公布了次月的生产计划（消息）。工厂不同类型的部门和雇员（对象）作出了不同的响应（执行方法）： 采购部门的同事会将生产计划展开成具体的物料清单，并根据物料库存制定并执行物料采购计划； 生产部门的管理者以生产计划为依据，调配设备及人员，作生产做出具体安排； 财务部门的同事会评估完成生产计划所需要耗用的资金，作相应的资金规划； 仓库及物流部门的同事则需要对相应的物料/成品的存储及运输作出规划。 小学校里，上课预备铃响（消息）后，不同类型的参与者（对象）作出了不同的响应（执行方法）： 学生结束游戏，回到教室座位上，等待老师的到来； 教师带上教学资料，走向教室做课前准备； 校长则可能四处巡视，检查纪律及出勤状况。 要点🎯 不同类型的对象在接受到相同消息后，产生不同行为（执行不同方法）的过程，就是多态（polymorphism）。 18.1 早绑定 图18- 宠物继承结构 下述C++代码实现了图18- 所示的继承结构，我们通过对该程序的分析来解释对象成员函数调用的早绑定（early binding）。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//Project - EarlyBinding#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Pet &#123;public: string sName; void sayHello() &#123; cout &lt;&lt; \"Pet \" &lt;&lt; sName &lt;&lt; \" : hello\" &lt;&lt; endl; &#125; Pet(const string&amp; name):sName(name)&#123;&#125; ~Pet()&#123; cout &lt;&lt; \"Pet destructor: \" &lt;&lt; sName &lt;&lt; endl; &#125;&#125;;class Rabbit:public Pet &#123;public: void sayHello()&#123; cout &lt;&lt; \"Rabbit \" &lt;&lt; sName &lt;&lt; \" : carrot\" &lt;&lt; endl; &#125; Rabbit(const string&amp; name):Pet(name)&#123;&#125; ~Rabbit()&#123; cout &lt;&lt; \"Rabbit destructor: \" &lt;&lt; sName &lt;&lt; endl; &#125;&#125;;class Cat:public Pet &#123;public: void sayHello()&#123; cout &lt;&lt; \"Cat \" &lt;&lt; sName &lt;&lt; \" : meow \" &lt;&lt; endl; &#125; Cat(const string&amp; name):Pet(name)&#123;&#125; ~Cat()&#123; cout &lt;&lt; \"Cat destructor: \" &lt;&lt; sName &lt;&lt; endl; &#125;&#125;;int main()&#123; Rabbit r(\"Charlie\"); //查理兔 Pet&amp; r2 = r; r2.sayHello(); Pet* c = new Cat(\"Lucy\"); //露西猫 c-&gt;sayHello(); delete c; return 0;&#125; 上述程序的执行结果为： 12345Pet Charlie : helloPet Lucy : helloPet destructor: LucyRabbit destructor: CharliePet destructor: Charlie 1Rabbit r(\"Charlie\"); //查理兔 第44行：定义并构建一只名为查理的兔子。毫无疑问，这里将执行Rabbit的构造函数，以”Charlie”为参数，因为自动变量r的类型为Rabbit。由于Rabbit是Pet的子类，所以，r的构造函数会调用执行Pet的构造函数以初始化r内部的Pet父对象，详见第25行的构造函数初始化列表。 1Pet&amp; r2 = r; 第45行：定义Pet类型的引用r2，并将其与查理兔r相关联。这在逻辑上是合理的，因为查理兔确实是一只宠物；在语法上，这也是合法的。 1r2.sayHello(); 第46行：执行Pet&amp;类型的变量r2的sayHello( )成员函数。 我们的期望是：r2的类型的Pet&amp;，但它事实上是一只兔子，应该执行Rabbit::sayHello( )函数，以r2的地址为this指针。事实是：Pet::sayHello( )函数被执行，以r2的地址为this指针，请见执行结果的第1行。显然，编译器依据r2的类型Pet&amp;作出了上述决定。 1Pet* c = new Cat(\"Lucy\"); //露西猫 第48行：创建并构造一个Cat类型的堆对象（名为露西的猫），将其指针赋值给Pet*类型的自动对象c。这在逻辑上是合理的，因为露西确实是一只宠物，其地址既是Cat*，也是Pet*；在语法上，这也是合法的。 1c-&gt;sayHello(); 第49行：执行c指针所指向的对象的sayHello( )函数。 我们的期望是：c的类型虽是Pet*，但它事实上指向的是露西猫，应执行Cat::sayHello( )函数，以c值为this指针。事实是：Pet::sayHello( )函数被执行，以c值为this指针，请见执行结果的第2行。显然，编译器依据c的类型Pet*作出了上述决定。理论上，编译器并不知道c指针所指向对象的真正类型，它只知道c指向一只Pet，到底是Rabbit还是Cat，不得而知。 1delete c; 第50行：释放指针c所指向的对象。 我们的期望是：c的类型虽为Pet*，但它事实上指向的是露西猫，应该执行Cat::Cat( )析构函数，以c值为this指针。事实是：Pet::Pet( )析构函数被执行，以c值为this指针，请见执行结果的第3行。同样地，编译器依据c的类型Pet*作出了上述决定。显然，用Pet的析构函数来析构一只猫，很可能意味着错误。 到了main( )函数的结尾，自动对象r被析构，查理兔的析构函数被执行，并引发了查理兔内部的Pet父对象的析构。相关输出见执行结果的第4 ~ 5行。 要点🎯 调用对象的成员函数时，编译器默认执行早绑定（early binding）：在编译时刻，根据变量/常量、指针或者引用的类型直接确定被执行的函数。 具体到本例中的c-&gt;sayHello( )，c的类型为Pet*，其所指向的对象可能是Pet，也可能是Rabbit或者Cat。但编译器仅知道c的类型为Pet*，早绑定的结果就是：选择执行Pet::sayHello( )函数，以c值为this指针。 显然，早绑定没能实现我们期望的多态，虽然c指向的是露西猫，但Cat::sayHello( )没有被执行，我们也没有”听”到喵喵（meow）叫。 对于上述程序，有读者可以会认为：编译器有能力根据上下文”猜”出r2的实际类型为Rabbit&amp;，c的实际类型为Cat*，编译器早绑定函数调用至Pet::sayHello( )不合理。请看下述程序： 1234567891011121314151617//Project - RabbitOrCat...int main() &#123; cout &lt;&lt; \"What do you need ? rabbit or cat ?\"; string s; cin &gt;&gt; s; Pet* p = nullptr; if (s==\"rabbit\") p = new Rabbit(\"Charlie\"); else p = new Cat(\"Lucy\"); p-&gt;sayHello(); delete p; return 0;&#125; 在上述程序中，指针p所指向的对象的真正类型（兔或猫）取决于运行时的用户输入。在编译时刻，编译器只知道p指向的是一只宠物（Pet）！ 18.2 虚函数及晚绑定 要点🎯 在成员函数声明中增加virtual关键字，可以将其声明为虚函数。编译器会对虚函数执行晚绑定（late binding），以实现多态。 请阅读下述C++程序： 12345678910111213141516171819202122232425262728293031323334//Project - VirtualFunction...class Pet &#123;public: string sName; virtual void sayHello() &#123; ... &#125; Pet(const string&amp; name):sName(name)&#123;&#125; virtual ~Pet()&#123; ... &#125;&#125;;class Rabbit:public Pet &#123;public: virtual void sayHello()&#123; ... &#125; //virtual可省略 Rabbit(const string&amp; name):Pet(name)&#123;&#125; virtual ~Rabbit()&#123; ... &#125; //virtual可省略&#125;;class Cat:public Pet &#123;public: virtual void sayHello()&#123; ... &#125; //virtual可省略 Cat(const string&amp; name):Pet(name)&#123;&#125; virtual ~Cat()&#123; ... &#125; //virtual可省略&#125;;int main()&#123; Rabbit r(\"Charlie\"); //查理兔 Pet&amp; r2 = r; r2.sayHello(); Pet* c = new Cat(\"Lucy\"); //露西猫 c-&gt;sayHello(); delete c; return 0;&#125; 上述程序的执行结果为： 123456Rabbit Charlie : carrotCat Lucy : meowCat destructor: LucyPet destructor: LucyRabbit destructor: CharliePet destructor: Charlie 相较于前节中的程序，上述程序的唯一不同：通过在函数声明前添加virtual，把Pet、Rabbit以及Cat三个类的sayHello( )成员函数及析构函数设置为虚函数。 要点🎯 调用对象的成员函数时，如果该成员函数是虚函数，编译器执行晚绑定（late binding）：生成额外的机器指令，在运行时刻确定对象的真正类型，并执行对应类型的对应函数。依赖于晚绑定，不同类型的对象在接受到相同的消息（形式上执行的是同一个方法）后，会表现出不同的行为（执行不同的方法），这就是C++里的多态。 1r2.sayHello(); 第28行：r2的类型为Pet&amp;，Pet的sayHello函数为虚函数，函数调用执行晚绑定。在程序运行时，晚绑定机制发现r2所引用的对象为Rabbit类型，执行Rabbit::sayHello( )函数，以r2的地址为this指针。执行结果的第1行可见来自查理兔的问候。 1c-&gt;sayHello(); 第31行：同理，函数调用执行晚绑定。程序运行时，晚绑定机制发现c所指向的对象为Cat类型，执行Cat::sayHello( )函数，以c值为this指针。执行结果的第2行可见来自露西猫的问候。 1delete c; 第32行：释放指针c所指向的对象隐含了对相应析构函数的调用。同样，晚绑定机制在运行时发现c所指向的对象是Cat类型，执行Cat::~Cat( )析构函数，以c值为this指针。执行结果的第3 ~ 4行来自于露西猫的析构。其中，第4行对应露西猫对象内部的Pet父对象的析构输出。 要点🎯 当父类（Pet）的某个成员函数是虚函数时，其子类（Rabbit、Cat）的对应函数自动成为虚函数。 本例中，Rabbit、Cat类声明中的两个virtual关键字可以省略，不影响结果。 大多数其它语言都是默认执行晚绑定，也就是默认多态，C++是个例外。原因在于，C++视执行效率为生命，通过晚绑定在运行时确定具体执行函数需要花费额外的一丁点儿CPU时间。 18.3 晚绑定原理*多态的实现，依赖于在运行时“确定”对象的实际类型。 要点🎯 当类型拥有至少一个虚函数时： 编译器为每个类型生成一个虚函数表（VTABLE），该表存储了该类全部虚函数的地址； 为每个对象增加一个虚函数表指针（vptr），该指针存储在对象内存的最初8个字节，并指向该对象对应类型的虚函数表。 下述C++程序及其执行结果提供了部分证据： 12345678910111213141516171819202122232425262728//Project - VPTR#include &lt;iostream&gt;using namespace std;class NoVirtual &#123;public: long long iDummy; //占8个字节 ~NoVirtual()&#123; cout &lt;&lt; \"~NoVirtual\" &lt;&lt; endl; &#125;&#125;;class WithVirtual&#123;public: long long iDummy; //占8个字节 virtual ~WithVirtual()&#123; cout &lt;&lt; \"~WithVirtual\" &lt;&lt; endl; &#125;&#125;;int main() &#123; cout &lt;&lt; \"sizeof(NoVirtual) = \" &lt;&lt; sizeof(NoVirtual) &lt;&lt; endl; cout &lt;&lt; \"sizeof(WithVirtual) = \" &lt;&lt; sizeof(WithVirtual) &lt;&lt; endl; WithVirtual a,b; printf(\"&amp;a = %p, &amp;a.iDummy = %p\\n\", &amp;a, &amp;a.iDummy); printf(\"vptr of a = %p, vptr of b = %p\\n\", *(long long*)&amp;a, *(long long*)&amp;b); return 0;&#125; 在作者的计算机上，上述程序的执行结果为： 123456sizeof(NoVirtual) &#x3D; 8sizeof(WithVirtual) &#x3D; 16&amp;a &#x3D; 000000000061fe00, &amp;a.iDummy &#x3D; 000000000061fe08vptr of a &#x3D; 0000000000409960, vptr of b &#x3D; 0000000000409960~WithVirtual~WithVirtual 说明：在读者计算机上，执行结果中的地址很可能与本书不同；如果读者的编译器是32位的，则vptr应为4个字节，而不是8个字节，上述程序需要通过修改（第26行的long long改成int）才能正确执行。 上述代码中的WithVirtual类相对于NoVirtual类的唯一区别是：WithVirtual的析构函数是虚函数。从执行结果的第1 ~ 2行可见，一个WithVirtual对象比一个NoVirtual对象大8个字节。这8个字节存储了指向WithVirtual虚函数表的指针。 12WithVirtual a,b;printf(\"&amp;a = %p, &amp;a.iDummy = %p\\n\", &amp;a, &amp;a.iDummy); 第24 ~ 25行：执行结果的第3行证实，a对象内唯一的数据成员iDummy的存储地址相对于a对象的首地址要靠后8个字节。这说明：虚函数表指针（vptr）存储在对象内存空间的起始处。 1printf(\"vptr of a = %p, vptr of b = %p\\n\", *(long long*)&amp;a, *(long long*)&amp;b); 第26行：将a，b对象的前8个字节，即vptr，当成long long对象，并按地址格式输出。 执行结果的第4行证实，WithVirtual类型的两个对象a和b的vptr的值相同，它们都指向同一个VTABLE，因为它们属于同一个类型。每个对象的vptr，是由编译器生成的隐含代码在构造函数中完成初始化的。 执行结果的第5 ~ 6行对应自动对象a、b的析构输出。 为了进一步解释晚绑定是如何借助于对象的vptr以及类型的VTABLE来实现的，我们编写了下述C++程序： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//Project - LateBinding#include &lt;iostream&gt;using namespace std;class Pet &#123;public: string sName; virtual void sayHello() &#123; cout &lt;&lt; \"Pet \" &lt;&lt; sName &lt;&lt; \" : hello\" &lt;&lt; endl; &#125; virtual void eat(int weight)&#123; cout &lt;&lt; \"Pet: I ate \" &lt;&lt; weight &lt;&lt; \" gram's food.\\n\"; &#125; Pet(const string&amp; name):sName(name)&#123;&#125; virtual ~Pet()&#123; cout &lt;&lt; \"Pet destructor: \" &lt;&lt; sName &lt;&lt; endl; &#125;&#125;;class Rabbit:public Pet &#123;public: void sayHello()&#123; cout &lt;&lt; \"Rabbit \" &lt;&lt; sName &lt;&lt; \" : woof\" &lt;&lt; endl; &#125; void eat(int weight)&#123; cout &lt;&lt; \"Rabbit: \" &lt;&lt; weight &lt;&lt; \" gram's food is not enough!\\n\"; &#125; Rabbit(const string&amp; name):Pet(name)&#123;&#125; ~Rabbit()&#123; cout &lt;&lt; \"Rabbit destructor: \" &lt;&lt; sName &lt;&lt; endl; &#125;&#125;;class Cat:public Pet &#123;public: void sayHello()&#123; cout &lt;&lt; \"Cat \" &lt;&lt; sName &lt;&lt; \" : meow \" &lt;&lt; endl; &#125; Cat(const string&amp; name):Pet(name)&#123;&#125; ~Cat()&#123; cout &lt;&lt; \"Cat destructor: \" &lt;&lt; sName &lt;&lt; endl; &#125;&#125;;int main()&#123; Pet* pets[3] = &#123;nullptr&#125;; pets[0] = new Pet(\"Emily\"); pets[1] = new Cat(\"Lucy\"); pets[2] = new Rabbit(\"Charlie\"); for (auto x:pets)&#123; x-&gt;sayHello(); x-&gt;eat(100); delete x; &#125; return 0;&#125; 上述程序的执行结果为： 1234567891011Pet Emily : helloPet: I ate 100 gram&#39;s food.Pet destructor: EmilyCat Lucy : meowPet: I ate 100 gram&#39;s food.Cat destructor: LucyPet destructor: LucyRabbit Charlie : woofRabbit: 100 gram&#39;s food is not enough!Rabbit destructor: CharliePet destructor: Charlie 图18- pets数组的结构 图18- 描绘了pets数组内的指针所提向的对象的结构，我们对照该图来解释代码。 1pets[0] = new Pet(\"Emily\"); 第52行：创建名为Emily的Pet对象，并将其指针赋值给pets[0]。 由于Pet类型包含虚函数，所以编译器为Pet类型准备了虚函数表（VTABLE），其中依次存储了Pet类型的三个虚函数的地址。 对象Pet Emily内部包含的虚函数表指针（vptr）指向VTABLE - Pet。 1pets[1] = new Cat(\"Lucy\"); 第53行：创建名为Lucy的Cat对象，并将其地址向上类型转换为Pet*，赋值给pets[1]。 由于Pet类型的sayHello( )、eat( )、Pet( )函数为虚函数，其子类Cat的sayHello( )、Cat( )自动成为虚函数。再加上从Pet继承的虚函数eat( )，VTABLE - Cat依次存储了三个虚函数地址。 对象Cat Lucy内部包含的虚函数表指针（vptr）指向VTABLE - Cat。 1pets[2] = new Rabbit(\"Charlie\"); 第54行：创建名为Charlie的Rabbit对象，并将其地址向上类型转换为Pet*，赋值给pets[2]。 同理，Rabbit类型的sayHello( )、eat( )、~Rabbit( )自动成为虚函数，VTABLE - Rabbit依次存储了三个虚函数地址。 对象Rabbit Charlie内部包含的虚函数表指针（vptr）指向VTABLE - Rabbit。 12345for (auto x:pets)&#123; x-&gt;sayHello(); x-&gt;eat(100); delete x; //隐含调用析构函数&#125; 第56 ~ 60行：遍历pets数组，依次执行其所指向的三个对象的sayHello( )、eat( )、及析构函数。 于编译器而言，pets数组的元素类型为Pet*，其所指向的对象到底是Pet、Rabbit或Cat已经不得而知。我们以x-&gt;eat(100)为例（当x为pets[2]时）来说明执行过程。x的类型为Pet*，Pet的eat( )函数为虚函数，编译器生成额外指令执行晚绑定： 通过x指针找到x所指向的对象，即查理兔（Rabbit Charlie），并在其中找到vptr（位于前8个字节）。 通过vptr找到VTABLE - Rabbit。 在VTABLE - Rabbit中找到Rabbit::eat( )函数的地址，并跳转执行。 在虚函数表中，虚函数的地址是按照虚函数的声明顺序依次存储的，所以无论是VTABLE - Pet，VTABLE - Cat或是VTABLE - Rabbit，eat( )函数的地址都位于该表的第1项（从0开始计数）。如果把虚函数表指针视为一个函数指针数组，那么eat( )函数的地址就是vptr[1]。实际上，上述晚绑定过程即是通过此种方式来确定函数跳转地址的。 执行结果证实，借助于虚函数和晚绑定，多态得以实现。编译时刻，x-&gt;sayHello( )被调用时，虽然并不清楚x的具体类型，但到了运行时，借助于对象内部的虚函数表指针及对应类型的虚函数的表，正确的方法得以执行。不同类型的对象在收到相同消息时表现了不同的行为，露西猫说“喵”（meow），查理兔就知道要胡萝卜（carrot）。 18.4 运行时类型识别*当类型包含虚函数时，对象内部的虚函数表指针（vptr）使得运行时对象类型识别（runtime type identification，简写为RTTI）成为可能。在包含虚函数的情况下，同一个类型的所有对象都包含相同vptr，指向同一个虚函数表。 要点🎯 可以通过操作符typeid( )在运行时判断对象的实际类型。typeid(x)中的操作数（operand）x既可以是类名，也可以是对象，它返回一个type_info类型的对象，表明操作数的类型。当操作数是对象时，如果对象的编译时类型包含虚函数，typeid( )操作符通过对象的vptr判断对象的运行时类型；如果对象的编译时类型不包含虚函数，对象内并不存在vptr，无法进行运行时类型识别，typeid( )直接返回对象的编译时类型作为结果。 其中，type_info类型由头文件typeinfo引入。 C++示例程序如下： 1234567891011121314151617181920212223242526//Project - RTTI#include &lt;iostream&gt;#include &lt;typeinfo&gt;using namespace std;class Shape&#123;public: ~Shape()&#123;&#125;&#125;;class Circle:public Shape&#123;&#125;;class Pet&#123;public: virtual ~Pet()&#123;&#125;&#125;;class Rabbit:public Pet&#123;&#125;;int main()&#123; Shape *s = new Circle(); if (typeid(*s) == typeid(Shape)) cout &lt;&lt; \"s points to a shape.\" &lt;&lt; endl; if (typeid(*s) == typeid(Circle)) cout &lt;&lt; \"s points to a circle.\" &lt;&lt; endl; Pet *p = new Rabbit(); if (typeid(*p)==typeid(Pet)) cout &lt;&lt; \"p points to a pet.\" &lt;&lt; endl; if (typeid(*p)==typeid(Rabbit)) cout &lt;&lt; \"p points to a rabbit.\" &lt;&lt; endl; return 0;&#125; 上述程序的执行结果为： 12s points to a shape.p points to a rabbit. 图18- RTTI的继承结构 我们结合图18- 来解释上述程序的执行过程及结果。在两个继承结构里，Shape - Circle类型不存在析构函数，Pet - Rabbit类型存在析构函数。 1Shape *s = new Circle(); 第13行：创建一个Circle类型的对象，并将其地址向上类型转换为Shape*，赋值给s。 12if (typeid(*s) == typeid(Shape)) cout &lt;&lt; \"s points to a shape.\" &lt;&lt; endl; 第14 ~ 15行：s的编译时类型为Shape*，*s的编译时类型为Shape。对于typeid( )操作符而言，Shape类型不包含虚函数，对象*s内没有vptr可以利用，故typeid( )直接返回其编译时类型Shape，逻辑判断成立，第15行被执行，其输出对应执行结果第1行。 12if (typeid(*s) == typeid(Circle)) cout &lt;&lt; \"s points to a circle.\" &lt;&lt; endl; 第16 ~ 17行：如上所述，typeid(*s)返回的是*s的编译时类型Shape，逻辑判断不成立，第17行没有执行。 1Pet *p = new Rabbit(); 第19行：创建一个Rabbit类型的对象，并将其地址向上类型转换为Pet*，赋值给p。 12if (typeid(*p)==typeid(Pet)) cout &lt;&lt; \"p points to a pet.\" &lt;&lt; endl; 第20 ~ 21行：对象*p的编译时类型为包含虚函数的Pet，typeid( )通过对象*p内部的vptr进行运行时类型识别，得到其真实的类型Rabbit。虽然Rabbit是Pet的子类，但Rabbit不等于Pet，上述逻辑判断不成立，第21行未执行。 12if (typeid(*p)==typeid(Rabbit)) cout &lt;&lt; \"p points to a rabbit.\" &lt;&lt; endl; 第22 ~ 23行：如上所述，借助于过行时类型识别（RTTI），typeid(*p)返回了*p的运行时类型（即事实类型）Rabbit。上述逻辑判断成立，第23行被执行，其输出对应执行结果的第2行。 18.5 类型转换C语言风格的显式类型转换是有风险的，相当于程序员直接告诉编译器：忘掉你的类型检查，把这个对象当成另外一个类型来处理。无论这种转换是不是合理的，编译器都会照单全收。不恰当的类型转换的后果需要到运行时才“可能”体现出来。 为尽量避免上述问题，【C++】提供了4种显式类型转换语法，本节逐一进行介绍。 18.5.1 static_cast按照下述语法，static_cast可以完成那些”合理“的类型转换。 1static_cast&lt;目标类型&gt;(对象) 所谓”合理“的类型转换包括基本C/C++数据类型的转换： 12345int v = 77;long long ll = static_cast&lt;long long&gt;(v);//int --&gt; long longfloat f = static_cast&lt;float&gt;(v); //int --&gt; floatunsigned char uc = static_cast&lt;unsigned char&gt;(v); //允许但有风险//float* p = static_cast&lt;float*&gt;(&amp;v); //错误:int* --&gt; float* 第4行：从int转换成unsigned char，可以由static_cast完成，但因为类型收窄（narrowing）的原理，有极大的数据失真的风险。 第5行：不允许基本数据类型指针之间的static_cast类型转换，这种转换只能通过reinterpret_cast进行。本例中，将int*转换成float*，涉及到彻底的数据的重新解释，强制程序员使用reinterpret_cast，相当于强制程序员重新审视这种转换的合理性与必要性。 此外，static_cast也可以在具有继承关系的类型之间进行转换： 12345678910class Pet&#123;&#125;;class Cat:public Pet&#123;&#125;;class Dog:public Pet&#123;&#125;;... Cat c; Pet p = static_cast&lt;Pet&gt;(c); //Cat --&gt; Pet Pet&amp; p1 = static_cast&lt;Pet&amp;&gt;(c); //Cat --&gt; Pet&amp; Pet* p2 = static_cast&lt;Pet*&gt;(&amp;c); //Cat* --&gt; Pet* Cat* c1 = static_cast&lt;Cat*&gt;(p2); //Pet* --&gt; Cat*, 允许但不安全 //Cat c2 = static_cast&lt;Cat&gt;(p); //错误:Pet --&gt; Cat 第8行：Cat*向上类型转换（upcasting）为Pet*，是安全的，因为Cat是Pet的子类。 第9行：Pet*向下类型转换（downcasting）为Cat*，static_cast允许这种向下类型转换，并不意味着这是安全的。因为p2所指向的对象，可能是Dog，不是Cat。安全的向下类型转换，建议使用dynamic_cast。 第10行：不支持Pet至Cat类型的转换。在本例中，p虽然来自Cat c，但因为对象切片（object slicing）的原因，p只包含了对象c内的Pet部分，static_cast不支持这种转换具有合理性。 18.5.2 const_cast按照下述语法，const_cast可以将常量型转换成对应的非常量型。 1const_cast&lt;非常量目标类型&gt;(对象) 示例如下： 123456789class Cat&#123;&#125;;... const Cat cat; Cat&amp; c = const_cast&lt;Cat&amp;&gt;(cat); //const Cast --&gt; Cat&amp; const int v = 777; int v1 = v; //const int --&gt; int,无转换必要 int&amp; r = const_cast&lt;int&amp;&gt;(v); //const int --&gt; int&amp; int* p = const_cast&lt;int*&gt;(&amp;v); //const int* --&gt; int* 第7行：将一个常量型对象转换成一个同类型的非常量对象，直接赋值即可办到，没有进行显示类型转换的必要。 第8行：为const int类型的对象v创建非常量型引用r，这事实上破坏了v的常量性，因为通过引用r，可以达到修改v的目的。 第9行：v的类型为const int， &amp;v的类型为const int*，即指向const int的指针。本行代码将&amp;v转换成int*并赋值给p，同样破坏了v的常量性：可以通过指针p来修改v值。 警告🚩 没有十分特别的站得住脚的理由时，不要使用const_cast！ 将对象声明为常量型，相当于给程序的阅读者、编译器以及与你一起工作的同事许下了一个诺言：我不会修改这个对象。而通过const_cast去除其常量性，相当于偷偷地违背了自己许下的诺言。这很可能成为bug（软件缺陷）之源。 在重用他人代码的前提下，如果不得不使用，一定要给以特别的注释，并在注释及软件文档中说明理由。 18.5.3 reinterpret_cast按照下述语法，可以将一个类型的对象重新解释成另一个类型的对象： 1reinterpret_cast&lt;目标类型&gt;(对象) 示例如下： 1234567891011//Project - ReinterpretCast#include &lt;iostream&gt;using namespace std;int main()&#123; unsigned int v = 0x11223344; unsigned char* rawBytes = reinterpret_cast&lt;unsigned char*&gt;(&amp;v); printf(\"bytes of v: %x - %x - %x - %x\", rawBytes[0],rawBytes[1],rawBytes[2],rawBytes[3]); return 0;&#125; 上述程序的执行结果为： 1bytes of v: 44 - 33 - 22 - 11 第7行：将4字节的整数v的地址重新解释转换成char*。 第8行：逐一将变量v的四个字节的值按十六进制输出。可以看到，在作者的x86计算机上，低字节（0x44）在低地址。 由于reinterpret_cast会导致程序以完全不同的方式来解释对象的原有内存，所以使用时应十分谨慎。 18.5.4 dynamic_cast*在一个继承关系中，如果将子类对象的地址或者引用转换为父类对象的指针或引用，称之为向上类型转换（upcasting）。这种转换是安全的。 但如果反过来，把一个父类对象的指针或者引用转换成子类对象的指针或引用，则称之为向下类型转换（downcasting）。这种转换有风险，应通过dynamic_cast进行。 按照下述语法，可以将父类对象的指针或者引用转换为子类对象的指针或引用： 1dynamic_cast&lt;目标类型&gt;(对象指针/引用) 注意📢 dynamic_cast依赖于RTTI在运行时识别对象的实际类型，而RTTI的实现，又依赖于对象内部的虚函数表指针vptr。因此，上述“对象”的编译时类型必须包含虚函数，否则，编译器会报错。 C++示例程序如下： 1234567891011121314151617181920212223242526//Project - DynamicCast#include &lt;iostream&gt;using namespace std;class Pet&#123;public: virtual ~Pet()&#123;&#125;&#125;; //Pet父类有虚函数class Cat:public Pet&#123;public: void sayHello()&#123; cout &lt;&lt; \"meow\" &lt;&lt; endl; &#125;&#125;;class Dog:public Pet&#123;&#125;;int main() &#123; Pet* p = new Cat(); Cat* c = dynamic_cast&lt;Cat*&gt;(p); //指针转换失败会返回一个nullptr if (c)&#123; c-&gt;sayHello(); &#125; Cat&amp; c1 = dynamic_cast&lt;Cat&amp;&gt;(*p); //类型转换失败会抛出一个std::bad_cast异常 c1.sayHello(); delete p; return 0;&#125; 上述程序的执行结果为： 12meowmeow 第16行：将Pet*类型的指针p转换成Cat*类型的指针c。dynamic_cast会检查p所指向的对象内部的vptr进行运行行类型识别，如果对象的实际类型是Cat或者是Cat的子类型，则转换成功。否则，dynamic_cast会返回空指针nullptr。本例中，p指向的事实上是个Cat对象，转换成功。 第17行：如果指针c非空，则说明转换成功，c可以被使用。 第21行：同理，dynamic_cast通过检查*p对象内部的vptr进行运行行类型识别。如果转换失败，则一个类型为std::bad_cast的异常▲会被抛出。 18.6 纯虚函数及抽象类* 图18- 抽象类继承结构 在上述继承结构中，为Pet类型的speak( )方法提供函数体可能毫无用处：① 你养的宠物，要么是狗、要么是猫、或者其他动物，不存在不是狗、不是猫、不是蛇或者其他动物的纯粹的宠物；② 狗、猫、兔子的叫声各不相同，即Pet的各个子类，会实现各自独立的speak( )虚函数。 基于以上考量，可以将Pet类的部分虚函数定义纯虚函数（pure virtual function），从而使得Pet类型成为抽象类（abstract class）。纯虚函数的定义方法是在成员函数声明中用添加”= 0”，并省略其函数体定义。 要点🎯 将成员函数定义为纯虚函数可以获得两方面的收益： ① 避免为不必要地为函数提供函数体。 ② 使得类成为不可实例化的抽象类。所谓不可实例化，即是指你不可以直接创建这个类的对象。 下述C++代码定义了图18- 所示的Pet抽象类： 1234567891011121314//Project - AbstractClass...class Pet &#123;protected: string sName;public: void virtual speak() = 0; //=0表示该函数为纯虚函数 void virtual eat(int weight) = 0; Pet(const string&amp; name):sName(name)&#123;&#125; virtual ~Pet()&#123;&#125;&#125;;... //Pet p(\"Emily\"); //Pet* p = new Pet(\"Emily\"); //错误：抽象类不可以实例化 上述Pet类有两个纯虚函数，分别为第7行的speak( )以及第8行的eat( )。作为包含纯虚函数的抽象类，Pet类型不可以被实例化，上述代码的第13行、第14行都会被编译器拒绝。 要点🎯 抽象基类的纯虚函数需要在其扩展类中被实现/定义。当且仅当所有基类的纯虚函数都被实现后，扩展类才可能被实例化。 下述C++代码实现了图18- 中所示的Rabbit类型： 123456789101112131415161718192021//Project - AbstractClass...class Pet &#123;...&#125;;class Rabbit:public Pet &#123;public: void speak()&#123; cout &lt;&lt; \"Hello from rabbit \" &lt;&lt; sName &lt;&lt; endl; &#125; void eat(int weight)&#123; cout &lt;&lt; \"Rabbit \" &lt;&lt; sName &lt;&lt; \" ate \" &lt;&lt; weight &lt;&lt; \" gram's food.\\n\"; &#125; Rabbit(const string&amp; name):Pet(name)&#123;&#125;&#125;;... Pet* r = new Rabbit(\"Eddie\"); r-&gt;eat(100); r-&gt;speak(); delete r; 上述代码执行结果（局部）为： 12Rabbit Eddie ate 100 gram&#39;s food.Hello from rabbit Eddie 第7 ~ 13行：Rabbit类型为Pet父类的两个纯虚函数speak( )以及eat( )提供了函数体，也称为实现了这两个纯虚函数。 由于不存在未实现的纯虚函数，Rabbit类不是抽象类，可以直接创建Rabbit类型的对象。 第18行：创建名为Eddie的Rabbit对象，并将其地址向上类型转换为Pet*，赋值给r。 第19 ~ 20行：通过Pet*类型的指针r，通过晚绑定调用执行Eddie兔的eat( )及speak( )函数。执行结果证实，Eddie兔的相关代码被执行。 下述C++代码实现了图18- 所示的Cat类型： 123456789101112131415//Project - AbstractClass...class Pet &#123;&#125;...class Cat:public Pet&#123;public: void eat(int weight)&#123; cout &lt;&lt; \"Cat \" &lt;&lt; sName &lt;&lt; \" ate \" &lt;&lt; weight &lt;&lt; \" gram's food.\\n\"; &#125; Cat(const string&amp; name):Pet(name)&#123;&#125;&#125;;... //Cat c(\"Lucy\"); //Pet* c = new Cat(\"Lucy\"); //错误：抽象类Cat不可以实例化 上述代码中的Cat类仅实现了基类Pet的一个纯虚函数eat( )，未实现另一个纯虚函数speak( )，因此Cat类型仍为抽象类，不可以被实例化。第14行、第15行代码会被编译器拒绝。 下述C++代码实现了图18- 所示的DragonLi（狸花猫）及Persian（波斯猫）类型： 123456789101112131415161718192021222324252627282930//Project - AbstractClass#include &lt;memory&gt;...class Pet &#123;...&#125;;class Cat:public Pet&#123;...&#125;;class DragonLi:public Cat&#123;public: void speak()&#123; cout &lt;&lt; \"Hello from dragonli cat \" &lt;&lt; sName &lt;&lt; endl; &#125; DragonLi(const string&amp; name):Cat(name)&#123;&#125;&#125;;class Persian:public Cat&#123;public: void speak()&#123; cout &lt;&lt; \"Hello from persian cat \" &lt;&lt; sName &lt;&lt; endl; &#125; Persian(const string&amp; name):Cat(name)&#123;&#125;&#125;;... shared_ptr&lt;Pet&gt; c1(new DragonLi(\"Happy\")); unique_ptr&lt;Cat&gt; c2(new Persian(\"Socks\")); c1-&gt;eat(100); c1-&gt;speak(); c2-&gt;eat(100); c2-&gt;speak(); 上述代码执行结果（局部）为： 1234Cat Happy ate 100 gram&#39;s food.Hello from dragonli cat HappyCat Socks ate 100 gram&#39;s food.Hello from persian cat Socks DragonLi及Persian各自实现了纯虚函数speak( )，其基类Cat实现了纯虚函数eat( )。因此，DargonLi及Persian的基类的纯虚函数全部得以实现，它们不是抽象类，可以实例化。 第25 ~ 26行：创建名为Happy的狸花猫及名为Socks的波斯猫动态对象，并将其地址交给智能指针管理。本例中，c1为指向Pet对象的shared_ptr类型智能指针，c2为指向Cat对象的unique_ptr类型智能指针。 第27 ~ 30行：通过智能使用分别执行两只猫的eat( )及speak( )方法，由于晚绑定的关系，“正确”的方法被调用执行。在执行结果中可以看到相关输出。 当作为自动变量的智能指针对象c1和c2超过作用域时，其析构函数会释放两个猫对象，手工delete不再被需要。 18.7 多态应用举例* 要点🎯 抽象类的最大用途在于为所有的扩展类定义一个统一的接口（interface）。 想象一个Word类软件，WPS或者Open Office之类，在文档中，用户会加入非常多的界面元素，包括但不限于：三角形、箭头、段落、圆形、矩形、艺术字、图片。在面向对象程序设计中，这些元素都会使用类来描述，并且，设计者一定会为这些界面元素提供一个统一的父类。作者把这个类结构简化成图18- 的模样，读者要明白真实的情况比这个要复杂得多，但基本结构大体如此。 图18- Shape继承结构 可以看到，所有的界面元素，三角形、圆形、… 、 文本段落（paragraph），被描述成拥有一个共同的祖先类（Shape）。这个祖先类可以是抽象类，这意味着系统不允许你创建Shape类的对象。抽象类什么具体的工作也不做，只是描述了他的全部后代的模样：至少实现描绘自身的draw( ）以及获取元素在页面中的空间尺寸的getSize( )这两个方法。这种描述是强制性的，它的后代必须实现这两个方法或函数。 Triangle类用三个点坐标来描述自己的属性，除了实现必须的draw()和getSize()方法外，还实现了一个getArea()方法以计算自身所占面积。 Circle类则用一个圆点坐标以及一个半径来描述自己，也实现了额外的getArea()函数。 文本段落（Paragraph）类则用一个字符串sContent来存储其文本内容，另外，还额外实现了setFont()函数来设置文本的字体和字号。 下述C++代码给出了上述继承结构的极简版实现： 1234567891011121314151617181920212223242526272829303132//Project - Word...class Shape &#123;public: //virtual Size getSize() = 0; virtual void draw() = 0; virtual ~Shape()&#123;&#125;&#125;;class Triangle:public Shape&#123;public: //point0, point1, point2 //Size getSize(...) //float getArea(...) void draw()&#123; cout &lt;&lt; \"Triangle::draw()\" &lt;&lt; endl; &#125;&#125;;class Circle:public Shape&#123;public: //ptCenter, iRadius //Size getSize(...) //float getArea(...) void draw() &#123; cout &lt;&lt; \"Circle::draw()\" &lt;&lt; endl; &#125;&#125;;class Paragraph:public Shape&#123;public: string sContent; //Size getSize(...) //void setFont(...) void draw()&#123; cout &lt;&lt; \"Paragraph::draw()\" &lt;&lt; endl; &#125;&#125;; 让我们把关注点放在这三个类的draw()函数上。Office类软件会用文档来组织这些界面元素，在这里我们把文档想像成一个数组，在这个数组包含了很多个三角形、矩形、段落、图片、艺术字、公式、图表对象，这些对象都是Shape类的子对象，都实现了draw()方法。 当一个页面被显示出来时，软件会遍历这个数组，然后逐一调用数组内Shape子对象的draw()方法，以便把每个界面元素画出来。对，你听得没错，就是每个对象自己画自己。因为三角形类了解三角形的数据表达形式，掌握描绘一个三角形的全部信息，由这个类的draw()来承担这个职责再合适不过了。圆形、段落这些类也是类似情况。我们设想一下，假设在页面上描绘三角形的任务不是由三角形类来完成，而是由外部代码来完成，那么外部代码就必须清楚并访问三角形对象内部的全部细节，如果这件事情真的发生的话，对于软件工程而言是灾难性的：外部代码知道太多关于三角形内部实现的细节！ 内部实现的细节变成了接口的一部分！ 三角形类接口不再简洁明了！ 以后你如果想修改三角形的内部数据结构，这几乎不可能，因为外部代码也要跟着改，涉及的外部程序和修改点可能太多 。这种复杂的情况，我们称之为紧耦合（tight coupling）。而程序的松散耦合（loose coupling），才是我们的目标。 我们通过下述C++程序来模拟一个文档内的全部界面元素被逐一绘制的场景： 1234567891011121314151617//Project - Word...void renderDocument(Shape* shapes[], int n)&#123; for (auto i=0; i&lt;n;i++) shapes[i]-&gt;draw();&#125;int main()&#123; Shape* shapes[] = &#123;new Triangle(),new Triangle(),new Circle(), new Circle(), new Paragraph()&#125;; renderDocument(shapes,5); for (auto x:shapes) delete x; return 0;&#125; 上述程序的执行结果为： 12345Triangle::draw()Triangle::draw()Circle::draw()Circle::draw()Paragraph::draw() 在这段代码里，我们创建了两个三角形，两个圆形，一个段落 ，然后把它们放入一个数组中，这个数组就是一个文档的简化表达形式。renderDocument( )函数遍历这个数组，逐一执行其元素的draw( )方法。我们看到，renderDocument()函数并不清楚数组元素shapes[i]的具体类型，它只认为它是指向Shape对象的指针，而Shape对象实现了draw()方法，至于该对象到底是三角形、圆形或者别的什么界面元素，完全不关心。但是，我们发现，shapes[i]指向什么类型，就会执行对应类型的draw()函数，并打印出对应的文字。这就是多态，这些变量类型未知，但自动展现出与类型对应的恰当行为。 本节展示的类结构为程序的扩展提供了无限的可能及便利。如果Office软件试图建立一种全新的界面元素，比如某种直方图图表，软件设计者所要做的，就是继承Shape类并设计一个新的类，然后在新的类里实现全部虚函数。然后，上述renderDocument( )函数一个字符都不用修改，即可以拥抱新的界面元素的加入所带来的变化，以不变应万变！ 想想一下没有多态时的可怕场景，上述renderDocument( )函数可能需要修改成下述伪代码所描述的模样： 1234567891011121314void renderDocument(Shape* shapes[], int n)&#123; for (auto i=0; i&lt;n;i++)&#123; x = shapes[i]; if x 指向的是三角形 执行三角形的draw函数 else if x 指向的是圆形 执行圆形的draw函数 else if x 指向的是矩形 执行矩形的draw函数 ... else if x 指向的是艺术字 执行艺术字的draw函数 &#125;&#125; 就Word而言，其界面元素类型多达数百种甚至更多，上述第10行的省略号的背后，可能是上千行效率极其低下的难以维护的多分支代码。 19. 容器与模板用数组，即便是动态数组，来保存对象有一个很大的局限：难以准确估计需要的数组空间。如果将数组定义得过大，可能浪费内存，如果定义得过小，又存在容量不足的可能。 要点🎯 容器（container）类对象可以像数组那样容纳其它对象。数组的容量是固定的，而容器类对象（模板数组▲除外）的容量可以需要自动伸缩。 表19-1列出了标准模板库中的容器类型及其特点，本章将介绍主常用的几种。 表19-1 容器类型 类型名 特点 vector/向量 尺寸可伸缩的“数组”，可以快速地随机存取元素值。当在特定位置（尾部除外）删除或插入无素时，速度较慢。 array/数组 固定元素个数的数组，可以快速随机存取元素值。不支持插入或者删除元素。 string/字符串 用于包含字符的特殊向量，可以快速地随机存取元素值。当在特定位置（尾部除外）删除或插入无素时，速度较慢。 deque/双端队列▲ 可以快速随机存取元素值。在头部/尾部插入、删除元素速度较快。 list/双向链表▲ 不可以随机存取元素，仅支持双向的顺序元素存取。可以快速地在任意位置插入、删除元素。 forward list/前向链表▲ 不可以随机存取元素，仅支持前向的顺序元素存取。可以快速地在任意位置插入、删除元素。 19.1 向量向量（vector）类型来自于标准模板库（standard template library），由vector头文件引入。其工作方式与数组类似，主要区别有二：元素类型由模板参数指定；容量根据使用需要自动伸缩。 123vector&lt;string&gt; v1; //元素类型为string的向量vector&lt;int&gt; v2; //元素类型为int的向量vector&lt;Fish*&gt; v3; //向量，其元素类型为Fish*，即指向Fish对象的指针 上述代码定义了三个向量，其存储的元素类型各不相同。当向量刚被创建时，默认为空，即不包含任何元素。 我们通过下述C++示例程序来简单解释向量的用法。在本章随书代码的WordsCount项目目录下，有一个名为title.txt的文本文件，其内容是一首美丽的诗： 12345678910111213141516When you are old--- William Butler YeatsWhen you are old and grey and full of sleep,And nodding by the fire, take down this book,And slowly read, and dream of the soft lookYour eyes had once, and of their shadows deep;How many loved your moments of glad grace,And loved your beauty with love false or true,But one man loved the pilgrim soul in you,And loved the sorrows of your changing face;And bending down beside the glowing bars,Murmur, a little sadly, how Love fledAnd paced upon the mountains overheadAnd hid his face amid a crowd of stars. 我们通过程序来对这首诗进行词频统计：找出这首诗中的全部单词并统计该单词在诗中出现的次数。程序如下： 12345678910111213141516171819202122232425262728293031323334//Project - WordsCount#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;fstream&gt;#include &lt;assert.h&gt;using namespace std;int main() &#123; ifstream in(\"C:/C2Cpp/C19_Container/WordsCount/title.txt\"); vector&lt;string&gt; words; //words[i]存放发现的第i个单词 vector&lt;int&gt; counts; //counts[i]存放words[i]在诗中的出现次数 string sWord; while (in &gt;&gt; sWord)&#123; //operator&gt;&gt;(in,sWord) for (size_t i=0;i&lt;words.size();i++)&#123; if (words[i]==sWord)&#123; counts[i]++; sWord = \"\"; break; &#125; &#125; if (sWord!=\"\")&#123; words.push_back(sWord); counts.push_back(1); &#125; &#125; assert(words.size()==counts.size());//断言向量words及counts长度相等 for (size_t i=0;i&lt;words.size();i++)&#123; cout &lt;&lt; words[i] &lt;&lt; \":\" &lt;&lt; counts[i] &lt;&lt; \", \"; &#125; return 0;&#125; 上述程序的执行结果为： 1When:2, you:2, are:2, old:2, ---:1, William:1, Butler:1, Yeats:1, and:4, grey:1, full:1, of:6, sleep,:1, And:7, nodding:1, by:1, the:6, fire,:1, take:1, down:2, this:1, book,:1, slowly:1, read,:1, dream:1, soft:1, look:1, Your:1, eyes:1, had:1, once,:1, their:1, shadows:1, deep;:1, How:1, many:1, loved:4, your:3, moments:1, glad:1, grace,:1, beauty:1, with:1, love:1, false:1, or:1, true,:1, But:1, one:1, man:1, pilgrim:1, soul:1, in:1, you,:1, sorrows:1, changing:1, face;:1, bending:1, beside:1, glowing:1, bars,:1, Murmur,:1, a:2, little:1, sadly,:1, how:1, Love:1, fled:1, paced:1, upon:1, mountains:1, overhead:1, hid:1, his:1, face:1, amid:1, crowd:1, stars.:1, 说明：第9行中的”C:/C2Cpp/C19_Container/WordsCount/title.txt”是title.txt在作者计算机上的完整路径，读者运行上述程序时，可能需要根据实际情况作出修改。 1#include &lt;vector&gt; 第3行：vector头文件引入向量类型，其属于标准模板库（standard template library）的构成部分。 1#include &lt;fstream&gt; 第4行：fstream是文件流（file stream）头文件，本例中，其引入的ifstream类型用于读入文本文件的内容。 1#include &lt;assert.h&gt; 第5行：引入断言（assertion）宏（macro）。 1ifstream in(\"C:/C2Cpp/C19_Container/WordsCount/title.txt\"); 第9行：定义一个输入文件流（input file stream）对象in，该对象会打开参数字符串所指明的文本文件。在后续代码中，可以从该输入文件流读取内容，就像从控制台输入流（cin，即console input stream）读取内容一样。 12vector&lt;string&gt; words; //words[i]存放发现的第i个单词vector&lt;int&gt; counts; //counts[i]存放words[i]在诗中的出现次数 第10 ~ 11行：定义了向量words及counts，其含义见代码注释。向量的逻辑上与数组非常相似，words[i]代表向量内存储的第i个元素。在程序运行过程中，words和counts的元素个数应是相等的。 123while (in &gt;&gt; sWord)&#123; //operator&gt;&gt;(in,sWord)...&#125; 第14 ~ 26行：循环从输入文件流读入一个字符串（以空格作为分隔符），并进行处理。其中，in &gt;&gt; sWord等价于operator&gt;&gt;(in, sWord)，当in中的全部内容都被读取完毕后，该操作符函数将返回False并导致循环结束。 1234567for (size_t i=0;i&lt;words.size();i++)&#123; if (words[i]==sWord)&#123; counts[i]++; sWord = \"\"; break; &#125;&#125; 第15 ~ 21行：读取到一个单词（字符串）sWord后，先在向量对象words中进行查找。 成员函数size( )返回向量内保存的元素个数，其返回类型为size_t，在作者的计算机上，size_t即为unsigned long long。使用无符号长整数来表示向量的元素个数具有一定的合理性，因为元素数量不可能为负。 words[i]表示向量words内下标为i的元素。 这意味着同数组一样，向量内的元素是有先后顺序的。words[i]事实上执行的是words.operator[ ](i)，该重载操符符函数将返回元素的引用，本例中，其类型为string&amp;。 如果在words向量内找到字符串sWord（第16行），则将其计数counts[i]加1（第17行），并将sWord置为空串（18行）。 1234if (sWord!=\"\")&#123; words.push_back(sWord); counts.push_back(1);&#125; 第22 ~ 25行：如果sWord不为空，则说明未在words中找到sWord，它是一个新发现的单词。将sWord加入向量words，并在向量counts尾部增加元素1。向量的push_back( )成员函数将参数对象添加到向量的末尾。 1assert(words.size()==counts.size());//断言向量words及counts长度相等 第28行：如果程序逻辑完全正确，向量words及counts的元素个数应当相等。本例中，assert宏将会在运行时对“参数”表达式进行检查，如果为假，程序将会报错。通常，断言（assertion）失败的报错信息包含具体的源代码文件名及断言失败的行号，这对程序员查找程序缺陷非常有用。当断言成功时，它什么都不会做。 建议🔔 人都会犯错，在程序的恰当位置适当地通过断言来帮助发现错误，是有益的实践。 123for (size_t i=0;i&lt;words.size();i++)&#123; cout &lt;&lt; words[i] &lt;&lt; \":\" &lt;&lt; counts[i] &lt;&lt; \", \";&#125; 第29 ~ 31行：将诗中出现的单词以及词频（次数）配对打印。 可以在向量定义时通过列表初始化【C++ 11】语法来为向量指定初始成员： 123//Project - VectorInit vector&lt;string&gt; v0 &#123;\"good\", \"better\", \"best\"&#125;; vector&lt;string&gt; v1 = &#123;\"good\", \"better\", \"best\"&#125;; 上述程序中的v0，v1都是包含三个字符串元素的向量，其值分别为”good”、”better”以及”best”。 此外，也可以通过指定构造函数参数来初始化向量： 12vector&lt;string&gt; v2(5,\"hi\");vector&lt;int&gt; v3(6); 上述程序中的v2包含5个字符串元素，每个字符串均为”hi”；v3则包含6个元素，其值全部为0。 12vector&lt;int&gt; v4 &#123;6&#125;; //vs. v4(6)vector&lt;int&gt; v5 &#123;6,1&#125;; //vs. v5(6,1) 实践中，应注意区分初始化列表的{ }与构造函数的( )号。上述程序中的v4仅包含一个值为6的元素，而不是6个值为0的元素；v5仅包含值为6和1的两个元素，而不是6个值为1的元素。 19.2 向量的生长向量的存储空间根据需要而自动伸缩。当现有的存储空间不足以容纳新增元素时，向量会自动申请新的存储空间，并将旧的元素进行迁移。我们通过分析下述C++程序来理解向量的内存管理行为。 1234567891011121314151617181920212223242526272829303132333435363738//Project - FishVector#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class Fish&#123; string sNumber;public: Fish()&#123; static int i = 0; sNumber = std::to_string(i++); cout &lt;&lt; \"Fish constructor: \" &lt;&lt; sNumber &lt;&lt; endl; &#125; Fish(const Fish&amp; r)&#123; sNumber = r.sNumber + \"[Copy]\"; cout &lt;&lt; \"Fish copy constructor: \" &lt;&lt; sNumber &lt;&lt; endl; &#125; ~Fish()&#123; cout &lt;&lt; \"Fish destructor: \" &lt;&lt; sNumber &lt;&lt; endl; &#125;&#125;;int main()&#123; vector&lt;Fish&gt; f(2); //0,1号鱼 printf(\"f.capacity = %d, f.size = %d\\n\",f.capacity(),f.size()); Fish f2; //2号鱼 cout &lt;&lt; \"-------------f.push_back(f2)----------\" &lt;&lt; endl; f.push_back(f2); printf(\"f.capacity = %d, f.size = %d\\n\",f.capacity(),f.size()); cout &lt;&lt; \"vector f is \" &lt;&lt; (f.empty()?\"empty.\\n\":\"not empty.\\n\"); cout &lt;&lt; \"-------------f.pop_back()-------------\" &lt;&lt; endl; f.pop_back(); cout &lt;&lt; \"-------------f.resize(1)--------------\" &lt;&lt; endl; f.resize(1); cout &lt;&lt; \"-------------f.clear()----------------\" &lt;&lt; endl; f.clear(); return 0;&#125; 上述程序的执行结果为： 12345678910111213141516171819Fish constructor: 0Fish constructor: 1f.capacity &#x3D; 2, f.size &#x3D; 2Fish constructor: 2-------------f.push_back(f2)----------Fish copy constructor: 2[Copy]Fish copy constructor: 0[Copy]Fish copy constructor: 1[Copy]Fish destructor: 0Fish destructor: 1f.capacity &#x3D; 4, f.size &#x3D; 3vector f is not empty.-------------f.pop_back()-------------Fish destructor: 2[Copy]-------------f.resize(1)--------------Fish destructor: 1[Copy]-------------f.clear()----------------Fish destructor: 0[Copy]Fish destructor: 2 说明：不同版本的标准模板库在算法策略上会有差异，在读者的计算机上，上述执行结果很可能与本书存在差异。 第6 ~ 21行：Fish类型的构造函数通过局部静态变量i为每个新对象提供一个唯一的序号（sNumber）。当Fish对象被拷贝构造时，sNumber序号会增加”[Copy]“字样，以表明拷贝生成的新对象是由哪一个旧对象拷贝而得的。无论是构造函数，拷贝构造函数，还是析构函数，都会向控制台打印包括序号的报告信息，以便于我们观察向量元素增减时的内存管理行为。 1vector&lt;Fish&gt; f(2); //0,1号鱼 第24行：f向量的构造参数2导致向量自动创建了0号鱼及1号鱼。0，1号鱼的构造函数输出见执行结果的第1 ~ 2行。可以想象，该行代码事实上要求Fish类型必须具备一个“零参数”的构造函数，否则编译器会报错。 1printf(\"f.capacity = %d, f.size = %d\\n\",f.capacity(),f.size()); 第25行：capacity( )成员函数返回向量对象的容量，即向量对象能够容纳的元素个数；size( )成员函数返回向量对象当前实际包含的元素个数。执行结果的第3行显示，当前容量（capacity）及尺寸（size）均为2。这提示，如果试图往向量中增加一个元素，将存在向量内存空间不足的问题。 1Fish f2; //2号鱼 第26行：定义并构建了2号鱼对象。其构造函数的输出见执行结果的第4行。 12cout &lt;&lt; \"-------------f.push_back(f2)----------\" &lt;&lt; endl;f.push_back(f2); 第27 ~ 28行：push_back(f2)将2号鱼加入向量f的末尾。C++并不能把2号鱼从外部变量f2“移入“向量，它只能将外部对象f2”复制”至向量内。但当前向量f的容量和尺寸都为2，没有剩余空间，为了将f2加入向量，push_back( )函数做了如下工作。 ① 在堆中申请并分配新的足够的存储空间； ② 将2号鱼，即f2对象拷贝构造至新空间内的2号位置（从下标0开始数）。相关拷贝构造函数的输出见执行结果的第6行。请注意，向量内的2号鱼的序号已变为2[Copy]。 ③ 将向量内原有的0，1号鱼由旧空间拷贝至新空间的对应位置。相关拷贝构造函数的输出见执行结果的第7 ~ 8行。请注意，向量内的0，1号鱼的序号变为0[Copy]及1[Copy]。 ④ 释放旧空间，旧空间内的原0，1号鱼的析构函数被执行。相关析构函数的输出见执行结果的第9 ~ 10行。 可以相象，push_back( )函数的这种”复制“行为要求元素类型具有公开的拷贝构造函数（可以是默认的），否则，编译器会报错。 1printf(\"f.capacity = %d, f.size = %d\\n\",f.capacity(),f.size()); 第29行：再次打印向量f的容量及尺寸。执行结果的第11行可见，容量为4，尺寸为3。这提示，向量f”认为“使用者有可能会再次往向量内增加元素，push_back( )函数在分配新空间时作了适当的预留。 1cout &lt;&lt; \"vector f is \" &lt;&lt; (f.empty()?\"empty.\\n\":\"not empty.\\n\"); 第30行：当向量内容纳的元素个数为0时，empty( )成员函数返回真，否则为假。执行结果的第12行显示，向量f非空。 12cout &lt;&lt; &quot;-------------f.pop_back()-------------&quot; &lt;&lt; endl;f.pop_back(); 第31 ~ 32行：pop_back( )成员函数将向量的最后一个元素弹出。执行结果的第14行可见，向量内的2号鱼被析构，其序号为2[Copy]。 12cout &lt;&lt; \"-------------f.resize(1)--------------\" &lt;&lt; endl;f.resize(1); 第33 ~ 34行：resize( n )成员函数将向量内的元素个数修改为n。如果n大于向量内的当前元素个数，向量将自动新增元素来实现目标；如果n小于向量内的当前元素个数，则末尾方向的多余元素会被移除。第34行执行前，向量f内有2个元素，resize(1)导致1号鱼被移除，相关析构函数输出见执行结果第16行，其序号为1[Copy]。 12cout &lt;&lt; \"-------------f.clear()----------------\" &lt;&lt; endl;f.clear(); 第35 ~ 36行：clear( )成员函数清空向量内的全部元素。执行结果第18行显示，向量内的最后一个元素，序号为0[Copy]的0号鱼被析构。 在执行结果的最后一行，我们还看到了局部变量f2的析构输出。 要点🎯 当往向量内加入元素时，向量会”酌情“申请新空间，并将旧空间的原有元素及拟加入元素以拷贝构造的形式复制到新空间内。同时，旧空间的原有元素会被释放。如果期望降低这种因内存不足而导致的“搬家开销”，可以通过reserve( n )函数预分配向量的元素存储空间。 reserve(n)成员函数会导致向量预分配n个元素的存储空间。请注意，该函数的执行只会导致向量的容量（capacity）发生变化，其实际存储的元素个数（size）不变。 向量等容器还提供emplace_back( )函数【C++ 11】，它们的功能与push_back( )类似，但实现机制略有差别。我们结合下述程序进行解释。 123456789101112131415161718192021222324252627//Project - EmplaceFish#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class Fish&#123; string sName;public: Fish(const char* name)&#123; sName = name; cout &lt;&lt; \"Fish constructor: \" &lt;&lt; sName &lt;&lt; endl; &#125; Fish(const Fish&amp; r)&#123; sName = r.sName; cout &lt;&lt; \"Fish copy constructor: \" &lt;&lt; sName &lt;&lt; endl; &#125;&#125;;int main()&#123; vector&lt;Fish&gt; v; v.reserve(10); //提前分配10个元素的空间 v.push_back(Fish(\"Tom\")); v.push_back(\"Dora\"); v.emplace_back(\"Charlie\"); return 0;&#125; 上述程序的执行结果为： 12345Fish constructor: TomFish copy constructor: TomFish constructor: DoraFish copy constructor: DoraFish constructor: Charlie 第22行：执行reserve( )函数提前为向量分配10个元素的空间，以避免通过push_back( )、emplace_back( )函数添加新元素时重新分配内存。 1v.push_back(Fish(\"Tom\")); 第23行：程序先执行Fish的构造函数，构造一个临时对象，其输出见执行结果的第1行。push_back( )函数则把临时对象Tom鱼通过拷贝构造函数复制到向量内部，相关拷贝构造函数的输出见执行结果的第2行。 1v.push_back(\"Dora\"); 第24行：push_back( )函数的参数为一个C风格的字符数组，其类型为const char*。显然，向量v预期存储Fish对象，而不是const char*类型的对象，但这行代码会通过编译并正确执行： ① 编译器“聪明”地执行Fish的构造函数，以”Dora”为参数，构建了一个用完即弃的临时对象。相关构造输出对应执行结果的第3行。 ② push_back( )函数将临时Fish对象拷贝复制到向量内。相关拷贝构造输出对应执行结果的第4行。 1v.emplace_back(\"Charlie\"); 第25行：emplace_back( )函数与push_back( )函数有如下区别。 ① emplace_back( )函数的预期参数并不是Fish对象（结合本例），而是Fish类型的构造参数。其参数的个数及类型取决于Fish的构造函数定义。 ② emplace_back( )向向量增加元素的方法并不是先构造、后复制，而是直接在分配好的元素空间上执行Fish类型的构造函数，以”Charlie”为参数（结合本例）。相关构造函数输出对应执行结果第5行。 理论上，如果待添加的元素不是一个已经存在的Fish对象，emplace_back( )函数的执行效率比push_back( )高。 如果需要在向量的特定位置插入或者删除元素，则需要使用到迭代器（iterator），请见本章后续部分。 19.3 模板数组相较于原生的数组类型，向量可以很好地适应元素数量的不确定性：以一定的执行效率损失为代价。【C++ 11】提供的array模板类可以提供固定尺寸的数组容器，相较于向量，它执行效率更高，相较于原生数组，它更安全、更便利。本书中，我们称由array模板类提供的数组容器为模板数组，以区别于原生数组。示例代码如下： 123456789101112131415161718192021222324//Project - StringArray#include &lt;iostream&gt;#include &lt;array&gt;using namespace std;int main()&#123; array&lt;string,3&gt; a1 &#123;\"Tom\",\"Dora\",\"Eddie\"&#125;; auto a2 = a1; a1[1] = \"Charlie\"; //a1.at(1) = \"Charlie\"; cout &lt;&lt; \"a1: \"; for (auto x:a1) cout &lt;&lt; x &lt;&lt; \", \"; cout &lt;&lt; \"\\na2: \"; for (auto x:a2) cout &lt;&lt; x &lt;&lt; \", \"; cout &lt;&lt; \"\\na1 == a2: \" &lt;&lt; (a1==a2?\"True\":\"False\") &lt;&lt; endl; cout &lt;&lt; \"a1 != a2: \" &lt;&lt; (a1!=a2?\"True\":\"False\") &lt;&lt; endl; cout &lt;&lt; \"a1 &gt; a2: \" &lt;&lt; (a1&gt; a2?\"True\":\"False\") &lt;&lt; endl; cout &lt;&lt; \"a1 &lt; a2: \" &lt;&lt; (a1&lt; a2?\"True\":\"False\") &lt;&lt; endl; return 0;&#125; 上述程序的执行结果为： 123456a1: Tom, Charlie, Eddie,a2: Tom, Dora, Eddie,a1 &#x3D;&#x3D; a2: Falsea1 !&#x3D; a2: Truea1 &gt; a2: Falsea1 &lt; a2: True 第3 ~ 4行：array类型由array头文件引入，且处于std名字空间之下。 1array&lt;string,3&gt; a1 &#123;\"Tom\",\"Dora\",\"Eddie\"&#125;; 第7行：array&lt;ElemType, size&gt;有两个模板参数，其中，ElemType表示元素类型，size预期为一个size_t类型的整数，它指定了模板数组的固定尺寸。模板数组一旦建立，其尺寸（元素个数）恒定。本例中，a1数组的元素类型为string，尺寸为3。 1auto a2 = a1; 第8行：模板数组对象可以整体赋值给相同类型（元素类型和尺寸均需相同）的另一个数组对象。本例中，a2通过类型推断获得与a1相同的类型，模板数组对象赋值时，右值对象中的元素通过拷贝构造或者operator=操作符函数复制给左值对象中的对应元素。此操作同样适用于向量。 1a1[1] = \"Charlie\"; //a1.at(1) = \"Charlie\"; 第9行：通过下标可以访问模板数组元素。同原生数组一样，当通过下标访问数组元素时，不会进行越界检查。通过使用at( idx )函数，也可以访问数组元素，但会进行越界检查，这显然会带来一点点执行效率的损失。当at( idx )函数收到越界的下标时，会抛出一个异常（exception）▲。异常处理机制有机会通过捕获这一异常来修复错误。at(idx)函数也适用于向量。 123 cout &lt;&lt; \"a1: \";for (auto x:a1) cout &lt;&lt; x &lt;&lt; \", \"; 第11 ~ 13行：通过基于范围的for循环来遍历并打印a1数组的全部元素，这种语法同样适用于向量。需要注意的是，在本例的语法下，循环变量x只是容器元素的复制品。如果期望通过这种循环修改容器元素，应通过下述语法获取容器元素的引用。 12for (auto&amp; x:a1): ... //对x的修改，即是对容器元素的修改 此外，当容器元素对象较大时，即便没有通过循环修改容器元素的需要，也应尽量使用容器元素的引用。这样做可以避免在循环过程中的多次大对象复制。 1234cout &lt;&lt; \"\\na1 == a2: \" &lt;&lt; (a1==a2?\"True\":\"False\") &lt;&lt; endl;cout &lt;&lt; \"a1 != a2: \" &lt;&lt; (a1!=a2?\"True\":\"False\") &lt;&lt; endl;cout &lt;&lt; \"a1 &gt; a2: \" &lt;&lt; (a1&gt; a2?\"True\":\"False\") &lt;&lt; endl;cout &lt;&lt; \"a1 &lt; a2: \" &lt;&lt; (a1&lt; a2?\"True\":\"False\") &lt;&lt; endl; 第19 ~ 22行：通过==、!=、&gt;、&lt;等重载操作符函数，可对模板数组对象进行整体比较，这是原生数组无法完成的任务。当且仅当两个模板数组内的元素完全相同时，两个模板数组相等。当两个模板数组比较大小时，则会从第0个元素开始比较，如果第0个元素相等，则比较第1个 … 请读者结合程序执行结果进行理解。上述逻辑比较运算同样适用于向量。 19.4 数组与链表array、vector以及string，都可视为数组类型，其元素均存储在一片连续的内存空间之内。这一特性使得通过下标存取容器元素（即随机存取）成为可能：元素地址可以通过首元素地址加上元素大小与下标的乘积得到。array、vector、string类型都有一个名为data( )的成员函数，通过该成员函数，可以获取其数据存储空间的指针。 如图19- 所示，数组的这种内存结构也使得在特定位置插入或者删除元素变得困难。比如，如果我们期望在下标k的位置插入一个新元素，就需要先从后往前把从下标k开始的所有元素依次后移，然后才能把新元素存入下标k。当删除指定下标元素时，情况与此类似，需要把后续无素逐一前移，以填补元素删除后的空缺。 图19- 数组类容器的结构 与数组不同，链表（包括双向链表list以及单向链表forward_list【C++ 11】）中的元素是分散存储的，元素之间通过节点指针来串接。图19- 展示了一个典型的双向链表的结构： 链表由多个节点串接而成，每个节点包括：前向（prev）指针、数据及后向（next）指针三个部分。其中，数据即为链表容器的元素，每个节点存储一个元素。 前向指针指向本节点的前一个节点，容器的第0个节点的前向指针为空。 后向指针指向节点节的后一个节点，容器的最后一个节点的后向指针为空。 头指针指向链表第0个节点；尾指针指向链表的最后一个节点。 图19- 双向链表的结构 链表中每个节点的存储在内存中是散布非连续的，这使得程序无法通过下标计算得到节点/元素的存储位置。要访问链表元素，必须从头指针或者尾指针出发，后向或前向顺序访问。但链表的这种结构也有好处，那就是可以快速地在指向位置删除或者插入元素。如图19- 所示，当我们在data1和data2元素之间插入新元素new时，并不需要象数组那样把data2及后续元素依次后移，只需要新建一个包含元素new的节点，然后修改data1、data2以及new节点的部分指针的指向即可。 图19- 双向链表中的元素插入 与双向链表（list）不同，单向链表（forward_list）的节点中没有前向指针，这使得单向链表的元素访问，只能从头指针出发，从前向往单向进行。 下述C++程序是一个非常简单的双向链表的示例： 12345678910111213141516//Project - StringList#include &lt;iostream&gt;#include &lt;list&gt;using namespace std;int main() &#123; list&lt;string&gt; girls &#123;\"Dora\", \"Emily\", \"Cinderella\"&#125;; girls.pop_back(); girls.push_back(\"Angela\"); girls.emplace_front(\"Iris\"); girls.sort(); for (auto&amp; x:girls) cout &lt;&lt; x &lt;&lt; endl; return 0;&#125; 上述程序的执行结果为： 1234AngelaDoraEmilyIris 第3 ~ 4行：list类型由list头文件引入，且处于std名字空间之下。 1list&lt;string&gt; girls &#123;\"Dora\", \"Emily\", \"Cinderella\"&#125;; 第7行：定义了一个元素类型为string的双向链表对象girls，并使用初始化列表进行了初始化。 1girls.pop_back(); 第8行：弹出/移除链表中的最后一个元素。具体到本例，”Cinderella”被移除。与此对应的成员函数还有pop_front( )，它用于弹出/移出链表的第一个元素。 1girls.push_back(\"Angela\"); 第9行：在链表的尾部添加一个元素。与此对应的成员函数还有push_front( )，它用于在链表头部添加一个元素。 1girls.emplace_front(\"Iris\"); 第10行：在链表的起始处添加一个元素。如本章稍早所述，emplace_front(…)、emplace_back(…)会避免使用拷贝构造的方式来复制元素，而是直接通过构造函数来初始化元素。此处的…指元素的构造函数参数。 1girls.sort(); 第11行：对链表内的元素进行排序。 12for (auto&amp; x:girls) cout &lt;&lt; x &lt;&lt; endl; 第13 ~ 14行：使用基于范围的for循环遍历打印链表元素。注意，此处通过获取链表元素的引用来避免循环过程中的链表元素的不必要复制。 执行结果可见，经过排序后的链表按照非递减有序。 向量（vector）内的全部元素是存储在一块连续内存之内的，这使得元素的随机访问速度很快。双端队列（deque）的元素则存储在多块连续内存上，其每一个内存块通常存储相同数量的元素。这使得双端队列也可以支持快速的元素随机访问（比向量稍慢）。同时，当向双端队列队首或队尾添加元素时，双端队列可以通过申请新的内存块来实现快速的队首/队尾元素添加。 扩展阅读📕 上述链表、队列的具体工作原理通常属于《数据结构》课程的内容；对数组、链表等插入、删除中间元素，添加、移除头部/尾部元素的计算代价，称之为计算复杂性，通常属于《算法分析》研究的内容。 19.5 迭代器如前所述，不同容量，比如向量和链表，其内部数据结构差异很大。不同的内部数据结构导致的不同的容器特性：向量、模板数组、双端队列可以通过下标随机访问元素，而链表、单向链表则只能顺序访问。这种容器间的接口差异，为代码复用（code reuse）带来困难。而迭代器（iterator）的设计目的之一，就是为了消除不同容器间的访问接口差异，使得泛型程序设计（generic programming）成为可能。广义地，迭代器属于设计模式（design patterns）的范畴。 19.5.1 获取迭代器大多数容器，都有begin( )和end( )两个成员函数，其中，begin( )函数返回指向首元素的迭代器。与读者的预期不同，end( )函数所返回的迭代器并非指向末尾元素（容器的最后一个元素），而是指向末尾元素的后面一个”元素”，它被称为尾后迭代器（off-the-end iterator）。当然，末尾元素的后面不会再有其它元素，end( )函数所返回的迭代器用于表示：所有元素都已遍历完成，程序已到达容器尾部的“出口”。我们结合下述程序及图19- 来解释。 12345678910111213141516//Project - StringIterator#include &lt;iostream&gt;using namespace std;int main() &#123; string s = \"Run, Forrest\"; auto it = s.begin(); while (it!=s.end())&#123; *it = toupper(*it); it++; &#125; cout &lt;&lt; s &lt;&lt; endl; return 0;&#125; 上述程序的执行结果为： 1RUN, FORREST 图19- 首元素及尾后迭代器 可以将string类型的对象视为一种类似于向量的容器，其元素类型为字符。图19- 展示了s对象内部的元素排列状况。 1auto it = s.begin(); 第8行：通过begin( )成员函数获取s的首元素迭代器并赋值给变量it。如图19- 所示，此时的it应指向s的首元素’R’。根据类型推断，本例中对象it的类型为string::iterator。 要点🎯 迭代器对象可以视为指向容器内元素的智能指针，借助于其重载的操作符函数，可以使用迭代器遍历容器，并插入、删除元素。 1234while (it!=s.end())&#123; *it = toupper(*it); it++;&#125; 第9 ~ 12行：借助于循环及迭代器的移动，将s字符串的所有字符改为大写。 ① s.end( )返回尾后迭代器，它指向尾元素的后面一个“元素”，如图19- 所示。 ② !=是迭代器对象的一个重载操作符函数，两个迭代器如果不相等，就意味着它们指向不同的容器元素。本例中，it迭代器会在循环过程中逐渐后移，it与尾后迭代器相等即意味着容器元素已遍历完毕。 ③ 间接操作符*也被迭代器对象重载了，*it返回it所指向的元素的引用。 ④ toupper( )函数将字符转换成大写形式，该函数位于std名字空间之下。 ⑤ it++对应it.operator++(int)，其执行使得it迭代器后移一个元素。 从执行结果可见，上述循环成功地达成了目标，s内的小写字母全部变成了大写字母。 建议🔔 上述while循环条件中的it!=s.end( )也可以写成it &lt; s.end( )。对于两个迭代器a和b而言，如果a &lt; b，说明a所指向的元素在b所指向的元素的前面。但是，作者更建议使用it != s.end( )，这是因为部分容器的迭代器不支持&lt;操作符，使用!=使得上述程序兼容性更佳。 如前所述，迭代器的用途之一是消除不同容器的访问接口的差异。借助于迭代器，遍历链表的方法与遍历向量或者字符串基本相同。见下述示例。 123456789101112131415//Project - ListIterator#include &lt;iostream&gt;#include &lt;list&gt;using namespace std;int main() &#123; list&lt;double&gt; a &#123;1,10,100,1000&#125;; auto it = a.rbegin(); while (it!=a.rend())&#123; *it = (*it)*1.2; cout &lt;&lt; *it &lt;&lt; \",\"; it++; &#125; return 0;&#125; 上述程序的执行结果为： 11200,120,12,1.2, 图19- 尾元素及首前迭代器 在上述程序中，我们使用了反向迭代器（reverse iterator），链表容器的遍历顺序为由后往前，即尾元素1000最先被迭代。 1auto it = a.rbegin(); 第8行：a.rbegin( )返回的迭代器是个反向迭代器，本例中， 它指向尾元素1000。其中，迭代器it的类型被推断为list&lt;double&gt;::reverse_iterator。 12345while (it!=a.rend())&#123; *it = (*it)*1.2; cout &lt;&lt; *it &lt;&lt; \",\"; it++;&#125; 第9 ~ 13行：借助于循环及迭代器的移动，将a数组内的元素全部乘以1.2，并输出其值。 ① s.rend( )返回反向首前迭代器，它指向首元素的前面一个“元素”，如图19- 所示。 ② !=是迭代器对象的一个重载操作符函数，两个迭代器如果不相等，就意味着它们指向不同的容器元素。本例中，it迭代器会在循环过程中逐渐前移，it与首前迭代器相等即意味着容器元素已遍历完毕。 ③ 间接操作符*也被迭代器对象重载了，*it返回it所指向的元素的引用。 ④ it++对应it.operator++(int)，由于it是反向迭代器，所以it++事实上导致it移至前一个元素。相应地，it–则意味着，it移至后一个元素。请读者注意图19- 中it++及it–所对应的箭头方向。 从执行结果可见，上述循环成功地达成了目标，a内的全部元素向后向前被遍历并修改。 表19- 标准的迭代器获取函数（对象c为一个容器） 名称 说明 类型 c.begin( ), c.end( ) 正向迭代器。其中，begin( )返回的迭代器指向首元素，end( )返回尾后迭代器，它指向尾元素的后面一个“元素”。如果c是常量型容器对象，begin( )及end( )返回的迭代器也是常量型。 &lt;容器类型&gt;::iterator c.rbegin( ),c.rend( ) 反向迭代器。其中，rbegin( )返回的迭代器指向尾元素，rend( )返回首前迭代器，它指向首元素的前面一个“元素”。如果c是常量型容器对象，rbegin( )及rend( )返回的迭代器也是常量型。 &lt;容器类型&gt;::reverse_iterator c.cbegin( ), c.cend( ) 常量型正向迭代器，对常量型迭代器使用间接操作符将得到元素的常量型引用。对于只读，不修改的容器遍历，应尽可能使用常量型迭代器。 &lt;容器类型&gt;::const_iterator c.crbegin( ), c.rcend( ) 常量型反向迭代器。 &lt;容器类型&gt;::const_reverse_iterator 注意📢 当容器c为空时，c.begin( )与c.end( )相等，它们都返回尾后迭代器。同理，当容器c为空时，c.rbegin( )也等于c.rend( )。 19.5.2 迭代器算术迭代器本质是对象，但使用方法类似于指针。表19- 总结了标准的迭代器操作符。 表19- 标准迭代器操作符（it指迭代器） 操作符 说 明 *it 间接操作符，*it返回迭代器it所指向的元素的引用，当迭代器是常量型时，返回的引用也是常量型。 it-&gt;member 指向操作符，返回迭代器it所指向的元素的成员的引用，其等价于(*it).member。 it++ 当it是正向迭代器时，移至后一个元素；当it是反向迭代器时，移至前一个元素。 it– 当it是正向迭代器时，移至前一个元素；当it是反向迭代器时，移到后一个元素。 it1 == it2 迭代器it1与it2相等， it1 != it2 判断迭代器it1和it2是否不相等。 it + n 迭代器it与整数n相加将返回一个新的迭代器，结果迭代器预期指向it所指向的元素＂后＂面的第n个元素。 it - n 迭代器it与整数n相加将返回一个新的迭代器，结果迭代器预期指向it所指向的元素＂前＂面的第n个元素。 it += n 将迭代器it”后“移n个位置，指向原指向元素的”后“面第n个元素。 it -= n 将迭代器it”前“移n个位置，指向原指向元素的”前“面第n个元素。 it1 - it2 将两个迭代器相减将得到一个整数n，这个整数n等于两个迭代器所指向的元素的”下标“差值。如果将it2加上整数n，预期应得到it1。 &gt;, &gt;=, &lt;, &lt;= 对迭代器进行逻辑比较。对于迭代器it1和it2，如果it1所指向的元素在it2所指向元素的”前“面，it1小于it2。 注意📢 表19- 所述的”前“、”后“与迭代器的方向有关， 当迭代器为反向迭代器时，所谓的”后“，事实上是靠近首元素的方向。 警告🚩 使用迭代器时，程序员需要小心避免”不合逻辑“的访问行为。比如：尾后迭代器事实上不指向任何元素，对其使用间接操作符*会导致程序异常；同样地，对于个迭代器加上整数n，程序员也应小心确保其结果迭代器要么指向一个容器元素，要么是“尾后”或“首前”迭代器。 把同一个容器的两个迭代器配合使用，可以表示容器元素的一个连续子集。在数学上，迭代器it1和it2所示表示的元素范围可以表示成 [ it1, it2 )，这是一个左闭右开的区间，它表示结果子集中的元素从it1所指向的元素（包含，左闭）开始，到it2所指向的元素结束，且不包含（右开）it2所指向的元素。对于图19- 所示的容器c而言： [ it1, it2 ) 表示从A到L的全部元素，请注意it2是尾后迭代器，它指向L的后面一个”元素”。 [ it3, it4 ) 表示从D到H的元素，即D、E、F、G、H共5个元素。请注意，it4所指向的元素I并未包含。 [ it5, it6 ) 则表示从L到A的全部元素，请注意，it5和it6都是反向迭代器，且it6指向“首前元素”。 图19- 双迭代器所表示的元素范围 当使用两个迭代器，如it1和it2表示元素范围时，必须保证it1在迭代方向上较it2靠前，即it2可以通过递增it1得到，否则，结果子集合为空。对于图19- ，[ it2, it1 )的结果的一个空集合。此外，两个相等的迭代器所表示的元素子集也为空。 注意📢 [ it1, it2 ) 只是一种数学表达，C++并不支持直接在代码中使用这种格式来获取或表达容器的元素子集。结合两个迭代器来表达容器的元素子集的方法，请见19.6节。 19.5.3 折半查找示例我们使用迭代器重写了第5章中讨论过的折半查找算法，来帮助读者理解迭代器的算术运算。其核心代码如下： 1234567891011121314151617//Project - BinarySearch...template &lt;typename T, typename V&gt;T binarySearch(T begin, T end, const V v)&#123; auto endOriginal = end; while (begin != end) &#123; auto mid = begin + (end-begin)/2; if (*mid==v) return mid; else if (v &lt; *mid) end = mid; else begin = mid+1; &#125; return endOriginal;&#125;... binarySearch( )是一个模板函数，其接口描述如下。 输入： 迭代器 [ begin, end ) 代表了搜索的元素范围，如上一小节所述，end所指向的元素不在搜索范围内； 搜索值v。注意，无论是迭代器类型还是搜索值类型都为模板参数，这意味着该函数具备泛型编程的特征，它不对输入的容器/迭代器类型、元素类型作出限定。理论上，该折半查找函数适用于向量、模板数组、双端队列等不同容器。 输出：如果在指定的元素范围内找到了搜索值，返回指向该元素的迭代器；如未找到，返回end迭代器。 1auto endOriginal = end; 第5行：将end迭代器存入endOriginal备用，未找到搜索值时，返回endOriginal，即原始的end迭代器。 1while (begin != end) &#123; 第6行：在整个折半查找的过程中，[begin, end) 代表了当前搜索的元素范围。只要begin不等于end，即意味着在该范围内至少存在一个元素，搜索应继续进行，否则应结束循环。 1auto mid = begin + (end-begin)/2; 第7行：通过迭代器算术求指向当前搜索范围 [begin, end) 的中位元素的迭代器。其中，end - begin返回待搜索的元素个数，将该值除以2，再加上begin，即得指向中位元素的迭代器。 12if (*mid==v) return mid; 第8 ~ 9行：将中位元素与搜索值v进行比较，如相同，说明找到搜索值，直接返回中位元素的迭代器mid。 12else if (v &lt; *mid) end = mid; 第10 ~ 11行：否则，如果搜索值小于中位元素，这说明搜索值位于中位元素的左边，将中位元素迭代器赋值给end。赋值之后的[begin, end)相较于之前的[begin,end)，其范围大概缩小了一半，且不包含之前的中位元素。 12else begin = mid+1; 第12 ~ 13行：如果上述两种情况都不成立，说明搜索值大于中位元素，其应位于中位元素的右方，将mid + 1赋值给begin。赋值之后的[begin, end) **相较于之前的[begin, end)**，其范围大概缩小了一半。 1return endOriginal; 第15行：在前述循环过程中，如果一直没有找到搜索值，每经过一轮循环，[begin, end) 的范围就缩小一半，最终会导致begin与end相等，满足循环中止条件，循环结束并返回endOriginal。 下述代码则展示了使用binarySearch( )函数进行折半查找的过程： 1234567891011121314151617//Project - BinarySearch#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;... int main() &#123; vector&lt;int&gt; a &#123;1,3,5,7,9,11&#125;; auto r = binarySearch(a.cbegin(),a.cend(), 7); if (r==a.cend()) cout &lt;&lt; \"Not found.\" &lt;&lt; endl; else cout &lt;&lt; \"Found: \" &lt;&lt; *r &lt;&lt; endl; return 0;&#125; 上述程序的执行结果为： 1Found: 7 第6行：… 表示被省略的binarySearch( )函数的定义。 1auto r = binarySearch(a.cbegin(),a.cend(), 7); 第7行：a.cbegin( )， a.cend( )返回向量a的首元素只读迭代器以及只读尾后迭代器，这说明折半查找的搜索范围包括a的全部元素。binarySearch( )模板参数T的类型被确定为vector&lt;int&gt;::const_iterator。 1if (r==a.cend()) 第11行：如果返回迭代器等于a.cend( )，说明在向量a内未找到搜索值。 要点🎯 第5章中所描述的折半查找函数，仅适用于指定类型的数组，不具体通用性。借助于迭代器及模板参数，本节中的binarySearch( )理论上可以支持不同的容器类型及元素类型，具备泛型编程的特征。事实上，本节的binarySearch( )函数不支持对链表的折半查找，因为链表的迭代器不支持减法操作符。 19.5.4 容器元素的修改下述程序展示了通过迭代器对容器元素进行修改的一般方法： 1234567891011121314151617181920212223242526//Project - ModifyElement#include &lt;iostream&gt;#include &lt;list&gt;#include &lt;vector&gt;using namespace std;template &lt;typename T&gt;void output(T begin, T end, const string&amp; sTitle)&#123; cout &lt;&lt; \"----------\" &lt;&lt; sTitle &lt;&lt; \"------------\\n\"; while (begin!=end) cout &lt;&lt; *begin++ &lt;&lt; \",\"; cout &lt;&lt; endl;&#125;int main() &#123; vector&lt;int&gt; a; a.assign(&#123;0,1,2,3,4,5,6,7,8,9&#125;); *(a.begin()+3) = 99; output(a.cbegin(),a.cend(),\"vector&lt;int&gt; a\"); list&lt;int&gt; b; b.assign(a.crbegin()+2,a.crend()-3); output(b.cbegin(),b.cend(), \"list&lt;int&gt; b\"); return 0;&#125; 上述程序的执行结果为： 1234----------vector&lt;int&gt; a------------0,1,2,99,4,5,6,7,8,9,----------list&lt;int&gt; b------------7,6,5,4,99, 第7 ~ 13行：定义了一个“通用”的容器元素输出函数output( )，因为模板参数及迭代器的使用，该函数理论上可以输出任意序列容器（sequential container）的元素。 1a.assign(&#123;0,1,2,3,4,5,6,7,8,9&#125;); 第17行：用初始化列表中的元素替换向量a中的全部元素。 1*(a.begin()+3) = 99; 第18行：将向量a的第3个元素（从0开始计数）修改为99。这里使用到了迭代器算术。 1output(a.cbegin(),a.cend(),\"vector&lt;int&gt; a\"); 第19行：使用output( )函数输出向量a的全部元素。由于输出过程并不期望改变容器元素的值，所以我们使用了常量型迭代器。其输出对应执行结果的第1 ~ 2行。 1b.assign(a.crbegin()+2,a.crend()-3); 第22行：用向量a中的部分元素替换链表b中的全部元素。源自向量a的元素集由两个迭代器来表示，形式上可表示为 **[ a.crbegin()+2, a.crend()-3 ) **。 a.crbegin( ) + 2: 反向只读迭代器，指向尾元素之”后”的第2个元素，即向量a倒数第3个元素，其值为7。 a.crend( ) - 3: 反向只读迭代器，指向”首前元素”之“前”的第3个元素，即向量a正数第3个元素，其值为2。 由于两个迭代器都是反向迭代器，且按照左闭右开的规则，a.crend( )-3所指向的元素（即2）不包含在范围内，所以，**[ a.crbegin()+2, a.crend()-3 ) **所表示的元素序列为7， 6， 5， 4， 99。 第22行的assign( )与第17行的assign( )参数不同，显然，这些容器通过函数名重载定义了多个名为assign( )的成员函数。请读者对照图19- 理解第22行代码所涉及的元素范围。 图19- 反向迭代器元素范围示例 1output(b.cbegin(),b.cend(), \"list&lt;int&gt; b\"); 第23行：打印链表b的全部元素，其输出对应执行结果的第3 ~ 4行。 19.5.5 容器元素的增加表19- 序列容器的元素增加函数 函数 说明 c.push_back(e) 将元素e通过复制的方式添加到容器的尾部。 c.emplace_back(args) 在容器尾部添加一个元素，新元素通过参数args构造。 c.push_front(e) 将元素e通过复制的方式添加到容器的头部。前向链表不支持该函数。 c.emplace_front(args) 在容器头部添加一个元素，新元素通过参数args构造。前向链表不支持该函数。 c.insert(it,e) 在迭代器it所指向的元素前，通过复制的方式添加一个新元素，其值为e。函数返回指向新增元素的迭代器。 c.emplace(it,args) 在迭代器it所指向的元素前，新增一个元素，新元素通过参数args构造。函数返回指向新增元素的迭代器。 c.insert(it,initialize_list) initialize_list是包含一系列元素值的初始化列表。该函数将这些元素值插入it所指向的元素之前。函数返回指向第1个新增元素的迭代器，如果initialize_list为空，则返回参数it。 c.insert(it,n,e) 在迭代器it所指向的元素前，新增n个值为e的元素。函数返回指向第1个新增元素的迭代器，如果n等于0，则返回参数it。 c.insert(it,begin,end) 在迭代器it所指向的元素前，插入[begin,end)元素范围中的全部元素。函数返回指向第1个新增元素的迭代器，如果元素范围[begin,end)为空，则返回参数it。注意：迭代器begin, end不可以来自容器c。 警告🚩 往vector、string、deque等容器添加元素，可能会使得相关的迭代器、引用、地址等全部失效，因为元素的添加过程可能会导致原有元素的内存地址变生变化。这也是表19- 中，c.insert(it,begin,end)中的begin,end不可以源自容器c的原因。 下述程序主要讨论表19- 中，几个insert( )函数的使用方法： 1234567891011121314151617181920212223//Project - AddElements#include &lt;iostream&gt;#include &lt;list&gt;#include &lt;vector&gt;using namespace std;void output(T begin, T end, const string&amp; sTitle)&#123; ... &#125; //代码有省略int main() &#123; vector&lt;int&gt; a &#123;0,1,2,3,4,5&#125;; a.insert(a.cbegin()+4,10); a.insert(a.cbegin()+2,3,100); a.insert(a.cbegin()+3,&#123;97,98,99&#125;); a.emplace(a.cbegin()+5, 999); output(a.cbegin(),a.cend(),\"vector&lt;int&gt; a\"); list&lt;int&gt; b &#123;0,0,0,0,0&#125;; auto it = b.cbegin(); it++; b.insert(it, a.cbegin()+2, a.cbegin()+7); output(b.cbegin(),b.cend(),\"list&lt;int&gt; b\"); return 0;&#125; 上述程序的执行结果为： 1234----------vector&lt;int&gt; a------------0,1,100,97,98,999,99,100,100,2,3,10,4,5,----------list&lt;int&gt; b------------0,100,97,98,999,99,0,0,0,0, 第7行代码有省略，该output( )函数与前节中的output( )函数完全相同，用于输出容器内容。 图19- AddElements示例执行过程（第一部分） 第11 ~ 14行：图19- 展示了相关执行过程。 第11行在第4个元素（从0开始计数，即元素4）之前插入元素10。 第12行在第2个元素（从0开始计数，即元素2）之前插入3个值为100的元素。 第13行在第3个元素（从0开始计数，即如图所示的值为100的元素）之前插入三个元素，其值依次为97、98和99。 第14行在第5个元素（从0开始计数，即元素99）之前新增一个元素，其值为999。理论上，emplace( )函数会通过从参数构造而不是复制来初始化新元素，但对于原生数据类型int来讲，两者并无区别。 1output(a.cbegin(),a.cend(),\"vector&lt;int&gt; a\"); 第15行：输出向量a的全部元素，从执行结果的第2行可见，a内的元素内容与图19- 完全一致。 图19- AddElements示例执行过程（第二部分） 123auto it = b.cbegin();it++;b.insert(it, a.cbegin()+2, a.cbegin()+7); 第18 ~ 20行：图19- 展示了相关执行过程。 第18行先取得容器b的首元素只读迭代器it， 经过++操作符，it指向第1个元素（从0开始计数），如图19- 所示。 第20行则把两个迭代器所表示的范围内的元素，对应图19- 中底色为灰的单元格，复制并插入到it迭代器所指向的元素之前。如前所述，迭代器[it1, it2)所指的元素范围是不包括it2所指向的元素的。 1output(b.cbegin(),b.cend(),\"list&lt;int&gt; b\"); 第21行：输出容器b的全部内容，从执行结果的第4行可见，相关输出与图19- 的描述相符。 要点🎯 可以看出，迭代器的使用部分消除了不同类型容器之间的鸿沟。在上述示例中，通过迭代器，我们很容易地把向量中的元素批量复制到链表内。反之亦然。 19.5.6 容器元素的删除表19- 序列容器的元素移除函数 名称 说明 c.pop_back( ) 删除容器c的最后一个元素。如果c为空，函数行为不确定。前向链表不支持该函数。 c.pop_front( ) 删除容器c的第一个元素。如果c为空，函数行为不确定。向量及字符串不支持该函数。 c.erase(it) 删除迭代器it所指向的元素。返回一个迭代器，指向被删除元素的后一个元素。如果被删除元素是最后一个元素，则返回尾后迭代器。如果参数it是尾后迭代器，函数行为不确定。 c.erase(begin, end) 从容器中删除由迭代器[begin,end)所表示的全部元素。返回一个迭代器，指向最后一个被删除元素的后一个元素。如果参数end是尾后迭代器，函数返回尾后迭代器。 c.clear( ) 清空容器，即删除容器内的全部元素。 警告🚩 从开端队列的中间位置（开始和结尾除外）删除元素将使得该容器的全部迭代器、元素引用及指针失效。当从向量或者字符串容器删除元素时，删除点之后的迭代器、元素引用及指针将会失效，因为在删除元素的过程中，删除点之后的元素位置会发生变化，而删除点之前的元素则不受影响。 下述程序中的evenRemover( )函数，通过迭代器，来移除不同容器中的偶数： 1234567891011121314151617181920212223242526272829//Project - EvenRemover#include &lt;iostream&gt;#include &lt;list&gt;#include &lt;deque&gt;using namespace std;void output(T begin, T end, const string&amp; sTitle)&#123; ... &#125; //代码有省略template &lt;typename T&gt;void evenRemover(T&amp; c)&#123; auto it = c.begin(); while (it!=c.end())&#123; //检查it是否等于尾后迭代器 if (*it % 2 == 0) it = c.erase(it); //发现偶数，删除并移至下一个元素 else ++it; //不是偶然，移至下一个元素 &#125;&#125;int main() &#123; list&lt;int&gt; a &#123;0,1,2,3,4,5,6,7,8,9&#125;; evenRemover(a); output(a.cbegin(),a.cend(),\"list&lt;int&gt; a\"); deque&lt;int&gt; b &#123;0,1,2,3,4,5,6,7,8,9&#125;; evenRemover(b); output(b.cbegin(),b.cend(),\"deque&lt;int&gt; b\"); return 0;&#125; 程序的执行结果为： 1234----------list&lt;int&gt; a------------1,3,5,7,9,----------deque&lt;int&gt; b------------1,3,5,7,9, 第7行代码有省略，该output( )函数与前节中的output( )函数完全相同，用于输出容器内容。 第9 ~ 18行：evenRemover( )函数接受一个容器的引用作为参数，删除该容器内的全部偶数。由于类型T为模板参数，理论上，该函数适用于向量、链表、双端队表等各种容器类型。 1auto it = c.begin(); 第11行：获取容器c的首元素迭代器并赋值给it。 1while (it!=c.end())&#123; //检查it是否等于尾后迭代器 第12行：while循环以it != c.end( )作为循环条件，当it等于c.end( )/尾后迭代器时，即意味着容器c的全部元素已遍历完毕。 12if (*it % 2 == 0) it = c.erase(it); //发现偶数，删除并移至下一个元素 第13 ~ 14行：如果迭代器it所指向的元素为偶数，通过c.erase( )函数将其删除。根据erase( )函数的定义，其将返回指向被删除元素的后一个元素的迭代器。该返回迭代器被赋值给it。理论上，从容器中删除元素可能使得该容器的全部迭代器失效，但在第12行的while循环条件中，每次都是重新调用c.end( )函数来获取“最新”的尾后迭代器，这使得程序逻辑不会受到迭代器失效的影响。 12else ++it; //不是偶然，移至下一个元素 第15 ~ 16行：不是偶数，通过++it将迭代器移至下一个元素。 123list&lt;int&gt; a &#123;0,1,2,3,4,5,6,7,8,9&#125;;evenRemover(a);output(a.cbegin(),a.cend(),\"list&lt;int&gt; a\"); 第21 ~ 23行：将一个整数链表传递给evenRemover( )函数，执行结果的第1 ~ 2行证实，容器内的全部偶数被删除。 123deque&lt;int&gt; b &#123;0,1,2,3,4,5,6,7,8,9&#125;;evenRemover(b);output(b.cbegin(),b.cend(),\"deque&lt;int&gt; b\"); 第25 ~ 27行：将一个元素类型为整数的双端队列传递给evenRemover( )函数，执行结果的第3 ~ 4行证实，容器内的全部偶数被删除。 这个示例程序进一步证实，通过模板参数，以及迭代器，evenRemover( )函数和output( )函数均具备泛型程序设计的特征，它可以在不同的容器上完成相同的功能。 【缺？ 模板函数在编译器内部如何区分，当模板参数不同时】 19.5.7 迭代器失效19.6 map映射①②③④⑤⑥⑦⑧⑨⑩ 要点🎯 👣 警告🚩 🌋 建议🔔 扩展阅读📕 注意📢 20. 文件读写21. 实践 - 一棵树的构建22. 实践 - 数学之美23. 实践 - 唐朝诗人的朋友圈24. 异常 新入群的非本教学班的同学，建议先完成下述准备工作： 安装Qt Creator https://codelearn.club/2020/01/qt-install-win/ 创建第1个应用： https://codelearn.club/2020/02/simpleqtuse/ 然后你就可以开始学习了。 讲义在群文件里，每1-2天更新一次（正在写作）。 群规1.技术问题在群里问，私信不回答（考虑效率）；2.截图不拍照，尽量全屏；3.问完问题要及时响应回答者的疑问和解答，问完就不理人是相当不礼貌的。4. 陈叔会不定时装死，群内2018, 2019计科的大佬请随便圈。5.有问题先看群文件FAQ.PDF。 MOOC点赞，收藏，分享热线： https://www.bilibili.com/video/av34409478 同学们帮忙！ No debug adapter found部分同学调试运行时会遇到no debug adapter found错误，导致程序无法调试。vscode 1.42版本的bug, 卸载后， 安装群文件里的visual studio code 1.38.1版本即可解决。 ipynb文件（Jupyter Notebook）ipynb文件无法打开：照下述链接解决 (visual studio code的软件缺陷) https://codelearn.club/2020/02/vscjupyter/ 如果实在搞不定，建议放弃安装jupyter notebook, 即直接使用.py文件编程和运行，不影响学习。jupyter notebook属于锦上添花，非必须。 开发环境安装与配置严格按下述链接进行，仔细 https://codelearn.club/2019/06/pythoninstall/ https://codelearn.club/2019/06/pythonuse/ https://codelearn.club/2019/06/vscinstall/ https://codelearn.club/2019/06/vscuse/ https://codelearn.club/2019/06/vscconfig/ 当前目录下的operator.py改个名字。turtle间接引入了一个名为operator的模块，跟operator.py重名了。python3.7下没问题，3.8下问题显现。我的错。 总结，切片参数[x:y:z]中的x,y的确定过程分为两步： 第1步：如果x,y有指定负值，解释器会对其加上序列长度，将其转换成正值； 第2步：如果x,y没有指定值，解释器按下述规则取默认值； z &gt; 0时，x缺省默认值为0， y缺省默认值为列表长度； z &lt; 0时，x缺省默认值为列表长度减1， y缺省默认值为-1； 请注意，第2步发生在第1步之后，在第2步中给y的-1不会被转换成正值。 在线OJ如何评价你的程序： OJ是Online Judge的简称，pintia.cn就是一种OJ。 OJ会在它的评价有服务器上运行你提交的代码，它会假装成测试者为你的input( )函数提供输入： 这意味着，在你的程序里你必须要使用input( )函数获取输入！ OJ会检查你的程序的print( )结果， 因为是机器，所以它的检测可能会很苛刻：有时一个标点也不能错（中文符号不等于英文符号）。 如果涉及符号或者文字，最好直接从输出示例中复制，不要自己敲。 OJ会使用多种输入来运行测试你的程序，不仅限于它给出的示例输入。 如果OJ给出的错误信息是 程序未返回0值， 对于Python，可能意味着你的程序在执行过程中出了错。 我的建议是： 先在VSC里编程，运行，手工输入数据，检查结果，一切无异后再复制粘贴到OJ里提交。 ①②③④⑤⑥⑦⑧⑨⑩ ①②③④⑤⑥⑦⑧⑨⑩ 总结🍵 要点🎯 👣 警告🚩 🌋 建议🔔 扩展阅读📕 注意📢","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://codelearn.club/categories/C-C/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://codelearn.club/tags/C-C/"}]},{"title":"附录A.3. 实践 - 冒泡及轻者上浮","slug":"bubblesort","date":"2020-09-12T01:35:04.000Z","updated":"2020-09-14T01:53:47.299Z","comments":true,"path":"2020/09/bubblesort/","link":"","permalink":"http://codelearn.club/2020/09/bubblesort/","excerpt":"附录A.3. 实践 - 冒泡及轻者上浮","text":"附录A.3. 实践 - 冒泡及轻者上浮 本书同名免费MOOC《Python编程基础及应用》在哔哩哔哩（B站）热播，作者带着你学。 附录A.3. 实践 - 冒泡及轻者上浮Python自带有标准GUI-图形用户界面工具包Tkinter。但Tkinter的功能相对比较简单，界面也不够漂亮，对于规模大一点的GUI应用略显不足。在当前的Python生态圈，如果读者需要一种功能较齐全、能满足大多数项目实践需要的GUI工具包，作者认为，PyQt5是当前最好的选择。 本章向读者介绍基于PyQt5的图形应用程序的框架及开发过程，以及分时操作系统的消息循环机制，还有多线程程序设计的基本概念和方法。冒泡排序不是重点。 A.3.1 开发环境准备A.3.1.1 QtQt - https://www.qt.io/是久负盛名的跨平台C++ GUI开发包及集成开发环境。它独特的信号-槽机制屏蔽了不同操作系统间的差异，使得用C++语言书写的应用程序可以在不同的操作系统(Windows, Linux如Ubuntu)下运行。由于它本身就是C++语言书写的，所以运行速度相对较快。经过多年的发展，Qt已经发展得比较成熟了，即便开发Android App，也可以在Qt上用C++完成。 PyQt则是对Qt的Python封装，它是由英国的RiverBank公司- https://riverbankcomputing.com开发的。另外还有一款名为Eric的IDE软件，它把Python, PyQt集成得非常好。作者曾在树莓派卡片电脑上直接用Eric开发基于PyQt的应用程序，该卡片电脑运行一种Linux的发布版本 - Raspbian。 需要注意的是，Qt主要执行LGPL授权协议而PyQt执行 GPL授权协议。如果读者试图在一个私有代码的商业软件中应用上述组件，可能需要付费。 A.3.1.2 PyQt安装进入Windows命令行或者Linux的终端，通过pip工具安装pyqt5以及pyqt5-tools两个包。安装需要联网，并持续好几分钟，因为被安装的包是从网络软件仓库中实时下载的。 12pip install pyqt5pip install pyqt5-tools A.3.1.3 Visual Studio Code配置Qt/PyQt中包括一系列的工具，其中： 工具名称 用途 可执行文件/模块名称 Qt Designer 用即见即所得的方式设计图形界面，成果表现为扩展名为ui的文件。 designer UI Compiler 将上述ui文件“编译”成Python程序。该Python程序帮助构建ui文件所描述的图形界面。 pyuic5 Qt Linguist 语言学家，可以便捷的实现软件的国际化，即生成软件的法语、英语、日语或者其它语种版本。工作模式大致可以描述成：先用pylupdate5扫描源代码中全部可翻译的字符串，然后用linguist翻译相应的字符串至目标语言，接下来用lrelease工具发布。软件运行时，加载法语版本的语言学家文件，软件界面就是法语，加载日语版本的语言学家文件，软件界面就是日语。 linguist,pylupdate5,lrelease Resource Compiler 资源编译器。UI文件设计过程中可能需要使用到各种图片，这些图片以资源文件的形式组织，扩展名为qrc；资源编译器负责将 qrc格式的资源文件编译成py文件，其中，图片被转换成bytes-字节流。 pyrcc5 为了使用这些Qt工具，我们需要在Visual Studio Code中安装下述扩展或者其它类似功能的扩展并对扩展进行配置。Visual Studio Code上的扩展安装方法请回顾第一章相关内容。 安装完成后，上述扩展还需要进行配置才能使用，该扩展在Visual Studio Code中的配置及基本使用方法请参考下述链接：https://codelearn.club/2019/06/pyqtconfig/。 A.3.2 简单PyQt图形应用A.3.2.1 创建PyQt应用在计算机里创建一个名为BubbleSort的文件夹，比如d:\\pylearn\\BubbleSort。在Visual Source Code中打开这个文件夹，然后创建一个名为SimpleQtApp.py的程序文件，内容如下： 123456789101112131415161718#SimpleQtApp.pyimport sysfrom PyQt5 import QtWidgets,QtCoreapp = QtWidgets.QApplication(sys.argv)wdMain = QtWidgets.QWidget()wdMain.setGeometry(200,200,800,600)wdMain.setWindowTitle(\"GUI, Let's embrace the world!\")btnExit = QtWidgets.QPushButton('EXIT',wdMain)btnExit.resize(200,80)btnExit.move(300,300)btnExit.clicked.connect(QtCore.QCoreApplication.quit)wdMain.show()r = app.exec_()print(\"message loop ended.\")exit(r) 执行，得到第一个Qt图形应用的运行界面，用鼠标点一下EXIT按钮，程序运行结束。 A.3.2.2 分时系统与消息循环上面这个SimpleQtApp.py行数并不多，但要彻底理解它的工作原理却并不容易。我们得从操作系统说起。现代操作系统都是分时系统，你的计算机同时在做很多事情：浏览器、Word、音乐播放器… 读者如果打开Windows任务管理器，可以看到数十至数百个进程 - process在“同时”运行。而一个进程 ，可能又是由多个线程 - thread组成的。比如，当你的浏览器进程试图从网站上下载一个大文件时，它可能会创建一个单独的线程来下载文件，而原有的主线程则随时待命，及时处理你的命令：输入网址，点击超链接等等。 线程竞争性地使用CPU资源 操作系统管理着CPU，将CPU的时间切割成非常小的时间片。它按照效率与公平兼顾的原则将时间片分配给线程，线程获得时间片后，将执行相应的运算或其它操作。时间片用完后， 操作系统会收回CPU，将时间片分给其它线程；上述时间片的分配和回收对于应用程序而言是透明的，也就是应用程序根本不知道也无法预测或者控制时间片的获得与丧失。当一个线程被被剥夺时间片时，操作系统会保存好执行现场，包括CPU内各个寄存器的值，然后线程就挂起 - suspended。当这个被挂起的线程重新获得时间片时，操作系统会先恢复执行现场，然后通过跳转指令恢复线程的执行。由于时间片的轮转速度非常快，所以，使用者一般感觉不到应用程序的这种间断执行，似乎应用程序拥有一个“专享”的CPU。 计算机通常只有一个键盘、一个鼠标。所以我们不能认为键盘和鼠标是属于WORD的，还是浏览器的。这些应用程序在共同使用这些外部设备，计算机的系统软件-操作系统在管理这些外设资源，包括输入设备如键盘鼠标，也包括输出设备，如显示器/显卡等。 操作系统负责管理键盘鼠标并将键盘鼠标的输入分发给对应的进程 假设桌面上同时有两个窗口，如下图。这里操作者如果敲下一个键，比如c，那么首先获悉这个事件的，肯定是操作系统，因为操作系统监视着键盘输入。问题是，当操作系统获悉这个事件后，将这个事件分发给哪个应用程序呢？ 是前面的浏览器还是后面的文字编辑器呢？ 显然，操作系统遵循谁有焦点(focus)，就分发给谁的规则。事实上，所有的应用程序，它的窗口大小、窗口位置等信息都是向操作系统登记备案的，依据这些信息，操作系统决定信息的去向。为了更好的分发这些消息，操作系统会为每一个进程创建消息队列，凡是有发往这个进程的消息，操作系统就把这个消息放在对应的队列里。而应用程序的进程，则不断地从队列获取消息并处理，作出恰当的反应。应用程序不断读取消息队列并处理消息的机制称为消息循环。 ​ 总结，在分时操作系统下，一个图形应用程序的执行框架可以大致用下图刻画。 可以看到，图形应用程序启动后，在完成初始化，向操作系统注册，显示主窗口等任务后，即进入一个消息循环：周而复始的从操作系统的消息队列中获取分发给自己的消息并进行处理。比如，用户按了某个按钮，应用程序在收到这个消息后将执行对应的处理函数，以响应用户的要求。如果用户按下的是主窗口的关闭按钮（即窗口右上角的X），应用程序在收到这个消息后通常会退出消息循环，执行结束。 A.3.2.3 示例解读现在可以尝试解释本节的PyQt图形应用的代码了。 1from PyQt5 import QtWidgets,QtCore PyQt的包，我们主要用到三个，分别是： 包/模块名 说明 QtWidgets 包括一系列GUI部件，比如QMindow、QDialog等。 QtGui 包括窗口集成、事件处理、2D绘图、字体和文本等GUI元素。 QtCore 包括时间、文件及目录处理、数据类型、数据流、进程/线程等功能，属于非GUI的核心模块。 除此之外，还有一些模块：QtNetwork用于网络通信；QtSql用于关系数据库访问；QtWebKit则支持内置的网络浏览器；QtMultimedia则用于支持多媒体。 12345app = QtWidgets.QApplication(sys.argv)...r = app.exec_()print(\"message loop ended.\")exit(r) 所有的Qt图形应用程序都需要创建一个QtWidgets.QApplication对象，这个对象将负责进程的消息循环和分发。sys.argv是程序启动时的命令行参数。app.exec_()函数的实质就是应用程序的消息循环，它周而复始地从操作系统消息队列中获取用户消息/指令，然后把这些消息/指令按照Qt特有的信号-槽( signal - slot)机制分发给对应的处理函数进行处理，并做作适当响应。通常，当应用程序的主窗口被关闭后，app.exec_()函数将退出消息循环，并返回一个值表明应用的执行结果，这个值通常表明程序在执行过程中有没有出错。 读者可以再运行一次这个简单的只有一个按钮的图形应用。请注意，只有当你点击EXIT按钮，主窗口关闭后，上述print(“message loop ended.”)消息才会输出到控制台。这证明，app.exec_()函数真的是在进行消息”死”循环，它将程序“卡”在这里。 app.exec_()执行结束后，exit()函数退出Python解释器，参数r被返回给操作系统表明程序运行结果。 12345678910wdMain = QtWidgets.QWidget()wdMain.setGeometry(200,200,800,600)wdMain.setWindowTitle(\"GUI, Let's embrace the world!\")btnExit = QtWidgets.QPushButton('EXIT',wdMain)btnExit.resize(200,80)btnExit.move(300,300)btnExit.clicked.connect(QtCore.QCoreApplication.quit)wdMain.show() 中间这段代码先是创建了一个QtWidgets.QWidget对象作为应用程序的主窗口。Widget这个词大致就是窗口(Window)的另一种写法。setGeometry()方法显然设置了这个窗口在桌面上的呈现位置（左上角坐标)和像素单位长宽尺寸。setWindowTitle()则设置了窗口的标题。大多数情况下，Qt的类名、函数都具有良好自解释特性，看到名字大概就能猜出其功能。 接下来，btnExit是一个QtWidgets.QPushButton对象，就是一个按钮控件。QtWidgets.QPushButton(‘EXIT’,wdMain)的第一个参数表示这个按钮的标题，而参数wdMain表明了这个按钮的父控件，也就是按钮的拥有者是wdMain主窗口。resize()函数设定了按钮的尺寸，move()函数将按钮移动到窗口内部坐标(300,300)的位置。请注意，在GUI应用中，坐标系通常是top-left坐标系，以窗口的左上角为原点，向右x为正，向下y为正。 btnExit.clicked.connect(QtCore.QCoreApplication.quit)这一行最为关键。clicked为btnExit对象的属性，它是一个信号(signal)，而QtCore.QCoreApplication.quit可以认为是一个特殊的回调函数，称之为槽(slot)，它的功能大致是结束应用程序的运行。clicked.connect()函数则将信号clicked与槽关联起来，结果就是：当主窗口wdMain内的btnExit按钮被点击时，操作系统监控到鼠标的动作，然后将这一事件打包成一个消息，放至该应用程序的消息队列；app.exec_()内部的消息循环得到这一消息后，在内部将其处理成btnExit的clicked信号，根据信号-槽的关联，QtCore.QCoreApplication.quit槽方法被执行，跳出消息循环，程序结束。 上述代码只是”徒手”创建了wdMain窗口，而wdMain.show()函数的执行才真正将其显示出来。接下来就是app.exec_()的消息循环。 A.3.3 世界主要工业国GDP排名接下来，我们要编写一个图形应用程序，使用冒泡排序来对世界主要工业国的GDP进行排名，并演示冒泡排序的执行过程。在本书配套的网站上，你可以下载到本实践的全部代码和数据。在完成本章第一节的环境准备工作后，你应该可以打开并运行该实例。请对照代码阅读本章后续内容。 该实例的运行结果大致如下图。 A.3.4 数据及基础结构A.3.4.1 数据文件名为BubbleSort的项目目录内有一个名为countries.ini的文件，其中包括了2017年世界前15位的工业国家的GDP数据，下表列出了该文件的前几行。可见，基本数据包括国家名称，GDP值(以十亿(billion)美元为单位)，以及这个国家的国旗图片文件名称。 12345678[Countries]countries.size = 15countries[0].sName = United Statescountries[0].fGdp = 19555.874countries[0].sLogoFile = us.gifcountries[1].sName = Chinacountries[1].fGdp = 13173.585countries[1].sLogoFile = china.gif A.3.4.2 数据结构123456789101112131415#Country.pyfrom enum import Enumclass CompareState(Enum): prev = 0 #the item in comparation as prev item next = 1 #the item in comparation as next item idle = 2 #the item is not in comparation fixed = 3 #the item's position have been settled by sort algorithmclass Country: def __init__(self,name,gdp,logofile): self.sName = name self.fGdp = gdp self.sLogoFile = logofile self.compareState = CompareState.idle 在Country.py文件中，我们定义了新类Country。通过其构造函数，初始化了四个属性，依次是国家名称-sName，GDP值-fGdp，国旗文件-sLogoFile以及比较状态-compareState。 其中，比较状态是个枚举型，其值将用于界面展示（详见后）。idle表示当前这个国家对象不参与最近的冒泡比较；prev表示对象作为左元素参与冒泡比较；next则表示对象将作为右元素参与冒泡比较；fixed表明对象在序列中的位置已经确定，不会再移动了，将来也不会再参与冒泡比较。 A.3.4.3 数据读入与组织在MainWidget.py中，MainWidget的构造函数将调用initCountries()成员函数。该函数通过configparser包从”countries.ini”文件中读出数据，形成15个Country对象并置于self.countries列表当中。这些方法我们曾在本书的前述章节中讨论过。 1234567891011121314#MainWidget.pydef initCountries(self): self.countries = [] import configparser data = configparser.ConfigParser() data.read(\"countries.ini\") data = data[\"Countries\"] iSize = int(data.get(\"countries.size\",0)) for i in range(iSize): name = data.get(\"countries[&#123;&#125;].sName\".format(i),\"ERROR\").strip() gdp = float(data.get(\"countries[&#123;&#125;].fGdp\".format(i),\"0\")) logofile = data.get(\"countries[&#123;&#125;].sLogoFile\".format(i),\"ERROR\").strip() self.countries.append(Country(name,gdp,logofile)) A.3.5 界面设计在15.2节，我们“徒手”用代码创建了简单图形应用的主窗口，这样做没有问题。但更多情况下，图形界面的设计借助于那些所见即所得的设计工具将更加高效。Qt Designer就是这样一个设计工具。 A.3.5.1 基本操作在Visual Studio Code的项目目录中找到MainWidget.ui， 鼠标左键单击，打开该文件，可以看到该文件事实上是XML格式的文本文件。 在MainWidget.ui的编辑框中任意位置，右击鼠标，弹出菜单中选择Edit Form(Qt Deisnger UI File)，可以在Qt Designer中查看/编辑MainWidget.ui。受限于印刷分辨率，下图可能看不清，请读者在计算机中实际操作以查看细节。Qt Designer中的工具栏是可以调整和拖曳的，因此，读者在自己的计算机上看到的界面布局可能不完全与下图相同。读者可通过View菜单显示/隐藏工具栏。 这个界面的最左端，是Widget Box工具栏。这里包括了众多GUI组件，读者大致可以从名称和缩略图中猜出这些组件的功能：其中，Layouts属于布局类组件，它负责组织其中的下层GUI元素之间的相对位置关系；Buttons是各种操作按钮；Items Views以及Items Widgets是列表、树、及表格组件；Containers是容器类界面元素，它可以容纳下层组件；Input Widgets内的组件可以支持用户输入；Display Widgets内的组件负责在界面上显示信息。如果设计需要用到什么组件，左键单击该组件，按住不放，拖到中间界面内即可。 右上方的Object Inspector展示了当前窗口的树形结构。在Qt图形应用中，界面组件之间是存在父子从属关系的。比如，我们看到，名为pbStart的QPushButton按钮属于verticalLayout，而verticalLayout又从属于centralWidget，centralWidget又属于MainWidget，MainWidget的类型为QMainWindow。QMainWindow是Qt中的主窗口类，通常的Qt图形应用程序都应包括一个这样的主窗口。 当操作者选定一个界面组件时，可在右端中间的Property Editor中设置该界面组件的属性。当作者选中pbStart(START按钮)后，Property Editor如下图（部分属性被作者收起来了）。从该图中，我们可以看出QPushButton的继承关系：QObject -&gt; QWidget -&gt; QAbstractButton-&gt;QPushButton。QPushButton的每一个父类型都会带来一些属性，其中QObject带来了objectName，这是这个组件的对象名称。当你的代码操作或者引用这个组件时，就需要使用到这个名称。建议读者现在就展开pbStart的全部属性，从上到下看一遍，猜猜它们的用途。在本书中，组件的很多属性限于篇幅，无法一一介绍，读者需要自行查看和修改，通过观察变化来理解它们。 对于组件的名称取名，作者本人执行如下的铁律：当组件需要在代码中引用时，必须在UI设计阶段按照命令规则命名；如果组件不被代码引用，比如就是界面上的一个不需要修改显示内容的标签(Label)，允许不改名，使用UI Designer为其取的默认名。读者也可以研究一下作者在本项目中的命名，以 pbStart为例，pb为PushButton的首字母小写，Start表明其用途。 Qt Designer的右下端为Resource Browser - 资源浏览器。下图中展示了本项目中使用的各按钮的配用LOGO图片。 A.3.5.2 布局现代计算机的形式多种多样，笔记本、台式机、手机、iPad，每种终端的屏幕比例，分辨率千差万别。所以，现代界面设计，都要考虑应用界面在不同终端上的显示兼容。实现显示兼容的一个重要的工具就是布局。Qt里有4种布局组件：Vertical Layout把其下层界面组件按行布局，每行一个组件；Horizontal Layout把其下层组件按列布局，每列一个组件；Grid Layout把其下层组件按表格布局，每个单元一个组件，当然，也同时允许组件跨多行或者多列；Form Layout称为表单布局，其表现形式跟Grid Layout有些相似。在实践中，读者可以通过不种布局之间的相互嵌套才实现复杂界面布局。 本例中的MainWidget.ui使用了下述布局结构： 可以看到，START-开始，SHUFFLE-打乱，STOP-停止，ABOUT-关于，EXIT-退出这5个QPushButton处于同一个verticalLayout(类型为QVBoxLayout)中，它们从上至下等间距显示。 还可以注意到上述结构中有一个verticalLayoutCountries，它是一个垂直布局。这是全部布局中唯一一个取了正式名称的，这是因为，作者要在代码中引用它，并把参与排序的全部国家信息放置在该布局中展示。 点击verticalLayout，可以在Property Editor中修改布局属性： 从上到下，分别是布局的名称，左上右下的边距，布局间隔-即布局内各界面组件的相对距离等信息。读者可以尝试修改这些信息，同时观察界面变化。 其它布局的属性信息大同小异。 A.3.5.3 组件位置及尺寸一个组件在最终界面中的展示位置及尺寸受多方因素的制约。下图显示了STOP按钮的属性。当组件不位于任何布局容器中时，geometry中可以设置其Top-Left坐标系左上角坐标X,Y以及长宽。当组件位于布局容器中时，geometry不可用。 多数情况下，我们都会把组件放置在布局容器中。sizePolicy-尺寸策略将参与决定组件的最终尺寸。下图中，STOP按钮的Horizontal Policy为Expanding，这意味着，按钮将试图横向填满布局。STOP按钮的Vertical Policy则为Fixed，这意味着按钮的高度将为固定值，此处取了minimumSize中的Height，即120。后面的minimum Size和maximum Size则设置了组件的最大和最小尺寸。如果读者希望组件的大小是固定值，可以尝试把minimum和maximum Size设为相等的固定值。 反过来，布局中组件的minimum Size也可能影响布局的宽度，比如，界面中的tbTitle的minimum Size的Width为700，这就使得其归属容器verticalLayout_3被撑到700以上宽度。 A.3.5.4 使用图片资源在项目目录下有个子目录名为img，其中放置了本项目中各按钮使用的LOGO-图标文件。以STOP按钮为例，其对图标文件的引用信息如下： text属性设置了按钮上的显示文字；iconSize设置图标的长宽；在Normal On那里点有省略号的小按钮，可以打开如下界面： 通过这个资源选择器，可以选择按钮使用的图标。如前图所示，操作者甚至可以为按钮的不同状态指定不同的图标。点上图中的铅笔按钮可以进行资源编辑： 如图所示，作者创建了一个名为Images.qrc的资源文件，其中包括了6个图标文件，它们都在img子目录下。这些工具上有很多功能按钮，读者把鼠标焦点移上去即可看到提示文字。读者也可以在Visual Studio Code的项目目录中看到文件Images.qrc。 A.3.6 UI转PythonQt Designer的设计成果是扩展名为.ui的文件，比如本项目中的MainWidget.ui。 1234567891011121314151617181920#MainWidget.ui&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;ui version=\"4.0\"&gt; &lt;class&gt;MainWidget&lt;/class&gt; &lt;widget class=\"QMainWindow\" name=\"MainWidget\"&gt;... &lt;widget class=\"QPushButton\" name=\"pbStop\"&gt; &lt;property name=\"font\"&gt; &lt;font&gt; &lt;family&gt;Cambria&lt;/family&gt; &lt;pointsize&gt;16&lt;/pointsize&gt; &lt;/font&gt; &lt;/property&gt; &lt;property name=\"text\"&gt; &lt;string&gt; STOP &lt;/string&gt; &lt;/property&gt; &lt;property name=\"icon\"&gt; &lt;/property&gt; &lt;/widget&gt;... 作者随意从文件中摘取了数行，可以看到，我们在Qt Designer里所作的全部设计成果，都保存在这个XML文件里了，它描述了一个窗口是如何构成的。 如果在程序中需要使用它，我们还需要把UI文件“编译”成Python程序。在MainWidget.ui的编辑框中，右击鼠标，弹出菜单中选择Compile Form(Qt Designer UI File) into Qt for Python File。 在Visual Studio Code的下方控制台中自动执行了下述命令： 1pyuic5 -d -o .&#x2F;&quot;Ui_MainWidget.py&quot; &quot;d:\\pylearn\\C15_BubbleSort\\MainWidget.ui&quot; pyuic5可执行程序将MainWidget.ui翻译转换成Ui_MainWidget.py，该文件出现在项目目录中。接下来，看看Ui_MainWidget.py的内容： 123456789101112#Ui_MainWidget.pyfrom PyQt5 import QtCore, QtGui, QtWidgetsclass Ui_MainWidget(object): def setupUi(self, MainWidget): MainWidget.setObjectName(\"MainWidget\") MainWidget.resize(1077, 932)... self.tbTitle = QtWidgets.QToolButton(self.centralwidget) self.tbTitle.setEnabled(True)...import Images_rc 可以看到，Ui_MainWidget.py定义了一个新类，名为Ui_MainWidget，从object类型继承。这个类型定义了一个函数setupUi()，这个函数负责用代码创建一个MainWidget及其全部下层组件，然后把组件的全部属性都设置好。显然，setupUi()函数的内容是以UI文件为依据的。 由于Ui_MainWidget.py是由UI Compiler编译出来的，所以我们最好不要修改其代码。本章的后续部分，我们会定义一个MainWidget类，从Ui_MainWidget继承。我们将在MainWidget类中添加相关功能代码，避免对Ui_MainWidget.py的修改。 还应注意，上述Ui_MainWidget.py的最后一行，导入了Images_rc模块，这个模块应该是由Images.qrc资源文件编译而得。这是必要的，因为MainWidget中的按钮要使用资源文件中的图标内容。 A.3.7 资源编译直接在Visual Studio Code中单击Images.qrc文件，可以看到，它不过是一个列出了相关资源路径的XML文件。 12345678#Images.qrc&lt;RCC&gt; &lt;qresource prefix=\"Images\"&gt; &lt;file&gt;/images/copy.png&lt;/file&gt;... &lt;file&gt;/images/start.png&lt;/file&gt; &lt;/qresource&gt;&lt;/RCC&gt; 同样，在Images.qrc的编辑窗口中右击鼠标，弹出菜单中选择Compile Resource File into Qt for Python File。 可以看到，下述命令在Visual Studio Code的下方控制台中被执行，Images_rc.py文件被生成出来。 1pyrcc5 -o .&#x2F;&quot;Images_rc.py&quot; &quot;d:\\pylearn\\C15_BubbleSort\\Images.qrc&quot; 打开Images_rc.py，可以看到，资源文件被转换成了bytes字节流，以便后续利用。 123456789#Images_rc.pyfrom PyQt5 import QtCoreqt_resource_data &#x3D; b&quot;\\\\x00\\x00\\x22\\xb9\\\\x89\\\\x50\\x4e\\x47\\x0d\\x0a\\x1a\\x0a\\x00\\x00\\x00\\x0d\\x49\\x48\\x44\\x52\\x00\\\\x00\\x02\\x00\\x00\\x00\\x02\\x00\\x08\\x06\\x00\\x00\\x00\\xf4\\x78\\xd4\\xfa\\... A.3.8 BubbleSort.pyBubbleSort.py是程序的启动文件。可以看到，它首先创建了一个app对象， 然后创建了MainWidget主窗口（见后节）mw，并执行mw.show()将其显示出来。最后，app.exec_()函数开始消息循环。该应用程序将不断地查询操作系统消息队列，等待操作者的下一步指示。 1234567891011#BubbleSort.pyimport sysfrom PyQt5 import QtWidgetsimport MainWidgetapp = QtWidgets.QApplication(sys.argv)mw = MainWidget.MainWidget()mw.show()exit(app.exec_()) A.3.9 MainWidget.py这是我们新建的程序文件，它是应用程序的主窗口。可以看到，MainWidget有两个父类，分别是QMainWindow和Ui_MainWidget。QMainWindow是Qt里表示主窗口的父类。Ui_MainWidget是我们使用UI Compiler从MainWidget.ui“编译”生成的，MainWidget从这个父类里继承了setupUi()函数。通过这个函数，MainWidget对象创建了正确的组件结构，比如，创建了一个名为pbStart的QPushButton对象。pbStart同时也是MainWidget对象的属性。在MainWidget.py中，一般地，使用self.pbStart就可以引用这个按钮对象。 12345678#MainWidget.pyfrom PyQt5 import QtWidgets,QtGui,QtCoreimport Ui_MainWidgetclass MainWidget(QtWidgets.QMainWindow,Ui_MainWidget.Ui_MainWidget): def __init__(self,parent=None): super(MainWidget,self).__init__(parent) self.setupUi(self) A.3.9.1 国家列表组件1234567891011#MainWidget.pydef createPanelCountries(self): for i in range(len(self.countries)): panel = QtWidgets.QToolButton(self.centralwidget) panel.setFixedHeight(52) panel.setSizePolicy(QSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed)) panel.setFont(QtGui.QFont(\"Cambria\",16)) panel.setIconSize(QtCore.QSize(64,48)) panel.setToolButtonStyle(QtCore.Qt.ToolButtonTextBesideIcon) self.verticalLayoutCountries.addWidget(panel) self.panelCountries.append(panel) 如前所述，国家及其GDP数据存储在self.countries列表中。上述createPanelCountries()成员函数则创建相同数量的QToolButton-工具按钮，并存放在self.panelCountries列表当中。这些QToolButton用来显示对应国家的国旗、国名和GDP。 self.verticalLayoutCountries.addWidget(panel)将创建好的工具按钮加入verticalLayoutCountries布局容器，国家与国家将竖向排列，一行一个。从上到下，上述代码还设置了QToolButton的固定高度、SizePolicy-尺寸策略、字体、图标大小、以及工具按钮风格 - 图标在左，文字在旁。请注意，QToolButton的横向尺寸策略为Expanding，这意味着，代表国家的工具按钮将横向扩展，尽可能填满verticalLayoutCountries的横向空间。 需要说明的是，作者在这里用QToolButton组件来显示国家信息完全是因为方便。在运行的界面中，虽然操作者可以点击界面中代表国家的QToolButton，但不会有任何反应。 A.3.9.2 国家列表显示1234567891011121314151617#MainWidget.pydef displayCountries(self): if len(self.panelCountries) == 0: self.createPanelCountries() assert len(self.panelCountries) == len(self.countries) for x, y in zip(self.panelCountries,self.countries): x.setText(\" \" * 10 + \"$&#123;:&lt;30,.2f&#125;&#123;&#125;\".format(y.fGdp,y.sName)) x.setIcon(QtGui.QIcon(\"img&#123;&#125;&#123;&#125;\".format(os.sep,y.sLogoFile))) if y.compareState == CompareState.prev: x.setStyleSheet(\"background-color: rgb(255, 255, 0);\") elif y.compareState == CompareState.next: x.setStyleSheet(\"background-color: rgb(255, 0, 0);\") elif y.compareState == CompareState.fixed: x.setStyleSheet(\"background-color: rgb(0, 255, 0);\") else: x.setStyleSheet(\"\") 在MainWidget的构造函数中，调用了displayCountries()成员函数来完成国家列表的显示。该函数首先检查国家列表组件是否已创建，如果没有，则调用self.createPanelCountries()创建国家列表组件。 接下来，zip()函数将self.panelCountries和self.countries进行了序列缝合，然后再用for循环遍历。在循环体内部，y代表一个Country对象，x则是对应的QToolButton。根据y中的国家名称、GDP，我们设置了对应QToolButton的显示文本-setText()；根据y中的国旗图片文件名，我们设置了QToolButton的图标-setIcon()；最后，根据y中的compareState枚举值，我们还设置了QToolButton的样式-setStyleSheet()，改变其背景色，以表示对应的国家在当前排序进行程中状态：两两比较的左、右元素，已排序到位或是暂不参与比较。 A.3.9.3 按钮可用性按下”START”按钮，冒泡排序将开始。而在排序开始后，”START”按钮如果还可以点，则会引起不少逻辑问题。为了避免诸如此类的问题，MainWidget.py中定义了下述函数： 1234567891011121314#MainWidget.py def setToRunningState(self): self.pbStart.setEnabled(False) self.pbStop.setEnabled(True) self.pbShuffle.setEnabled(False) self.pbAbout.setEnabled(False) self.pbExit.setEnabled(False) def setToIdleState(self): self.pbStart.setEnabled(True) self.pbStop.setEnabled(False) self.pbShuffle.setEnabled(True) self.pbAbout.setEnabled(True) self.pbExit.setEnabled(True) 排序开始时，将执行setToRunningState()函数设置到运行态，将“STOP”按钮置为可用，而将其它按钮全部禁用（Disabled）。排序结束后，设置为空闲态的setToIdleState()函数将被执行，此时，除了”STOP”之外的按钮都将被设置成可用（Enabled）。 A.3.9.4 打乱顺序123456#MainWidget.py def on_pbShuffle_released(self): random.shuffle(self.countries) for x in self.countries: x.compareState = CompareState.idle self.displayCountries() 从”countries.ini”读取的原始数据是有序的，排序前需要先打乱。按下”SHUFFLE”按钮，上述成员函数将会被执行(背后的机制请见本章后续部分)。这个函数使用random模块把self.countries列表内的元素随机打乱。然后，把所有Country都设为“暂不参与比较的空闲状态”，再执行displayCountries()刷新界面上的国家列表。 A.3.10 信号与槽不同的操作系统在消息循环机制方面存在差异。为了做到跨平台，Qt定义了一套消息分发处理机制，称为信号(signal)和槽(slot)。 信号大概就是消息的同义词，当我们按下某个按钮、或者在主窗口处于活动状态时按下某个键盘键，都将触发一个至多个信号。app.exec_()函数内部的消息循环将处理并分发这些信号至对应的信号处理程序，也就是槽。 在PyQt里，槽通常是个函数。我们可以将信号和槽连接(connect)起来，即信号被触发后，槽函数将在主线程中被调用执行。一个信号可以与一个或者多个槽相连接，也可以一个都不连。 在本实践中，我们使用了两种方法将信号及槽关联起来。其中，一种就是前节中的on_pbShuffle_released()函数，这个成员函数的函数名有点奇怪，以on开头，然后是pbShuffle按钮对象，最后是released。这种成员函数的命名形式其实是PyQt的一种约定：当pbShuffle按钮被鼠标点击触发其released信号后，执行on_pbShuffle_released()函数。PyQt会扫描你的代码并将符合这种名字约定的信号和槽自动连接起来。 另一种方法我们已经在15.2节中见过了。btnExit.clicked.connect(QtCore.QCoreApplication.quit)将btnExit按钮的clicked信号与QtCore.QCoreApplication.quit槽函数连接起来。 A.3.11 主线程app._exec()中的消息循环在程序进程的主线程中运行，主线程主要负责处理这样一些任务： 主线程的使命 - 执行消息循环，消息的解释和封装，信号的分发；调用执行同信号连接的槽函数； - 界面内容的显示与刷新。 上述信息告诉我们两件事。第一，不要在主线程中处理耗费时间过长的任务。因为如果主线程花费时间片去处理耗时工作-比如向邮件服务器提交一个邮件发送申请，那么在这些耗时的任务未完成之前，主线程是没有时间通过消息循环去接收响应你的指令的。此时，应用程序就有“卡”住的现象：它会不理你，并且界面也不再刷新。 第二，不要在非主线程的其它线程中处理与界面有关的事情，比如修改一个按钮的图标之类。因为，这些都是主线程的任务。当主线程和其它线程竞争性的“同时”使用一些资源时，可能会引起麻烦。 A.3.12 排序线程实际上，15个国家的GDP冒泡排序花不了多少时间，不属于“耗时”工作的范畴。但由于我们需要演示冒泡排序的执行过程，这意味着，冒泡排序每执行一步， 都需要刷新一下国家列表的显示状态，休息一会儿再继续。这种事情，线程最在行。SortRunner.py定义了本实践中的排序线程。 12345678910111213141516171819202122232425262728293031323334#SortRunner.pyfrom PyQt5 import QtCorefrom Country import CompareStateimport timeclass SortRunner(QtCore.QThread): updateInformer = QtCore.pyqtSignal() def __init__(self, countries, parent): super().__init__(parent) self.countries = countries def run(self): for x in self.countries: x.compareState = CompareState.idle self.updateInformer.emit() time.sleep(0.2) for i in range(len(self.countries)-1,0,-1): for j in range(0,i): self.countries[j].compareState = CompareState.prev self.countries[j+1].compareState = CompareState.next self.updateInformer.emit() time.sleep(0.5) if self.countries[j].fGdp &lt; self.countries[j+1].fGdp: self.countries[j],self.countries[j+1] = \\ self.countries[j+1],self.countries[j] self.updateInformer.emit() time.sleep(1.0) self.countries[j].compareState = CompareState.idle self.countries[j+1].compareState = CompareState.idle self.countries[i].compareState = CompareState.fixed self.countries[0].compareState = CompareState.fixed self.updateInformer.emit() return SoftRunner类是QtCore.QThread的子类，QThread是Qt定义的线程祖先类。构造函数接受一个countries列表并将该列表存于self.countries属性。当然，通过super().__init__()执行QThread的构造函数是必不可少的。 run()成员函数是这个线程的实际执行体，里面就是在对self.countries列表进行冒泡排序。注意这里排序比较的不是Country对象本身，而是比较Country的fGdp属性：self.countries[j].fGdp &lt; self.countries[j+1].fGdp。在排序的进行过程中，还有几件事情值得注意： 排序算法会修改Country的compareState枚举值，以便MainWidget显示国家列表时标识排序进度。 排序算法会时不时执行self.updateInformer.emit()，这里的updateInformer是一个信号对象，通过QtCore.pyqtSignal()函数创建。其emit()函数将触发这个信号。当这个信号被触发后，与之连接的MainWidget.py当中的槽函数handlerUpdateInformer将执行并刷新国家列表显示。updateInformer信号与handlerUpdateInformer槽函数的连接在后节中叙述。请读者注意这里的updateInfomer信号对象是一个类属性。 123#MainWidget.py def handlerUpdateInformer(self): self.displayCountries() 排序算法在触发了updateInformer信号后会执行time.sleep()函数，参数单位为秒。time.sleep(0.5)将会主动向操作系统让出时间片，将告知操作系统，0.5秒之内我不再需要时间片，我要休息一会儿。时间到后，重新获得时间片的线程将继续排序过程。如果读者想把排序演示过程进行得慢一点，可以把time.sleep()中的时间延迟改长一点。 A.3.13 线程间的协调回到主线程中运行的MainWidget.py，”START”按钮点击后，下述槽函数将被执行： 12345678910111213#MainWidget.py def on_pbStart_released(self): if self.sortRunner != None: if not self.sortRunner.isFinished(): self.sortRunner.terminate() assert self.sortRunner.wait(2000) self.setToRunningState() self.sortRunner = SortRunner(self.countries,self) self.sortRunner.updateInformer.connect(self.handlerUpdateInformer) self.sortRunner.finished.connect(self.setToIdleState) self.sortRunner.start() 出于稳妥的考虑，代码首先检查了上一次排序操作的线程是否已执行完-isFinished()，如果没有执行完，终止-terminate()，然后等待直到其事实上终止-wait()。如果等待超出2000ms，断言失败。 接下来，将界面设置至运行态，除”STOP”之外的按钮都不再可用。然后，创建了SortRunner线程对象并将self.countries列表数据传递给它。注意，由于“名字绑定”的关系，SortRunner内如果修改了countries内的元素，MainWidget的self.countries也会改变（两者事实上是同一个列表）。 self.sortRunner.updateInformer.connect(self.handlerUpdateInformer)将sortRunner的updateInfomer信号连接至handlerUpdateInformer槽函数。这意味着，当sortRunner线程触发该信号后，该信号将会进入app.exec_()内的消息循环，主线程收到这个消息/信号后将调用对应的槽函数。对于操作系统而言，主线程和排序线程各自独立地领取时间片，排序线程只管触发信号，至于信号的槽函数何时被主线程执行，就不得而知了。但一般的，只要CPU不是过于繁忙，都会很快执行。 self.sortRunner.finished.connect(self.setToIdleState)这一行将sortRunner的finished信号连接到setToIdleState槽函数。finished信号是从QThread类继承过来的，它表明线程的run()函数已执完并返回。线程结束即排序结束，setToIdleState将界面设置成空闲态，”START”等按钮重新变得可用。 另外，pbStop也有对应的槽函数： 1234#MainWidget.py def on_pbStop_released(self): assert self.sortRunner != None self.sortRunner.terminate() terminate()要求终止sortRunner线程的执行。当它真正被终止时，其finished信号将被触发，MainWidget.py内的setToIdleState槽函数将被主线程执行，界面恢复至空闲状态。 到这里，我们终于说完了程序的主体部分，Enjoy it! A.3.14 关于对话框为了向读者展示如何打开一个对话框(dialog)，实例中还加入了一个“ABOUT”按钮功能。这很重要，因为，绝大多数应用程序都有一个主窗口及多个对话框子窗口。 About.ui是用Qt Designer设计的，编译之后有了 Ui_About.py。然后继承之，得About.py中的About类，请注意，About的父类不再是QMainWindow或者QWidget，而是QDiaglog - Qt中的对话框祖先类。 1234567891011#About.pyfrom PyQt5 import QtWidgetsfrom Ui_About import Ui_Aboutclass About(QtWidgets.QDialog,Ui_About): def __init__(self,parent): QtWidgets.QDialog.__init__(self,parent) self.setupUi(self) def on_pbClose_released(self): self.close() ​ 在MainWidget.py里： 1234#MainWidget.pydef on_pbAbout_released(self): dlg = About.About(self) dlg.exec() dlg.exec()使得对话框以模式对话框(modal dialog)形式执行，这意味着，在这个对话框结束之前，你无法再操作背后的主窗口。非模式对话框的执行函数为dlg.show()。 A.3.15 有坑请注意1234#MainWidget.pydef on_pbAbout_released(self): dlg = About.About(self) dlg.exec() 如上图，在本实践中，我们一直在响应QPushButton的released信号而不是clicked信号。在传统习惯中，clicked表示按钮被鼠标点击一次。至少在PyQt里，事实不是这样，我们尝试一下把上述代码改成响应clicked信号： 12def on_pbAbout_clicked(self): print(\"About button clicked.\") 运行后，点一次About按钮，可以注意如下控制台输出，看起来，一次鼠标点击导致了两次clicked信号的发射。据推测可能是Qt内部把鼠标按下与鼠标弹起分别当成一个clicked事件处理。部分初学者不明就里，响应clicked信号进行事件处理，遇到了很多无法解释的软件BUG。作者提醒读者记住这一点，PyQt图形应用中，对于按钮，标准方法是响应released信号。 12About button clicked.About button clicked. A.3.16 小结这一章的实例功能并不复杂，但信息量很大。Qt是个非常复杂，功能强大的跨平台GUI软件开发工具包。本实例只是起到把读者领进门的作用。如果读者真的希望用PyQt做点复杂的图形应用，还需要消化很多的资料，本章节远远不够。 另外，本实例中，SortRunner只管排序并向主线程发出界面刷新请求；而MainWidget.py中的代码只管展示和协调工作，不参与排序细节。MainWidget.py中的self.countries是国家列表的数据，self.panelCountries是国家列表显示的按钮列表，两者相互独立，仅在displayCountries()函数中同时使用两个列表：数据和展示是分开的。 这些细节处理试图降低程序不同部分之间的耦合度， 以达到所谓松散耦合的目的。而松散耦合的程序，容易理解和维护。 本书同名免费MOOC《Python编程基础及应用》在哔哩哔哩（B站）热播，点击加入，作者带着你学。 练习15-1 本实践中，SortRunner线程需要使用countries列表，MainWidget.py中的主线程也在使用同一个countries列表进行数据展示。事实上，两个线程在竞争性地使用该资源，有时，这样做会带来后果。我们希望有一种机制，可以确保同一时间，仅有一个线程使用该资源-countries列表，如果另一个线程需要用，则稍等等，等另一个线程使用完后再用。请查询资料，解决该问题。 提示：关键词mutex, 互斥锁。 15-2 试着修改本实践，增加一个进度条，显示排序进展到总进程的百分之多少。 15-3 本实践中，为了实现排序进程的演示并保证界面的及时响应，我们启用了排序线程。就本实践而言，使用定时器可以达到类似目的。请修改程序，改用定时器实现相同功能。提示：资料查询关键词QTimer, PyQt5。 15-4 在实践中，人们极少自行编写排序代码进行排序，而是尽可能地借助于列表的sort函数实现排序。就本实践MainWidget.py中的self.countries列表，请借助于列表的sort()函数，将该列表按GDP升序排序。 提示：key参数可以指向某个自定义函数或者lambda函数，该函数接受一个Country对象参数，返回该对象的GDP值。","categories":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/tags/Python/"}]},{"title":"那门用Python讲授的程序设计课程能带给学生什么？","slug":"pylesson","date":"2020-09-07T09:48:14.000Z","updated":"2020-09-07T14:16:30.848Z","comments":true,"path":"2020/09/pylesson/","link":"","permalink":"http://codelearn.club/2020/09/pylesson/","excerpt":"那门用Python讲授的程序设计课程能带给学生什么？","text":"那门用Python讲授的程序设计课程能带给学生什么？ 那门用Python讲授的程序设计课程能带给学生什么？海洋饼干叔叔 @ 重庆大学 最近这几年，Python火上天了。历史上，即便是Python它菩提老祖C语言（Python解释器是用C语言写的），也从未那么火过，毕竟在C语言刚出来那个年代，计算机只有很有钱的人家（比尔盖茨他妈是IBM董事，社会活动家）才有，编程还是少数技术人员拥有的特殊技能。 Python火起来的最大原因是所谓人生苦短，我用Python。易学易用的特点使得编程不再是需要专业训练的特殊技能，下至高校教师，家里的小祖宗，上至家里管钱管厨房的领导，进行引力波探测的顶尖科学家，都可以使用Python来编程。什么？不信？我们选择一个特别的角度证明给你看：下面是各种牛掰语言的爹地合集， 包括C++他爸Bjarne Stroustrup, Java之父James Gosling，PHP他爹Rasmus Lerdorf, Go语言之父Rob Pike， 以及造就Python的伟大“河（去声）南“ 雷峰 - Guido van Rossum。猜猜这几张照片哪位是Python之父Guido van Rossum ? 答案就是： 头发最茂盛那位！ 工业界为之疯狂，阿里https://edu.aliyun.com/course/505微软https://www.bilibili.com/video/av69042526/谷歌https://developers.google.com/edu/python/ 都推出了自己的专属Python课程，急吼吼地想培训和吸引P8以上的有福报能加班的年轻人。好像不免费提供一点像样的Python课程，都不好意思说自己是负责任的国际大公司。 中国的教育界也疯了，先是浙江传出消息，管教育那帮人终于睡醒了，从高中课标里删除了老掉牙，没人用的Visual Basic, 用Python替代，顺带着把Excel, Access也踢出了课标，因为Excel, Access能干的活好像Python也能干。 然后，山东，上海，北京，重庆相继表示，我们也不能落后，除了往中学课标里加入Python内容外，还顺带把”先进的科学”直接送到“我们的祖国是花园”，小学六年级的《信息技术-Python入门》给大家感受一下。 看这架势，Python进入高考已是板上钉钉，以后的泱泱中华，要想再找出一个没学过编程的小朋友，真如大海捞针一般困难。 中小学都上了， 大学自然也要上。无论是中国还是美国，Python正取代C/C++语言，成为大学最受欢迎的编程入门课程。大学里讲编程基础课的老师好像也松了一口气， 终于不会因为C语言劝退诸多懵懵懂懂的小朋友了。要知道，C语言以”从入门到放弃“而闻名而世，特别当你选用早期的C语言书作为教材的时候。在那个年代，学习编程的大多是一些智商超群的人，所以彼时的作者高估了读者的智商，专门挑一些没什么大用处，然后又特别烧脑的断头路（比如i = i++ + ++i，i之前等于0，问之后等于几？），死路，带着萌新们一条道走到黑，，，成功降低了程序员市场的竞争烈度。这么说其实对当时的作者也不太公平，老先生的书，在当年已经算是很浅显的了，在向社会普及计算机及编程知识方面，功勋卓著。 所谓内行看门道，给大一，大二的小鲜肉们上菜，不能太马虎。上一门借Python之名的程序设计课程，显然不能只讲语法，那是舍本逐末之举。作者在某985大学教了15年编程（从C, C++一直教到Python），又同时在工业界当了15年程序员，还跨圈画了数年的电路图，还曾经对着三视图跟模具工程师、结构工程师讨论过公差配合，运动噪声消除，材料耐用性之类的“高深”问题，，，，， 大着胆子，分享一下一家之言： Python程序设计课应该带给学生什么？ 1. 算法 - 用计算机解决问题的思维习惯乔帮主（布斯）留下话：学习编程教你如何思考。孔夫子也说过，学而不思则罔。所以不管学生的层次（985，211，三本，专科， 高职）如何，一定要在课程里带点算法以及使用算法解决问题的例子给他。包括但不限于下述示例，它们都是用Python写的，大部分都是带图，带动画的。（如果一直print, 老师学生都会疲倦） 发现圆周率 - 使用投点方法，借助于均匀分布的随机数函数，重新估算圆周率 一对兔兔与函数的增长 - 讲述著名的斐波那契数列， 以及函数的递归调用， 嗯，再帮助学生回顾一下《高等数学》中无穷大的阶的不同在计算机里如何体现，我们把斐波那契数列与n2, n3函数进行了作图比较，观察函数的增长速度 汉诺塔 - 递归求解的经典案例，古老的印度智慧 文本进度条 - 旧科技时代的回望 2. 语言 - 简单实用的语法变量与数据类型、缩进、输入输出、条件分支、列表、名字绑定、循环、字典、函数抽象、文件的读写、高级的字符串处理这些都是必不可少的语言知识。但笔者认为，面向对象也是一种思维方式和设计哲学，不可或缺。所以，在程序设计课程里应该有面向对象的一席之地。 除此之外，异常处理、单元测试、类序列化、迭代器与生成器等则属于非必要的语法知识，其讲授可根据学生的层次，以及学习目标而定。 对于C/C++这类复杂的语言，即便是一个熟练的程序员，也大概只会使用到其中20%的特性，另外80%则几乎不用。对Python而言，情况好一些，在选择课程内容时，应该挑出那些实用的，常用的语法特性加以认真发挥，而对于那些生僻的，生僻且晦涩难懂的，不讨论为妙。 但是，对于那些重要的特性，比如range(), 比如切片语法，则一定要讨论清楚。作者相信：图比文字清楚，所以画很多的流程图来帮助解释数值列表与切片及其他关键的语法： 总之， 语法的介绍要从实用出发， 而不是“考试”出发，象 i++++ 这种类型的“劝退”语法，坚决不涉及。 3. 代码 - 优美的编程习惯示范好的代码应该读起来跟散文一样优美。所以教材中给学生的示例代码大部分长这样：有行号，字体优美，匈牙利命名法则，连字体也精心选择的。 我们相信，学生会模仿老师的代码。老师的代码如果质量高，学生会潜移默化地学到优美，良好的编码风格和习惯。在书里面，我们还经常提及断言、单一职责原则、单元测试等简单的软件工程原则，希望在教授表面语法同时，顺便传递一点“内功”。 4. 实践 - 与专业相结合 我一个学新闻的，为什么要学编程？ 我们法学院，开个毛线编程课！ 我只想静静地做个医生，不行么？ 隔壁数理学院，开编程课，为什么我们学土木的也要开？ 这是非计算机专业的学生在学习编程时的常见抱怨。 原因有二： a. 课程内容与实践脱节，为教而教，为考试而学，学完就忘； b. 课程里的案例与学生的专业没有关系，学生没有获得用编程方法解决本专业问题的体验。 为了解决这个问题，我们设计了很多示例，涉及数学、美术、文学、历史、信号处理、医学、经济学、游戏、科学计算、人工智能等众多学科门类和领域。众多不同专业的学习者，都可以在本书中找到与本专业相关的应用实例。放几个大家感受一下。这些示例，有难有易。事实上，考虑到部分示例的复杂性，我们并不指望大一年级的新生能够完全读懂，我们只是希望让明白，学好编程，对他的专业发展颇有助益。 一棵树的建造 - 树形数据结构、递归、分形、树的宽度优先遍历算法 汉诺塔 - 定时器、pygame框架、汉诺塔算法、计算复杂性分析、复杂程序的结构、生成器 GDP前15工业图家的冒泡排序演示 - 多线程、GUI程序设计、PyQt、分时图形界面程序框架 图像风格迁移 - 深度学习、神经网络 缙湖下雨啦 - matplotlib动画、numpy多维数组 Mandelbrot集合 - 分形数学的开山之作 对ECG信号进行数字滤波 唐全诗数据分析 - 关系数据库、字典、数据分析 5. 手把手的私教学习体验新形态＂电纸＂书，凡是涉及实践操作的每一步，都有视频／图文步骤指导，扫扫二维码，轻松可得。 全书提供数百个二维码，提供在线课堂、先睹为快、操作指导、扩展阅读等各种在线协助。为读者的编程学习提供手把手＂私教＂。 6. 配套火爆B站的在线MOOC，学习轻松不怕难 写到了这一步，我的小心机藏不住了，对，我就是向读者推荐优质Python入门教材的，它长这样，某东、某宝、某当有售。 《Python编程基础及应用》","categories":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/tags/Python/"}]},{"title":"如何下载《Python编程基础及应用》课程的源代码(pylearn)","slug":"getpycode","date":"2020-05-04T09:21:04.000Z","updated":"2020-10-10T14:26:20.634Z","comments":true,"path":"2020/05/getpycode/","link":"","permalink":"http://codelearn.club/2020/05/getpycode/","excerpt":"各位后浪/幼浪，为了让更多人能够看到这门课程，UP主需要各位的转发支持。 获得《Python编程基础及应用》课程的源代码（pylearn, 30多MB)的方法如下。","text":"各位后浪/幼浪，为了让更多人能够看到这门课程，UP主需要各位的转发支持。 获得《Python编程基础及应用》课程的源代码（pylearn, 30多MB)的方法如下。 方法1如果你是高等教育（含高等职业教育）在校生，请将下述信息： 大学名称， 院系或专业， 贵校贵系的编程课课程名称， 教师姓名， 教师的邮件地址或者QQ号 举例： 重庆大学 通信 C语言程序设计 许三多 xsd@qq.com 通过下述渠道之一发给海洋饼干叔叔，UP主会尽量及时回复并提供下载地址： 648774553@qq.com 发邮件 通过加入读者互助群，在群中私信给 陈哥-私信不回答 方法2第1步 https://www.bilibili.com/video/BV1kt411R7uW 打开上述链接，分享至下述渠道之一： 微信朋友圈，集赞20个； QQ空间，集赞20个； 成员至少100位的同学群、年级群、同事群、学习群【 分享3分钟后再截图，截图中可以看到截图时间与分享时间相差3分钟以上， 作者也不想这样，但很多缺乏责任感的读者发完就截图，截图完就立即撤回， 让人很沮丧 】。 分享时需要加上下述文字： 我正在B站上学习Python，重庆大学海洋饼干叔叔讲得还行，细致，又没有废话，特别适合零基础小白，推荐给大家一起看… 课程是免费的，但需要转发才能获得作者的源代码，抱歉打扰到大家。 第2步​ 加入下述读者交流互助QQ群之一，把截图发群里，并@陈叔-私信不回答。 群主或管理员会发下载链接给你。 （部分群可能已满员）。 群号：1080059098 群号：593202212 群号：162436874","categories":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/tags/Python/"}]},{"title":"B站Python课程 - 重庆大学海洋饼干叔叔","slug":"pyad","date":"2020-05-04T09:06:04.000Z","updated":"2020-05-04T09:16:28.209Z","comments":true,"path":"2020/05/pyad/","link":"","permalink":"http://codelearn.club/2020/05/pyad/","excerpt":"我正在B站上学习Python，重庆大学海洋饼干叔叔讲得还行，奶妈级贴心，又没有废话，特别适合零基础小白，推荐给大家一起看…","text":"我正在B站上学习Python，重庆大学海洋饼干叔叔讲得还行，奶妈级贴心，又没有废话，特别适合零基础小白，推荐给大家一起看… 课程访问地址： https://www.bilibili.com/video/BV1kt411R7uW/","categories":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/tags/Python/"}]},{"title":"delete[ ]如何确定动态数组的元素个数？","slug":"delete","date":"2020-03-31T15:46:04.000Z","updated":"2020-03-31T15:53:17.898Z","comments":true,"path":"2020/03/delete/","link":"","permalink":"http://codelearn.club/2020/03/delete/","excerpt":"本文研究并解释delete [ ]操作符如何确定动态数组的元素个数。 本文转载自重庆大学2019级风流倜傥的于卓浩同学的文章：https://puluter.cn/20200331/delete/ [上述形容词是海洋饼干叔叔加的，与事实相符] 稍有修改。","text":"本文研究并解释delete [ ]操作符如何确定动态数组的元素个数。 本文转载自重庆大学2019级风流倜傥的于卓浩同学的文章：https://puluter.cn/20200331/delete/ [上述形容词是海洋饼干叔叔加的，与事实相符] 稍有修改。 1. 简介在面向对象编程中，我们经常会用到这样的动态分配数组： 1Person* a = new Person[100]; 在上述申请数组的过程中，我们使用到了new []这个表达式来完成，它会调用类的构造函数初始化这个数组的所有对象，有多少对象，就会执行多少次构造函数。如果我们用完了这个数组，想要释放空间，就需要调用： 1delete[] a; 在这个过程中，我们使用了delete[]操作符来完成对象释放。但是两个问题出现了： 如何知道a数组的内存空间大小？ 如何知道要调用几次析构函数（a数组的元素个数）？ 显然，想要知道数组有多长，我们必然要存下这个数组的长度。C++中也正是这么做的。本文讨论具体工作原理。 2. 结合代码的分析 注：本文适用于64位mingw。在32位mingw下后文内8字节应为4字节，long long应为int。 我们先定义一个自定义的类。 12345678class Yu &#123;public: int iNumber;//Yu类内将只有这一个int变量 //即 一个Yu对象的大小=一个int的大小=4字节 Yu()&#123;iNumber = 1;&#125; ~Yu()&#123;&#125; ...&#125;; 同时，在main中声明一个长度为len(20194134)的Yu类型的数组，再获取该数组开头的地址并打印。 12345678const long long len = 20194134;int main()&#123; ... Yu* testArr = new Yu[len]; char* p1 = (char*) testArr; cout &lt;&lt; \"Address for the Array: \"&lt;&lt; testArr &lt;&lt;endl; ...&#125; 输出为：Address for the Array: 0x2670048 理论上，20194134个Yu对象，总共需要 20194134 x sizeof(Yu) = 80776536字节的空间。实际申请的堆（自由内存区）空间稍有出入，我们可以通过重载new [ ]操作符来研究。 我们重载new[]了操作符： 12345void* operator new[](size_t sz)&#123; printf(\"|Length: %lld\\n|Real Size: %lld\\n|Raw Size(int(4)*length): %lld\\n|Gap: %lld\\n\",len,sz,len*4,(long long)sz-len*4); void* o = malloc(sz); return o;&#125; 在这个过程中，我们打印四个关键数值： 数组的长度(len) new[]过程中实际申请的内存空间大小(sz) 数组理论上需要的内存空间 （数组长度 x sizeof(Yu) = len x 4 ) 实际空间与理论空间的差 ( sz - len x 4) 上述程序的执行结果为： 1234|Length: 20194134|Real Size: 80776544|Raw Size(int(4)*length): 80776536|Gap: 8 这里会发现，编译器传递给new [ ]操作符的空间大小比实际需要多8个字节。而8个字节，恰好是一个long long变量的大小，实践中，这8个字节用于存储动态数组的元素个数。 为了弄清楚这8个字节的具体位置，我们重载了delete [ ]函数： 1234void operator delete[](void *o)&#123; cout&lt;&lt;\"Destruct from: \"&lt;&lt;o&lt;&lt;endl; free(o);&#125; 12345678int main()&#123; ... char* p1 = (char*) testArr; cout &lt;&lt; \"Address for the Array: \"&lt;&lt; testArr &lt;&lt;endl; ... delete[] testArr; return 0;&#125; 最后几行的输出为： 123Address for the Array: 0x2670048...Destruct from: 0x2670040 成了！我们发现，解构时得到的地址（0x2670040）恰好是数组的地址（0x2670048）减8。即：0x2670048 = 0x2670040 + 8接下来，我们更进一步，取出数组地址-8对应地址的一个long long变量，看一下它的值会是什么. 接下来获取该数组前的8字节，识别为long long并打印。 12345678int main()&#123; ... char* p1 = (char*) testArr; cout &lt;&lt; \"Address for the Array: \"&lt;&lt; testArr &lt;&lt;endl; cout&lt;&lt; \"The long long before the Array: \" &lt;&lt; *(long long*)(p1-len_ll)&lt;&lt;endl; delete[] testArr; ...&#125; 输出为： 123Address for the Array: 0x2670048The long long before the Array: 20194134 【这个值就是数组长度】Destuct from: 0x2670040 代码给出的结果证明了前述的猜想：自定义类数组前的8个字节，是一个long long类型的变量，储存了该数组的长度。 3. 结论 我们以Yu* a = new Yu[2]为例进行说明。表面上，我们需要sizeof(Yu) x 2共8个字节的空间，但事实上，new [ ]操作符会从堆里申请8 + 8 = 16个字节的空间。其中，前8个字节用于存储数组的元素个数，后续空间用于存放数组元素。具体到本例，变量a得到的是数组首元素的地址，它事实上等于真实的堆空间地址 + 8！ 当delete [ ]a被执行时： delete [ ]操作符会把a值 - 8，获得真实的堆空间首地址； 从堆空间首地址获得数组的元素个数（本例为2）； 依据元素个数及a值逐个执行全部数组元素的析构函数； 最后，以堆空间首地址为依据，通过free( )函数向操作系统归还堆空间。 本例中，如果执行delete a而不是delete [ ]a，可能导致两个后果： 仅有数组的首元素被正确析构； 释放堆空间时向操作系统提供的地址是不正确的，后果未知。 正是基于上述理由，书里反复强调，new/delete, new [ ] /delete [ ]要配对使用。 4. 完整实验代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;const long long len = 20194134;class Yu &#123;public: int iNumber; Yu()&#123;iNumber = 1;&#125; ~Yu()&#123;&#125; //重载 new[]操作符 void* operator new[](size_t sz)&#123; /*打印四个关键数据： ①数组的长度 ②new[]过程中申请的内存空间大小 ③数组实际需要的内存空间 ④ ②、③的差值 */ printf(\"|Length: %lld\\n|Real Size: %lld\\n|Raw Size(int(4)*length): %lld\\n|Gap: %lld\\n\",len,sz,len*4,(long long)sz-len*4); //完成内存分配 void* o = malloc(sz); return o; &#125; //重载delete[]操作符 void operator delete[](void *o)&#123; //打印析构的开端地址 cout&lt;&lt;\"Destruct from: \"&lt;&lt;o&lt;&lt;endl; //完成内存释放 free(o); &#125;&#125;;int main()&#123; // 打印long long的大小 int len_ll = sizeof(long long); cout&lt;&lt;\"Size of long long: \"&lt;&lt;len_ll&lt;&lt;endl; //生成一个长度为len(20194134)的Yu类型的数组 Yu* testArr = new Yu[len]; //获取该数组开头的地址并打印 char* p1 = (char*) testArr; cout &lt;&lt; \"Address for the Array: \"&lt;&lt; testArr &lt;&lt;endl; //获取该数组前的8字节，识别为long long 并打印 cout&lt;&lt; \"The long long before the Array: \" &lt;&lt; *(long long*)(p1-len_ll)&lt;&lt;endl; //释放数组空间 delete[] testArr; return 0;&#125; 完整输出： 12345678Size of long long: 8|Length: 20194134|Real Size: 80776544|Raw Size(int(4)*length): 80776536|Gap: 8Address for the Array: 0x2670048The long long before the Array: 20194134Destuct from: 0x2670040","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://codelearn.club/categories/C-C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://codelearn.club/tags/C/"}]},{"title":"C/C++程序的断点调试","slug":"qtdebug","date":"2020-02-20T07:16:04.000Z","updated":"2020-03-03T04:54:12.766Z","comments":true,"path":"2020/02/qtdebug/","link":"","permalink":"http://codelearn.club/2020/02/qtdebug/","excerpt":"本文以Qt Creator为例，简述C/C++程序断点调试的基本方法和过程。其它的IDE环境，大同小异。","text":"本文以Qt Creator为例，简述C/C++程序断点调试的基本方法和过程。其它的IDE环境，大同小异。 1. 简介在程序有BUG/缺陷，需要修复时，断点调试是发现缺陷的重要方法。对于初学者而言，断点调试还有另外一个用途：帮助理解程序背后的逻辑。 本文以Qt Creator为例，简述C/C++程序断点调试的基本方法和过程。其它的IDE环境，大同小异。 版权声明 本文可以在互联网上自由转载，但必须：注明出处(作者：海洋饼干叔叔)并包含指向本页面的链接。 本文不可以以纸质出版为目的进行改编、摘抄。 2. 程序代码在Qt Creator中创建一个Non Qt - Plain C Application （纯C控制台应用程序），然后录入如下代码： 12345678910111213141516171819202122232425262728293031//Project - DebugExample#include &lt;stdio.h&gt;#include &lt;stdbool.h&gt;bool isPrime(int n) &#123; //函数的定义 if (n&lt;=1) return false; for (int i=2;i&lt;n;i++) if (n % i == 0) return false; return true;&#125;int main()&#123; printf(\"Try to find all prime number(&lt;=10):\\n\"); int iFound = 0; //发现的质数个数 for (int i=2; i&lt;=10; i++) &#123; if (!isPrime(i)) continue; iFound++; printf(\"%d, \",i); &#125; printf(\"\\n%d prime numbers been found.\",iFound); return 0;&#125; 上述程序的用途在于找出2 ~ 10之间的全部质数并打印出来。请读者注意第19 ~ 21行，for循环的初始化语句，测试表达式，更新表达式故意分作了三行，以便于观察。 3. 断点 在第18行代码的行号左边（图中红框A处）单击鼠标，便会出现如图所示的断点（break point），在相同位置再次单击，断点便会消失。可以给同一段程序添加多个断点。 单击图中红框B内的按钮，断点调试开始。 4. 调试 与正常的程序运行不同，黑色的控制台界面一闪而过，程序将暂停在第18行的断点处。读者仔细观察，应可见第18行行左会出现一个黄色的箭头（图中标A处），该黄色箭头表明当前程序执行点，准确地说，箭头所指向的行是接下来准备执行的代码行。 在界面标B处，有一个列表，这个列表列出了程序当前执行阶段的局部变量的名称及当前值。可以看到，此时，有iFound变量存在，其值为0，类型为int。 展开调试菜单，可以看到很多与调试相关的菜单项。本文主要使用到两个，分别是单步跳过（F10）以及单步进入（F11)。在调试过程中，使用该菜单与直接按下F10、F11作用相同。本文主要使用快捷键来完成。读者需要注意，如果你使用的是笔记本电脑，笔记本电脑的F10、F11等键通常是复用的，你可能需要结合其它按键来触发F10、F11按键。如果实在弄不明白，也可以使用调试菜单。 按一下F10(单步跳过)，可以看到第18行被执行，黄色箭头指向第19行。此时，for循环内的局部变量i出现在右方的列表中，其值为16，这说明for循环局部变量i的空间已被分配，但for循环的初始化语句尚未执行，i还没有获得初始值0。 注意：在变量没有被初始化前，其值是不确定的，所以读者真实调试时，得到的值很可能不是16。 再次按下F10(单步跳过)，可以看到黄色箭头指向第23行。因为for循环初始化语句的执行，右方列表中i的当前值变成了2。 第23行涉及一次函数调用，如果操作者希望观察isPrime( )函数内部的执行过程，应按F11(单步进入)。如果操作者不关心isPrime( )内部的执行过程，只关心23行的总体执行结果，则按F10(单步跳过)。本次，我们按F11。 按下F11后，我们进入到了isPrime( )函数内部，黄色箭头指向第6行。对于isPrime( )函数而言，当前其局部变量仅有1个，即函数的形式参数n。该参数的值应由调用者传递进来。在右方的列表中，我们看到该值为2。 一直按F10，直到isPrime( )函数返回，由于2是质数，所以第23行的不是质数的条件不成立，第24行不会被执行，黄色箭头略过了第24行，指向了第25行。 按F10执行第25行后，黄色箭头指向第26行，iFound值由0变为1。 一直按F10进行循环，直到i = 4且黄色箭头指向第23行。 本次我们选择不进入isPrime( )函数，再次按下F10（单步跳过）。 由于i = 4不是质数，因此第23行的条件成立，黄色箭头跳转到第24行的continue语句。 根据continue的语义，其将略过本轮循环的剩余语句（第25 ~ 26行），直接尝试下一轮循环。 再次按下F10，可以看到，continue直接略过了第25 ~ 26行的剩余循环代码，直接跳到了for循环的更新表达式，如图中红色箭头所示。 再次按下F10, 可以看到更新表达式被执行，i值由4变成了5，黄色箭头指向了第19行，该行将进行循环测试(i &lt;= 10)，如果测试通过，则将执行循环体，否则循环结束。 说明：读者可能会疑惑，测试表达式在第20行，为何跳转到第19行？ 作者的回答：此处确实是在执行第20行的循环测试，调试器标指向第19行并不十分恰当。 5. 观察输出在Windows环境下，读者此时可以按Alt + Tab组合键切换到控制台窗口去观察到当前执行阶段为止的输出情况。 可以看到，2,3两个质数已被找出，4是合数被略过，正准备考察整数5。 说明：也可以在Windows任务栏中点击对应按钮切换到控制台输出窗口，见下图中红色方框所示。 6. 去除断点如果调试的目的已达成，准备放弃调试，可以再次单击红色断点将其取消，如下图： 此时，可以选择Continue （继续执行，F5），在没有断点的情况下将程序执行完；也可以选停止调试，强行中止程序的执行。 7. 继续执行取消断点后，我们选择了继续执行。程序执行完成后，Qt Creator与调试相关的箭头，右方的局部变量列表等均消失不见，恢复至常规编辑界面。 在控制台输出窗口中，可以看到程序执行的全部结果。","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://codelearn.club/categories/C-C/"}],"tags":[{"name":"Qt Creator","slug":"Qt-Creator","permalink":"http://codelearn.club/tags/Qt-Creator/"}]},{"title":"Visual Studio Code无法启动Jupyter的解决办法","slug":"vscjupyter","date":"2020-02-17T11:36:04.000Z","updated":"2020-09-20T10:16:03.970Z","comments":true,"path":"2020/02/vscjupyter/","link":"","permalink":"http://codelearn.club/2020/02/vscjupyter/","excerpt":"在Visual Studio Code中，依视频首次编辑运行Jupyter Notebook时( .ipynb )时，系统会主动安装Jupyter相关组件。默认情况下，系统从位于国外的服务器下载组件，受限于防火墙及网速，经常会出现安装失败的情况，通常表现为安装的中断及红字错误信息。如下图： [图1]","text":"在Visual Studio Code中，依视频首次编辑运行Jupyter Notebook时( .ipynb )时，系统会主动安装Jupyter相关组件。默认情况下，系统从位于国外的服务器下载组件，受限于防火墙及网速，经常会出现安装失败的情况，通常表现为安装的中断及红字错误信息。如下图： [图1] 解决方法在Visual Studio Code中的Terminal页中，手动执行安装命令安装组件，并通过-i 参数指定从国内清华大学的源进行下载。 12pip install jupyter -i https://pypi.tuna.tsinghua.edu.cn/simplepip install ipykernel -i https://pypi.tuna.tsinghua.edu.cn/simple 如下图所示： [图2] 安装完成后，重新启动Visual Studio Code, 再次尝试运行Jupyter Notebook. 说明具体的组件名称时有变化，读者可以从图1的红框位置找到安装失败的组件，哪个组件安装失败，就尝试从Terminal中手动安装哪个组件。","categories":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/tags/Python/"}]},{"title":"Windows环境下Qt Creator控制台输出中文乱码解决方法","slug":"qtconsolechinese","date":"2020-02-16T08:37:04.000Z","updated":"2020-09-11T06:28:08.207Z","comments":true,"path":"2020/02/qtconsolechinese/","link":"","permalink":"http://codelearn.club/2020/02/qtconsolechinese/","excerpt":"中文讨论Windows环境下Qt Creator控制台输出中文乱码的解决办法。","text":"中文讨论Windows环境下Qt Creator控制台输出中文乱码的解决办法。 1. 开发环境中文Windows 10 64bit, Qt Creator 4.11.0, mingw 7.3.0 64 bit 版权声明 本文可以在互联网上自由转载，但必须：注明出处(作者：海洋饼干叔叔)并包含指向本页面的链接。 本文不可以以纸质出版为目的进行改编、摘抄。 2. 故障现象​ Plain C/C++ Application在控制台输出中文时出现乱码。 程序如下： 12345678910111213141516171819202122232425//Project - EarthTime#include &lt;stdio.h&gt;#include &lt;time.h&gt;int main() &#123; time_t t; time(&amp;t); //获取当前时间,从1970年1月1日零时起经过的秒数 long long totalSeconds = (long long)t; //总秒数转换为long long类型 long long curSecond = totalSeconds % 60; //当前秒数 = 总秒数对60取余 long long totalMinutes = totalSeconds / 60; //总分钟 = 总秒数除60 long long curMinute = totalMinutes % 60; //当前分钟 = 总分钟对60取余 long long totalHours = totalMinutes / 60; //总小时 = 总分钟除60 long long curHour = totalHours % 24; //当前小时 = 总小时对24取余 printf(\"格林尼治时间 %lld 时 %lld 分 %lld 秒,1970年1月1日零时到现在经过了 %lld 秒.\", curHour,curMinute,curSecond,totalSeconds); /* printf的英文版本 printf(\"%lld:%lld:%lld, %lld seconds after 1970/1/1 00:00::00\", curHour,curMinute,curSecond,totalSeconds); */ return 0;&#125; 其执行结果包含乱码： 3. 解决方案images选择工具-&gt;选项菜单 在文本编辑器-显示中勾选 Display file encoding 右上角填UTF-8，弹出的对话框中选择System，选“按编码保存”。 保存之后，右上角显示的当前编码变为System. 再次编译执行，问题解决。 4. 后记问题事实上没有完全解决，下次再打开项目时，Qt Creator会以UTF-8读入事实上由System编码的文件，连源代码都会出现乱码。此时，可以通过按System编码读入来解决。 请读者不必纠正，大多数的应用开发，都是图形界面，控制台应用极少，控制台里还要使用中文的应用就更少了。 通过当整体开发环境的文件编码设置为System，或可解决问题。但作者不推荐这么做， 因为事实上，UTF-8是更通用的编码，它允许在同一个应用程序里同时显示多国文字。 本文内容节选自作者编著的《Python编程基础及应用》（高等教育出版社）一书。 免费随书B站MOOC:","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://codelearn.club/categories/C-C/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://codelearn.club/tags/C-C/"},{"name":"Qt","slug":"Qt","permalink":"http://codelearn.club/tags/Qt/"}]},{"title":"Qt Creator的简单使用方法","slug":"simpleqtuse","date":"2020-02-01T09:11:04.000Z","updated":"2020-09-11T06:29:20.403Z","comments":true,"path":"2020/02/simpleqtuse/","link":"","permalink":"http://codelearn.club/2020/02/simpleqtuse/","excerpt":"本文介绍使用Qt Creator进行C/C++编程的基本方法。","text":"本文介绍使用Qt Creator进行C/C++编程的基本方法。 版权声明 本文可以在互联网上自由转载，但必须：注明出处(作者：海洋饼干叔叔)并包含指向本页面的链接。 本文不可以以纸质出版为目的进行改编、摘抄。 1. Qt Creator启动安装完Qt后，在Windows开始菜单中可以找到Qt 5.14.1子目录（版本号不同，子目录名不同）。 单击Qt Creator 4.11.0(Community)即可启动Qt Creator。 考虑到后续使用方便，可以在桌面上创建一个快捷方式：用鼠标左键单击Qt Creator 4.11.0(Community)并按住不放，然后拖至桌面并释放鼠标左键。 点击右上角的最大化按钮将窗口最大化， Qt Creator启动完成，可以使用了。 2. 创建Non-Qt Project / Plain C Application选择菜单文件(File)-&gt;新建文件或项目（New File or Project ): 点选Non-Qt Project下的Plain C Application, 然后单击”Choose”, 将项目名称设为demo1; 可以看到，默认的项目路径是Windows当前登录用户的文档路径，对部分读者而言，该路径可能包括中文（目录和文件名最好不要包含非英文字符！，解释见后），稳妥起见，点”浏览”按钮， 在弹出的对话框里选择C盘，在对话框的空白处，右键单击鼠标，选择弹出菜单中的新建-&gt;文件夹， 新建一个名为C2Cpp的目录。 创建C:\\C2Cpp目录并“选择文件夹”后，勾选“设为默认项目路径”， 然后单击“下一步”， 直接点“下一步”， 直接点”下一步“， 如果读者计算机上出现了其它选项，说明读者可能安装了Qt的其它版本（比如MSVC 2017）， 建议完全卸载QT后严格按照作者的操作文档重新安装。 单击”完成“， 可以看到，demo1项目已经成功创建并打开，其项目文件为demo1.pro, 主程序为main.c。 在窗口的左下角，有一个绿色的三角形按钮（运行），点击此按钮将构建并运行当前项目。 点击运行按钮后，系统会进行构建/编译，然后一个黑色底的对话框内显示了执行结果: Hello World! 黑色对话框（Windows命令行）右上角的X按钮表示关闭窗口，点击此按钮，将关闭黑色对话框。 如果上述过程正确无误，恭喜你，你的Qt开发环境的安装和配置多半是成功的。 3. Qt Creator的基本操作3.1 关闭项目Qt Creator允许同时打开多个项目。为避免不必要的麻烦，我们建议初学者最好只同时打开一个项目。 当需要关闭某个项目时，选单击选中项目（如下图中的demo1), 然后选择文件菜单 –&gt; Close Project “demo1”, 该项目关闭后，可以看到项目列表为空。 3.2 打开已有的项目 方法1： 选择文件菜单-&gt; 打开文件或者项目， 定位到C:\\C2Cpp\\demo1目录，选中demo1.pro, 然后单击”打开“， 可见，demo1项目被成功打开： 方法2 在Windows的资源管理中，直接定位到项目文件demo1.pro, 然后双击，也可以打开该项目（Qt的安装程序将.pro文件与Qt Creator作了关联）。 3.3 项目栏的收起与展开在Qt Creator的左下角，有一个按钮（如下图），单击这个按钮可以帮助收起/展开项目栏。 当你书写代码时，可能希望整个屏幕都用于显示代码，此时，收取项目栏可以更好地利用屏幕空间。 3.4 文件的打开和关闭展开项目文件树后，双击main.c, 可见该文件被打开。 如果需要关闭该文件，请点击main.c后方的x按钮， 如下图所示。 3.5 代码字号调整在代码文件打开的情况下，先在代码编辑框中单击一下，确保当前编辑焦点在代码编辑框中。然后，按住Ctrl键不放，并滚动鼠标的滚轮（建议读者外接一个鼠标以便操作），可以看到代码的字号变化。 4. 创建Non-Qt Project / Plain C++ ApplicationC语言大约是C++语言的子集，当需要练习C++编程时，需要创建一个C++应用程序。 创建过程与创建C应用程序类似，唯一区别是新建项目时，应选择Non-Qt Project / Plain C++ Application，如下图所示： 在这里，我们创建一个名为demo2的C++应用程序。 请读者注意，为了避免初学者可能遇到的困难，本书中我们总是使用C:\\C2Cpp目录作为项目存储路径。 下图中，Qt Creator同时打开了两个项目：demo1和demo2， 其中, demo2为当前项目（字体更粗）。 main.cpp是demo2的主程序文件。此时，如果点击运行按钮，被编译和运行的将会是demo2项目。 在本书的前半部分，我们只需要创建和使用这种”原始“的C和C++项目。在本书的后半部分，我们还需要创建图形应用程序，具体方法到时再介绍。 5. 对初学者的忠告 对于键盘不熟悉的初学者，建议暂时关闭掉笔记本上的触摸板，仅使用外置鼠标（避免敲键盘时意外碰到触摸板误操作）。 仅使用英文字符来命名文件夹及程序文件。现代的编程语言，计算机，操作系统都起源于国外，对中文的支持不太好。记住：避免掉下悬崖摔死的最好办法不是练习高超的平衡术，而是远离悬崖！ 编程需要做大量的输入，输入的速度至关重要。没有掌握标准指法的初学者请逐步练习和使用标准指法，初期可能会浪费一点时间，后期会赚回来。一指禅威力过大，不宜日常使用。 本文内容节选自作者编著的《Python编程基础及应用》（高等教育出版社）一书。 免费随书B站MOOC:","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://codelearn.club/categories/C-C/"}],"tags":[{"name":"IDE","slug":"IDE","permalink":"http://codelearn.club/tags/IDE/"}]},{"title":"Windows环境下Qt C++开发环境的下载与安装","slug":"qt-install-win","date":"2020-01-31T09:33:04.000Z","updated":"2020-09-11T06:28:33.818Z","comments":true,"path":"2020/01/qt-install-win/","link":"","permalink":"http://codelearn.club/2020/01/qt-install-win/","excerpt":"Windows环境下Qt C++开发环境的下载与安装","text":"Windows环境下Qt C++开发环境的下载与安装 版权声明 本文可以在互联网上自由转载，但必须：注明出处(作者：海洋饼干叔叔)并包含指向本页面的链接。 本文不可以以纸质出版为目的进行改编、摘抄。 1. Qt的下载Qt有在线安装和离线安装两种模式，受限于国内有限的出口带宽，在线安装很困难，所以我们选择离线安装。 在浏览器中访问下述地址（直接单击下述链接也可以）： http://download.qt.io/official_releases/qt/ 页面装载后如下图： 可以看到该目录下有不同的Qt版本，一般选择最新的一个，此处，单击5.14，打开后可见下述两个子目录： 单击5.14.1子目录，打开后如下图： 如果准备在Windows系统下使用，单击qt-opensource-windows-x86-5.14.1.exe下载该离线安装包。如果你的网速不太好，也可以考虑右键单击qt-opensource-windows-x86-5.14.1.exe，然后在弹出菜单中选择复制链接地址，然后在诸如“迅雷”之类的下载工具中进行下载，如下图： 说明：Qt不断有新版本发布，读者看到的目录及文件名称可能与上述图片有差异。 2. Qt的安装找到之前下载的Qt离线安装包，大约2.4G, 在作者的电脑上，该文件如下图： 双击运行该文件，可见安装程序开始执行： 单击“Next”进入下一步，此页中要求使用Qt账号登录，如果没有，则注册(Sign-up)一个。输入正确的账号密码后，单击”Next”进行下一步。 勾选”I have read ….”, 然后单击下一步， 再次点击下一步， 一般使用默认安装路径，勾选下方的”Associate common file …”，然后单击”下一步”， 接下来选择准备安装的组件，千万不要选择”全选“， 这样安装的软件过于宠大，费时也太长。建议严格按照下图进行选择。然后选”下一步“。 下表对主要的组件进行了说明： 组件名称 说明（英文） 说明（中文） Qt 5.14.1 / MinGW 7.3.0 64-bit Qt 5.14.1 Prebuild Components for MinGW 7.3.0 64-bit 适用于MinGW 7.3.0 64-bit编译器的Qt 5.14.1预编译组件 Developer and Designer Tools / Qt Creator 4.11.0 IDE for Qt application development Qt应用程序的集成开发环境 Developer and Designer Tools / MinGW 7.3.0 64-bit MinGW-builds 7.3.0 64-bit toolchain MinGW 7.3.0 64-bit C/C++编译器(MinGW是Linux下gcc编译器的Windows版本) 说明：作为选项，在Windows环境下，用户也可以选择使用MSVC 2017 64-bit的编译器，但需要额外安装Visual Studio 2017中的C++编译器。对于初学者而言，过于麻烦，建议简单使用MinGW 7.3.0 64-bit编译器。 在下述对话框中勾选”I have read and agree to…”, 然后单击”下一步“， 这个对话框用于设置开始菜单中的目录名称，直接选”下一步“， 选择”安装“， 安装过程将持续很大一会儿， 勾选Launch Qt Creator后，单击完成将直接打开Qt Creator集成开发环境，这里，我们先把勾去掉，再单击”完成“。 至此，Windows环境下的Qt C++开发环境下载安装完成。 本文内容节选自作者编著的《Python编程基础及应用》（高等教育出版社）一书。 免费随书B站MOOC:","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://codelearn.club/categories/C-C/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://codelearn.club/tags/C-C/"},{"name":"Qt","slug":"Qt","permalink":"http://codelearn.club/tags/Qt/"}]},{"title":"Cython编译环境准备","slug":"cythonenv","date":"2020-01-19T12:50:04.000Z","updated":"2020-09-11T06:18:55.152Z","comments":true,"path":"2020/01/cythonenv/","link":"","permalink":"http://codelearn.club/2020/01/cythonenv/","excerpt":"本文讨论Windows环境下Cython编译环境的准备。","text":"本文讨论Windows环境下Cython编译环境的准备。 版权声明 本文可以在互联网上自由转载，但必须：注明出处(作者：海洋饼干叔叔)并包含指向本页面的链接。 本文不可以以纸质出版为目的进行改编、摘抄。 世界发展得太快，当读者阅读本书时，下述信息或许已经过时。 作者使用的是Windows 10环境下的64位的Python3.7解释器，所以作者安装了微软的Visual Studio社区版的”使用C++的桌面开发”部分，其中包括了VC 2017 version 15.9 v14.16以及相关的Windows SDK。该软件可以从 https://visualstudio.microsoft.com 获得。请注意，Visual Studio是一个非常宠大的IDE软件，除上述必要部分之外的请不要选择，否则非常耗时而且占据硬盘空间。 如果读者使用的是Linux, 则系统自带的gcc编译器通常足够使用。Linux下Cython代码的编译过程与下述过程相当，但细节或有区别。 读者还需要安装Cython模块，在Windows命令行或者Linux终端中运行pip install cython即可。 本文内容节选自作者编著的《Python编程基础及应用》（高等教育出版社）一书。 免费随书B站MOOC:","categories":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/tags/Python/"}]},{"title":"“实践 - 搬金盘的婆罗门”项目中的图片及音乐资源","slug":"hanoirsc","date":"2020-01-10T13:25:04.000Z","updated":"2020-09-11T06:20:34.178Z","comments":true,"path":"2020/01/hanoirsc/","link":"","permalink":"http://codelearn.club/2020/01/hanoirsc/","excerpt":"本书配套代码中HanoiTower项目目录下有resource子目录，其中存放了本游戏中使用的全部图片及音乐资源。","text":"本书配套代码中HanoiTower项目目录下有resource子目录，其中存放了本游戏中使用的全部图片及音乐资源。 版权声明 本文可以在互联网上自由转载，但必须：注明出处(作者：海洋饼干叔叔)并包含指向本页面的链接。 本文不可以以纸质出版为目的进行改编、摘抄。 资源名称 用途 background.png 游戏的背景图片 Serenity.mp3 游戏的背景音乐 blue … gray.png 盘图片，游戏中用于模拟柱上的金盘 runNormal, runFocused, runPushed, runDisabled.png… 按钮图标文件，每个按钮4个，依次为按钮“正常”，“高亮”，“按下”，“禁用”时的对应图片 读者如果希望设计一些游戏，可以试着从www.pixabay.com或者www.audionautix.com下载图片或音乐资源。这些网站提供的部分资源允许不经授权而免费使用，即便是出于商业目的。 本文内容节选自作者编著的《Python编程基础及应用》（高等教育出版社）一书。 免费随书B站MOOC:","categories":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/tags/Python/"}]},{"title":"人工智能的味道 - 使用Python进行图像风格迁移","slug":"imgstyle","date":"2019-11-07T14:36:04.000Z","updated":"2020-09-11T06:22:14.112Z","comments":true,"path":"2019/11/imgstyle/","link":"","permalink":"http://codelearn.club/2019/11/imgstyle/","excerpt":"Python是人工智能编程的首选语言，至少当作者在键盘上敲下这行话时，这是事实。作为一本Python基础入门性质的教科书，本书无法就Python在人工智能与深度学习中的应用展开深入讨论。要理解深度学习的内部细节，需要复杂的数学知识。不过作为应用层面的开发者，读者或者不需要理解深度学习复杂的数学细节，简单借助于开源的工具包和模型，也可以享受到人工智能的益处。本章通过图像风格迁移这个示例，让读者尝尝人工智能的味道。","text":"Python是人工智能编程的首选语言，至少当作者在键盘上敲下这行话时，这是事实。作为一本Python基础入门性质的教科书，本书无法就Python在人工智能与深度学习中的应用展开深入讨论。要理解深度学习的内部细节，需要复杂的数学知识。不过作为应用层面的开发者，读者或者不需要理解深度学习复杂的数学细节，简单借助于开源的工具包和模型，也可以享受到人工智能的益处。本章通过图像风格迁移这个示例，让读者尝尝人工智能的味道。 版权声明 本文可以在互联网上自由转载，但必须：注明出处(作者：海洋饼干叔叔)并包含指向本页面的链接。 本文不可以以纸质出版为目的进行改编、摘抄。 22. 人工智能的味道 - 图像风格迁移22.1 图像风格迁移 将上图中左上角图像的“风格”提取出来，应用到左下角的“原图”上，生成右方的图像，就是图像风格迁移的研究内容。 艺术风格是什么，即便在艺术家的视角看，也是见人见智的。显然不太可能从数学上准确地定义并求出图像的风格。到底怎么把一个缺乏明确数学定义的概念变成可以执行的程序，是困扰图像风格迁移的研究者的主要问题。 在将人工神经网络和深度学习应用于图像风格迁移之前，人们的主要思路就是分析某一种风格的图像，比如把毕加索画的全部画作进行统计分析，如小波分析，通过建立统计模型，然后迭代改变要做迁移的图像，让它更好地符合统计模型。这种方法有一个很大的缺点：一个程序只能做某一种风格或场景的图像风格迁移。 2015年，Gatsys等人在论文A Neural Algorithm for Artistic Style中首次将人工神经网络用于图像风格迁移，斯坦福大学的李飞飞和她的学生Justin Johnson等人于2016年进一步改进了算法，提高了图像风格迁移的速度。本章示例程序中图像风格迁移就是以Justin Johnson等人训练的深度神经网络模型为基础的。 22.2 深度神经网络人工智能是一个研究了很多年的课题。它有众多的学派，其中符号学派将机器学习看作逆向演绎，联结学派对大脑进行逆向分析和模拟，进化学派在计算机上模拟生物进化，贝叶斯学派认为学习是一种概率推理形式，理论根基在于统计学。其中，联结学派的主要工具就是人工神经网络，人工神经网络模拟了大脑神经元和神经元间突触连接的结构和工作方式。而深度神经网络又是人工神经网络的一种。 上图展示了一个深度神经网络(Deep Neural Network) - DNN的示意图。图中的节点称之为神经元，神经元之间的连线模拟了人类大脑中脑细胞之间的突触连接。可以简单地认为，每个神经元具备计算或者是信号处理的功能，它通过突触从别的神经元获取输入，经过计算/处理后再通过突触向其它神经元输出信号。我们已知，大脑细胞之间的每个突触连接，其离子通道的导电能力是有差异的。与之对应，神经网络神经元之间的连接权重参数用来表征该连接的重要程度。 神经元的层次，数量，神经元之间的连接关系可以称为神经网络的结构。突触连接的权重、偏倚等信息则称为神经网络的参数。为满足特定任务的需要，比如在各种图片或者视频中识别出猫，工程师会设计特定的神经网络结构，并将大量经过标注的资料图片（图片中有猫的位置被人工标记）输入神经网络的输入层，通过神经网络的计算，从输出层获得识别结果，然后根据识别错误反向修改神经网络内部的参数，经过多次迭代后，神经网络的内部参数被修正到即便对于标注资料外的图片，神经网络也能识别出猫的程度。这一过程称为神经网络的训练。训练的结果称为模型，它包括了神经网络的结构以及内部参数。 猫长什么模样，在数学上很难精确定义。我们可以认为，上述神经网络的训练过程有点类似于人类学习的过程，经过训练的神经网络模型包括了“何种模式的图像是猫”的知识。这种知识虽然说不清道不明，但在实践中却非常有效。 同理，将梵高的星空等相似风格的画作作为数据集，也可以对深度神经网络进行训练，训练所得的模型包含了这类画作的”风格是什么“以及”如何把另一幅图片变成这种风格”的知识。本章的示例程序就是借助于Justin Johnson等人训练好的图像风格迁移网络模型，对图片进行风格应用的。在调入模型，创建好深度神经网络后，将图片”输入“给图像风格迁移网络，该网络会进行一系列的迭代计算，其输出就是应用了对应风格的被修改过的图片。 22.3 程序解读本章的示例程序包含在目录C22_StyleTransfer当中，主程序为StyleTransfer.py。子目录images用于存储风格迁移的输入图片，models子目录用于存储风格图片及对应的图像风格迁移网络模型文件。其中，模型文件需要读者自行下载，详情请见Readme.txt。 该程序需要用到opencv-python以及matplotlib库。opencv是著名的C++语言编写的计算机视觉及图像处理工具包，本程序中，主要用它来读取、转换图片以及进行图像风格迁移网络的计算。matplotlib在本程序中用于交互和图片显示。 22.3.1 程序的使用先下载并将模型文件(扩展名为.t7)存入models子目录。在Visual Source Code中打开StyleTransfer目录，打开StyleTransfer.py并运行即可。按上下方向键可以切换图片，按左右方向键则可以切换风格模型。如本章开始的样图所示，左上角是风格图片，左下角是原图，右边则是风格迁移的结果图片。由于风格迁移网络的计算量很大，所以切换图片或者风格时反应较慢。 22.3.2 数据结构123456789101112class App: def __init__(self): self.idxImage = 0 #当前被风格迁移的图片在images列表中的下标 self.idxModel = 0 #当前使用的模型文件在models列表中的下标 self.images = glob.glob(\"images/*.jpg\") self.paintings,self.models = [],[] t = glob.glob(\"models/*.jpg\") for x in t: m = x[:-3] + \"t7\" #模型文件的扩展名为.t7, 基本名与对应的风格图片相同 if os.path.exists(m): #仅在风格图片及模型文件同时存在时，将二者加入列表 self.paintings.append(x) self.models.append(m) 为了避免过多的全部变量污染名字空间，作者把相关信息组织在App类型中。 数据成员 - images: 包含images子目录内全部jpg图片文件路径的列表，形如[‘images\\1.jpg’, ‘images\\2.jpg’, ‘images\\3.jpg’]。- paintings: 包含models子目录风格图片路径的列表，形如[‘models\\candy.jpg’, ‘models\\composition_vii.jpg’,…]。- models: 包含models子目录内模型文件路径的列表，形如[‘models\\candy.t7’, ‘models\\composition_vii.t7’,…]。 paintings与models列表内的风格图片与模型是一一对应的，且文件基本名相同，仅扩展名不同。- idxImage: 当前被风络迁移的内容图片在images列表中的下标。- idxModel: 当前使用的模型文件在models列表中的下标。 glob.glob(“images/*.jpg”) 遍历images子目录，找出其中的全部jpg文件，生成一个包含全部jpg文件路径字符串的列表。上述图像风格迁移网络的模型文件的扩展名为.t7，这是PyTorch的数据保存格式。而PyTorch是Facebook的深度学习开源工具包，具体一点可以把PyTorch看做加入了GPU 支持的numpy，同时也可以看成一个拥有自动求导功能的强大的深度神经网络。 22.3.3 风格迁移123456789101112131415161718import cv2 as cv #导入opencv库class App: ... def styleTransfer(self): net = cv.dnn.readNetFromTorch(self.models[self.idxModel]) #cv2.dnn_Net net.setPreferableBackend(cv.dnn.DNN_BACKEND_OPENCV) #设置计算后台类型 inImg = cv.imread(self.images[self.idxImage]) #读取输入的内容图片 inp = cv.dnn.blobFromImage(inImg, 1.0, (inImg.shape[1],inImg.shape[0]), (103.939, 116.779, 123.68), swapRB=False, crop=False) net.setInput(inp) outImg = net.forward() outImg = outImg.reshape(3, outImg.shape[2], outImg.shape[3]) outImg[0] += 103.939 outImg[1] += 116.779 outImg[2] += 123.68 outImg /= 255 outImg = outImg.transpose(1, 2, 0) return inImg, outImg 类App的styleTransfer()函数应用当前的图像风格迁移网络模型将当前内容图片风格迁移成输出图片。函数返回的inImg即为输入的内容图片，outImg则为输出图片，两者都是numpy三维数组。 读者可能会感到诧异，如此复杂的功能居然只有这么少的代码。是的，当你站在前人的肩膀上，只是调库（调用别人开发好的库）时，就是这么简单。 代码说明 - net = cv.dnn.readNetFromTorch() - 加载Torch格式的配置网络及其参数。执行后，net的类型为cv2.dnn_net，是一个深度神经网络。- cv.imread()函数用于读取图像文件，其返回一个numpy的三维数组，其维度依次为图像的像素高，图像的像素宽，像素颜色通道数（通常为3）。 - 接下来，blobFromImage将inImg进行转换，变成深度神经网络所接受的数据格式；net.setupInput(inp)则把转换后的数据设定为神经网络的输入; net.forward()则应用神经网络进行计算，并在其输出层得到输出图像outImg；outImg也是一个numpy多维数组，其维度与数据格式与常规的图像有所不同；所以后续代码对其进行了一些格式变换。- 最后，函数返回inImg-输入图像, outImg-输出图像两个用于表示图像的多维数组。 22.3.4 图像显示与刷新12345678910111213class App: ... def refresh(self,fig,axStyle,axIn,axOut): print(\"Style tranfering...\") self.idxImage = self.idxImage % len(self.images) self.idxModel = self.idxModel % len(self.models) inImg, outImg = self.styleTransfer() print(\"Rendering...\") styleImg = cv.imread(self.paintings[self.idxModel]) axStyle.imshow(cv.cvtColor(styleImg,cv.COLOR_BGR2RGB)) axIn.imshow(cv.cvtColor(inImg, cv.COLOR_BGR2RGB)) axOut.imshow(cv.cvtColor(outImg, cv.COLOR_BGR2RGB)) fig.canvas.draw() 函数refresh()负责对当前内容图像进行风格迁移运算，并将风格风像，内容图像，迁移后的输出图像显示在对应的子图(Axes)中。其中，axStyle用于显示风格图像，axIn显示内容图像，axOut用于显示输出图像。 self.idxImage和self.idxModel分别对len(self.images)和len(self.models)进行求模，目的是防止列表的越界访问（后续代码中，切换图片和风格时没有进行越界限制）。 axStyle/axIn/axOut.imshow()负责将图像显示在子图中。请注意，在显示之前，还应用cv.cvtColor()函数进行了一次图像格式转换，这是因为OpenCV中的图像其颜色通道顺序为BGR，即三维数组第三维中下标0对应蓝色，下标1对应绿色,下标2对应红色；而Matplotlib中，图像的颜色通道顺序为RGB，为了能正确显示，交换一下颜色通道顺序。 1234567891011...fig = plt.figure(figsize=(12,6))axStyle = plt.subplot(231) axIn = plt.subplot(234)axOut = plt.subplot2grid((2,3),(0,1),rowspan=2,colspan=2)plt.subplots_adjust(0,0,1,1,0,0) #设置子图间的间距为0for ax in (axStyle,axIn,axOut): ax.set_axis_off() #子图不显示坐标轴app.refresh(fig,axStyle,axIn,axOut) #刷新显示 fig.canvas.mpl_connect('key_release_event',on_key_release) #连接键盘事件响应函数plt.show() 我们在matplotlib中创建1个图和3个子图。plt.subplot(231)将图的可视区域等分成2行3列，然后在第1个区域创建一个子图。同理，plt.subplot(234)将图的可视区域等分成2行3列，然后在第4个区域（即第2行的第1个区域)创建子图。上述第1个区域，第4个区域是从1开始计数的。 plt.subplot2grid()也是将图的可视区域分成2行3列，然后在第0行的第1列开始创建子图，子图横向占2列，纵向占两行。这里的第0行，第1列从0开始计数，显然，这里的计数方式跟subplot()函数不同。读者不必为此感到困惑，这没有为什么。作者将此差异视作matplotlib设计者犯下的一个小错误，如果全部保持相同的计数规则，对于使用者而言，可能可容易理解一些。 fig.canvas.connect()函数连接键盘松开事件至on_key_release()函数， 当读者松开(release)键盘按键时，on_key_release()函数将被调用执行。 22.3.5 交互响应123456789101112def on_key_release(event): if event.key == 'up': app.idxImage-=1 elif event.key == 'down': app.idxImage+=1 elif event.key == 'left': app.idxModel-=1 elif event.key == 'right': app.idxModel+=1 else: return app.refresh(fig,axStyle,axIn,axOut) on_key_release()函数响应按键松开事件。如果是上-up, 下-down键，修改idxImage切换内容图片；如果是左(left)，右(right)键，修改idxModel切换图像风格迁移网络模型。最后，调用app.refresh()函数进行风格迁移和界面刷新。 22.4 小结下图是重庆大学虎溪校区图书馆及其在云湖上的倒影经过风格迁移后的效果。 现实中很多类似的计算问题，人类无法对相关概念进行准确的数学定义。比如：什么是图像的风格？ 何种形式的图像模式是一只猫？ 在乳腺X片里，什么样的图像可能是恶性的结节？ 在这种情况下，使用经过标注的数据集来训练神经网络，经过训练的神经网络从数据集中学习了相关的知识。这些知识包含在神经网络的内部参数中。即便这种知识的表达和真正的数学含义有些说不清，道不明，但我们仍然可以应用这些经过训练的神经网络来解决各种现实问题。 本文内容节选自作者编著的《Python编程基础及应用》（高等教育出版社）一书。 免费随书B站MOOC:","categories":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/categories/Python/"},{"name":"人工智能","slug":"Python/人工智能","permalink":"http://codelearn.club/categories/Python/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/tags/Python/"},{"name":"图像风格迁移","slug":"图像风格迁移","permalink":"http://codelearn.club/tags/%E5%9B%BE%E5%83%8F%E9%A3%8E%E6%A0%BC%E8%BF%81%E7%A7%BB/"},{"name":"深度学习","slug":"深度学习","permalink":"http://codelearn.club/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"DNN","slug":"DNN","permalink":"http://codelearn.club/tags/DNN/"}]},{"title":"浅尝则止 - SciPy科学计算","slug":"scipy","date":"2019-11-07T14:32:04.000Z","updated":"2020-09-11T06:29:06.240Z","comments":true,"path":"2019/11/scipy/","link":"","permalink":"http://codelearn.club/2019/11/scipy/","excerpt":"SciPy以NumPy为基础，提供了众多数学、科学、工程计算用的模块，包括但不限于：线性代数、常微分方程求解、信号处理、图像处理、稀疏矩阵处理。 本章适合那些有较好高等数学、线性代数、概率论基础的工科学生或从业者阅读。其他读者可以跳过，不影响后续章节。为减轻“数学恐惧症”患者的恐惧，作者尽量选择相对容易的“数学”案例来进行解读。","text":"SciPy以NumPy为基础，提供了众多数学、科学、工程计算用的模块，包括但不限于：线性代数、常微分方程求解、信号处理、图像处理、稀疏矩阵处理。 本章适合那些有较好高等数学、线性代数、概率论基础的工科学生或从业者阅读。其他读者可以跳过，不影响后续章节。为减轻“数学恐惧症”患者的恐惧，作者尽量选择相对容易的“数学”案例来进行解读。 版权声明 本文可以在互联网上自由转载，但必须：注明出处(作者：海洋饼干叔叔)并包含指向本页面的链接。 本文不可以以纸质出版为目的进行改编、摘抄。 21. 浅尝则止 - SciPy科学计算21.1 常数scipy.constants包含了众多的物理常数。 1234#Constants.pyfrom scipy import constants as Cprint(\"c =\",C.c) #光在真空中的传播速度print(\"g =\",C.g) #重力常数 执行结果 12c&#x3D; 299792458.0g&#x3D; 9.80665 其中，physical_constants是一个字典，它以物理常量名为键，对应值为一个三元素元组，分别是常数值、单位以及误差。下述程序可以打印其中的全部物理常数。下述程序执行结果中的electron volt常数表明了电子伏特与焦耳的换算关系。 1234#EnumConstants.pyfrom scipy import constants as Cfor k,v in C.physical_constants.items(): print(k,v) 执行结果 123...electron volt (1.6021766208e-19, &#39;J&#39;, 9.8e-28)... constants模块还可以帮助进行单位转换，其中的单位转换常量可将英制单位以及公制非标准单位全部转换成公制标准单位： 123456#Unit.pyfrom scipy import constants as Cprint(\"C.mile =\",C.mile) #一英里等于多少米print(\"C.gram =\",C.gram) #一克等于多少千克print(\"C.pound =\",C.pound) #一磅等于多少千克print(\"C.gallon =\",C.gallon) #一加仑等于多少立方米 执行结果 1234C.mile &#x3D; 1609.3439999999998C.gram &#x3D; 0.001C.pound &#x3D; 0.45359236999999997C.gallon &#x3D; 0.0037854117839999997 21.2 特殊函数special模块包括了数量众多的基本及特殊数学函数。下述程序可以打印这些函数的列表： 1234#Special.pyfrom scipy import special as Simport pprintpprint.pprint([x for x in dir(S) if not x.startswith(\"_\")]) 我们简要地介绍两个函数。Gamma函数Γ在统计学中有重要应用，其定义为：$$Γ(z)=\\int_0^{\\infty}{t^{z-1}e^{-t}dt}$$special模块的gamma()函数可计算上述函数的值。 1234#Gamma.pyimport scipy.special as Sprint(\"gamma(5)=\",S.gamma(5))print(\"gamma(1+1.2j)=\",S.gamma(1+2.1j)) #复数参数 执行结果 12gamma(5)&#x3D; 24.0gamma(1+1.2j)&#x3D; (0.13138722151786375+0.02710705024601709j) 受限于计算机内部浮点数的表达形式，计算机无法表达非常接近于1的实数，但可以表达非常接近于0的实数。比如，下述的v1的期望值是1.0 + 1e-25，但实际打印出来，其值为1.0。使用math.log(v1)求对数，就是对1.0求对数，结果为0.0。 123456789#Log1p.pyimport mathimport scipy.special as Sv1 = 1.0 + 1e-25print(\"v1=\",v1, \" #1.0 + 1e-25\")print(\"math.log(v1)=\",math.log(v1))v2 = 1e-25print(\"v2=\",v2)print(\"S.log1p(v2)=\",S.log1p(v2)) 执行结果 1234v1&#x3D; 1.0 #1.0 + 1e-25math.log(v1)&#x3D; 0.0v2&#x3D; 1e-25S.log1p(v2)&#x3D; 1e-25 special模块中的log1p()函数解决了这个问题，log1p(x)形式上等价于log(1+x)，但其内部小心地避免了用浮点数来表达1 + x。从上述程序的执行结果看，log1p(v2)非常好地计算了1+v2，也就是1+1e-25的对数值。 21.3 优化-optimizeoptimize模块提供了许多数值优化算法，提供非线性方程组求解、最小二乘法拟合、计算函数局域或者全域最小值等功能。在这里，我们介绍一下最小二乘拟合算法。 假设已知变量y和变量x之间存在函数关系y = f(x)。通过实验，我们观察到一些离散的实验数据(xi, yi)，然后，通过这些实验数据，来确定上述函数关系中的参数。比如，如果y与x之间满足形如y = kx+b的函数形式，那么，最小二乘法拟合就是要找到最佳的参数集p = {k,b}，使得下述函数S的值为最小：$$S(p)=\\sum_{i=1}^{m}[y_i-f(x_i,p)]^2$$粗浅地说，就是要找到最佳的k和b，使得通过函数关系计算出来的y值与实验数据尽可能一致。 微实践 - 最小二乘估计客观视力眼科医学实践中，有时会有患者出于特殊目的不愿意配合普通的视力表检查，试图假装“眼盲”来获取不恰当的经济利益，这在工作伤害和人身伤害纠纷中很常见。一种称为视觉诱发电位的检查技术可以鉴别受检者的诈盲。当向受检者呈现特定空间频率的刺激图形时，受检者的视觉皮层会因为分辨出刺激图形而产生脑电信号，这种脑电信号的产生不以受检者的主观意志为转移。通过安置于头部特殊位置的皮肤电极，可以采集受检者接受不同空间频率刺激时的脑电信号，用来以帮助评价受检者真实的客观视力。眼科学大夫们相信，受检者的视觉诱发电位信号的振幅与其可鉴别的刺激图形空间频率间存在着函数关系。本例中，我们假设该函数形为 y = kx + b。 现在有一位受检者，我们测得了下述实验数据，其中，cpd为空间频率，这个值越高，说明刺激图形越精细（对应标准对数视力表更下方的E形符号）。 空间频率/cpd 信号振幅/μV 空间频率/cpd 信号振幅/μV 4.02 8.11 6.04 10.43 8.05 6.72 10.06 6.09 12.07 4.3 13.48 5.04 15.09 3.23 17.3 1.66 20.12 1.03 24.14 1.58 接下来，我们应用这些数据来进行最小二乘拟合。 1234567891011121314151617181920#Leastsq.pyimport numpy as npfrom scipy import optimizefrom matplotlib import pyplot as pltx = np.array([4.02,6.04,8.05,10.06,12.07,13.48,15.09,17.3,20.12,24.14])y = np.array([8.11,10.43,6.72,6.09,4.3,5.04,3.23,1.66,1.03,1.58])def residuals(p): \"计算以p=(k,b)为参数的直线与实验数据之间的误差\" k,b = p print(\"try k=\",k,\"b=\",b) return y - (k*x+b)#leastsq()使得residuals()函数的输出数组的平方和为最小,[1,0]为初值r = optimize.leastsq(residuals,[1,0])k,b = r[0]print(\"k=\",k,\"b=\",b)#计算y=0时的x值print(\"x value when y=0:\",-b/k) 执行结果 1234567891011try k&#x3D; 1 b&#x3D; 0try k&#x3D; 1.0 b&#x3D; 0.0try k&#x3D; 1.0 b&#x3D; 0.0try k&#x3D; 1.0000000149011612 b&#x3D; 0.0try k&#x3D; 1.0 b&#x3D; 1.4901161193880158e-08try k&#x3D; -0.44638664967780084 b&#x3D; 10.63854270941558try k&#x3D; -0.4463866430261214 b&#x3D; 10.63854270941558try k&#x3D; -0.44638664967780084 b&#x3D; 10.638542867942219try k&#x3D; -0.446386640389808 b&#x3D; 10.638542630761927k&#x3D; -0.446386640389808 b&#x3D; 10.638542630761927x value when y&#x3D;0: 23.832573979973503 上述代码中，residuals(p)中的参数p为当前k值和b值构成的元组(k,b)。该函数根据x数组以及k,b参数计算理论y数组 - k*x+b， 然后用实验y数组减去理论y数组，得到误差数组。显然，返回的误差数组是一个长度为10的一维数组（x,y的长度均为10)。 leastsq(residuals,[1,0])以k=1, b=0为初始值，然后按照一定的数学规则去尝试不同的k,b值，直到residuals()返回的误差数组的平方和为最小。上述程序的输出结果中，我们可以看到leastsq()函数尝试过的不同的k,b值。 计算出k,b值后，y与x的函数关系也就确定：y = -0.45x + 10.64。在本例中，正常的人视力极限就是那个导致视觉诱发电位的振幅信号消失(=0)的最大空间频率。现在令y=0，则x = -b/k = 23.83。也就是说，当刺激图形的频率增加到23.83cpd时，受检者的视觉皮层不能产生有效的视觉诱发电位信号，这个空间频率就是受检者的视力极限。根据换算，该受检者的视力为20/25（Snellen视力表示法），换算成国内常用的对数视力就是0.8。请读者忽略眼视光学中空间频率至视力的换算关系。 我们使用下述代码绘制了实验数据的散点图以及拟合后的曲线： 12345678910#Leastsq.py...plt.scatter(x,y,label=\"Test Points\") #画散点图X = np.linspace(0,30,100) #画直线图Y = k*X + bsLabel = \"$y=&#123;:.2f&#125;x+&#123;:.2f&#125;$\".format(k,b)plt.plot(X,Y,label=sLabel)plt.legend() #显示图示plt.show() 执行结果 plt.scatter()用于绘制散点图， 共有10个点，每个点的横坐标来自实验x数组，纵坐标则来自实验y数组。label参数用于指定图示。接下来，我们生成了值域为0-30共100个数的等差数列X，再使用k,b参数计算出拟合直线的Y数组，最后用plt.plot(X,Y,label=sLabel)绘制拟合直线的折线图。注意，此处的sLabel以”$”符号开头和结束，这是LaTeX语法，专门用于生成数学公式。plt.legend()负责将右上角的图示显示出来。 21.4 线性代数-linalgnumpy和scipy都有线性代数模块linalg，scipy的linalg更全面。借助于linalg模块，可以轻松解决解线性方程组、求最小二乘解、求特征值和特征向量、奇异值分解等线性代数问题。这里，我们讨论最简单的解线性方程组。 常规意义上的线性方程组表现为Ax = b的形式，其中A为n行n列的方阵，b为长为n的向量。 解线程方程组，就是要计算x = A-1b。x也应为一个长为n的向量。当然，x,b也可视为n行1列的矩阵。 ​ 方法1：我们先求A的逆，再乘以矩阵b。 12345678910111213141516#Linalg1.pyimport numpy as npfrom scipy import linalgimport timeitn = 10A = np.random.rand(n,n) #随机数矩阵A(10,10)b = np.random.rand(n) #随机数矩阵b,(10,)print(\"shape of A:\",A.shape)print(\"shape of b:\",b.shape)x = np.dot(linalg.inv(A),b) #A求逆，再乘以bprint(\"x=\",x)print(\"shape of x:\",x.shape) #结果矩阵x,(10,)print(\"Time cost of 100 runs:\",end=\"\\t\")print(timeit.timeit(\"np.dot(linalg.inv(A),b)\", number=100, globals=globals())) 执行结果 123456shape of A: (10, 10)shape of b: (10,)x&#x3D; [-0.28212025 -1.33259652 0.84617787 -0.2331461 1.00000274 1.08582473 -0.83282803 -0.65152769 -0.34456785 1.3682035 ]shape of x: (10,)Time cost of 100 runs: 0.01988152700000001 这里的linalg.inv(A)对矩阵A求逆，np.dot()负责计算两个矩阵的乘积。timeit.timeit()函数将上述核心求解过程执行100次，统计总执行时间，单位为秒。其中，numer参数指定重复计算的次数，globals=globals()把当前作用域字典传递给timeit()函数，以便其内部重复执行np.dot(linalg.inv(A),b)时使用。可以看到，计算100次，总耗时0.0199秒，即19.9毫秒。 ​ 方法2: 12345678910#Linalg2.py...n = 10A = np.random.rand(n,n)b = np.random.rand(n)...x = linalg.solve(A,b) #唯一区别：使用linalg.solve()进行计算...print(\"Time cost of 100 runs:\",end=\"\\t\")print(timeit.timeit(\"linalg.solve(A,b)\", number=100, globals=globals())) 执行结果 123456shape of A: (10, 10)shape of b: (10,)x&#x3D; [ 2.38796492 2.47056651 -2.20444094 2.52781153 -0.63039871 -2.97342647 0.93749006 1.43893311 -1.51257363 0.02269402]shape of x: (10,)Time cost of 100 runs: 0.006561185000000025 方法2当中，我们没有借助于显式的矩阵求逆和矩阵乘法，而是借助于linalg.solve()方法。从timeit()的计时看，同样的数据规模，同样执次100次，费时为6.6毫秒，比方法1要快。作者这里需要说明，把n的值变大一些，比如100，再把执行次数改为10000，才能更好地排除偶然因素对执行时间的影响。 更一般地，任何C=A-1B形式的矩阵运算，都可以用linalg.solve()求解，其形式为C = linalg.solve(A,B)。 21.5 数值积分-integrateintegrate模块提供了好几种数值积分的方法，包括常微分方程组(ODE)的数值积分。相关函数列表如下： 函数名 作用 函数名 作用 quad() 一元定积分 dblquad() 二元定积分 triquad() 三元定积分 odeint() 计算常微分方程组的数值解 微实践 - 定积分求解​ 本小节求解下述定积分：$$\\int_{0.7}^4(cos(2\\pi x)e^{-x}+1.2)\\mathrm{d}x$$为了方便说明，我们先使用下述代码画出示意图： 123456789101112131415#Integrate1.pyimport numpy as npfrom matplotlib import pyplot as pltx = np.linspace(0,6,1000)y = np.cos(2*np.pi*x)*np.exp(-x)+1.2plt.axis([np.min(x),np.max(x),0,np.max(y)]) #坐标范围plt.plot(x,y,label=\"$cos(2\\pi x)e^&#123;-x&#125;+1.2$\") #画曲线，带图示plt.fill_between(x,y1=y,y2=0,where=(x&gt;=0.7)&amp;(x&lt;=4), #填充积分区域 facecolor='blue',alpha=0.2)plt.text(0.5*(0.7+4),0.4,r\"$\\int_&#123;0.7&#125;^4(cos(2\\pi x)e^&#123;-x&#125;+1.2)\\mathrm&#123;d&#125;x$\", horizontalalignment='center',fontsize=14) #增加说明文本plt.legend() #显示图示plt.show() 执行结果 plt.axis()函数设定了图的坐标范围。fill_between(x,y1=y,y2=0,where=(x&gt;=0.7)&amp;(x&lt;=4)…)则用于填充积分区域，其中，x和y1构成曲线1; x和y2=0构成曲线2(也就是横坐标线)；该函数填充两条曲线之间x值域为[0.7,4]的部分，where参数指明了这个值域。facecolor指定填充颜色，alpha参数指定透明度。 plt.text()则在图上添加文本，前两个参数指定了文本的坐标位置，horizontalalignment=’center’要求文本在指定的位置水平居中摆放(指定位置位于文本的水平中心)。r”$…$“为文本内容：字符串前加r表示放弃对字符串内的内容进行\\转义；两个$包含起来说明其中的内容为LaTeX格式的公式。 显然，上述定积分就是图中阴影部分的面积。 ​ 方法1：分成小矩形，计算面积和 12345678#Area.pyimport numpy as npx = np.linspace(0.7,4.0,1000)y = np.cos(2*np.pi*x)*np.exp(-x)+1.2dx = x[1] - x[0] #每个矩形的宽度fArea = np.sum(y*dx) #矩形宽*高，再求和print(\"Integral area:\",fArea) 执行结果 1Integral area: 4.032803310221616 上述代码中，把曲线的阴影部分分成1000个矩形，每个矩形的宽都是dx，第i个矩形的高则是yi。每个矩形的长乘宽，再求和，得积分面积。注意，上述x,y均是形状为(1000,)的数组。 ​ 方法2：使用quad()函数进行积分 12345678910#Quad.pyimport mathfrom scipy import integratedef func(x): print(\"x=\",x) #用于展示quad()函数对func的多次调用 return math.cos(2*math.pi*x)*math.exp(-x)+1.2fArea,err = integrate.quad(func,0.7,4)print(\"Integral area:\",fArea) 执行结果 1234567x&#x3D; 2.35x&#x3D; 0.7430542279466668x&#x3D; 3.9569457720533334x&#x3D; 2.4613227224815875...x&#x3D; 3.4178741117287044Integral area: 4.029065401143393 首先，我们定义了一个函数func()，它根据x计算y值。当对单个数值进行计算时，numpy的ufunc并不具备速度优势，所以我们使用了math模块。 integrate.quad()专门用于计算一元定积分，fArea,err = integrate.quad(func,0.7,4)取x值域[0.7,4]进行数值积分，在积分过程中，会反复调用func()函数计算y值。其返回一个元组，包括积分结果及误差。 integrate.quad()计算的积分会比方法1的矩形面积求和方法更加精确。 微实践 - Lorenz吸引子常微分方程组求解在“数学之美”那一章里，为方便读者理解，Lorenz吸引子轨迹的计算采用了比较“原始”的方法。采用integrate模块中的odeint()函数可以更加方便地完成计算。Lorenz吸引子由下述三个微分方程定义：$$\\frac{dx}{dt}=\\sigma(y-x), \\quad \\frac{dy}{dt}=x(\\rho-z)-y,\\quad \\frac{dz}{dt}=xy-\\beta z$$其中，σ, ρ, β为参数。这些方程定义了三维空间中的一个无质量点(x,y,z)的各轴坐标相对于时间的速度矢量。我们这里需要计算随着时间t的变化，无质量点(x,y,z)的运动轨迹，也就是一组时间点上的系统状态。 ​ 源代码如下： 12345678910111213141516171819202122#Lorenz.pyimport numpy as npfrom scipy import integrateimport matplotlib.pyplot as pltfrom mpl_toolkits.mplot3d import Axes3Ddef lorenz(p,t,s,r,b): x,y,z = p.tolist() #无质量点的当前位置(x,y,z) print(\"x,y,z,t:\",x,y,z,t) #帮助理解odeint的执行过程 return s*(y-x),x*(r-z)-y,x*y-b*z #返回dx/dt,dy/dt,dz/dtt = np.arange(0,30,0.01)track1 = integrate.odeint(lorenz,(0.0,1.00,0.0),t,args=(10.0,28.0,2.6))track2 = integrate.odeint(lorenz,(0.0,1.01,0.0),t,args=(10.0,28.0,2.6))print(\"type(track1):\",type(track1),\"track1.shape:\",track1.shape)fig = plt.figure(figsize=(12,6))ax = fig.gca(projection='3d') #获取当前子图，指定三维模式ax.plot(track1[:,0],track1[:,1],track1[:,2],lw=1.0,color='r') #画轨迹1 ax.plot(track2[:,0],track2[:,1],track2[:,2],lw=1.0,color='g') #画轨迹2 ...plt.show() 控制台输出： 123456...x,y,z,t: -5.64346434502397 -6.711791064199058 21.875348370569984 12.728116763457338x,y,z,t: -5.6434643216721705 -6.7117909582448 21.875348207825766 12.728116763457338x,y,z,t: -5.776218568580239 -7.038353710472807 21.677470196579595 12.739506857199522...type(track1): &lt;class &#39;numpy.ndarray&#39;&gt; track1.shape: (3000, 3) 首先，定义了函数lorenz()，它的任务是计算无质量点坐标各方向相对于时间t的微分值。参数s,r,b分别对应方程组中的σ, ρ, β，t为时间（在函数里没有用到），p是一个ndarray，p.tolist()将其转换成一个列表，其中包括当前无质量点的坐标。 t = np.arange(0,30,0.01)以0.01为间隔，生成从0至30(不含)的等差数列，它代表了一组离散的时间点。 integrate.odeint()则进行微分方程求解，参数lorenz指明了微分计算函数，(0.0,1.00,0.0)则为无质量点的位置初始值；t为离散时间点；args指定了要传递给lorenz函数的额外参数，对应s,r,b，为固定值。odeint()会迭代调用lorenz()函数，用于生成无质量点的运动轨迹。上述控制台输出的结果可以帮助读者理解x,y,z坐标及t的变化过程。 t是一个长度为3000的一维数组，odeint()返回结果为一个形状为(3000,3)的二维数组，用3000个离散的三维空间点来表示无质量点的运动轨迹。据信，odeint()会将lorenz()函数返回的微分值再乘以dt以获得dx,dy和dz，这个过程其实跟我们在“数学之美”那一章的模拟计算过程类似，但更高效，更精确。 track1[:,0]对track1二维数组进行下标切片，得到3000个元素的一维数组，表示3000个空间点的x坐标，y和z坐标以类似方式获得。 我们可以看到，track1-红和track2-绿仅在系统初始值上有细微差异，但随着时间的推进，其运动轨迹差异越来越大，表现出“混沌”性：南美洲一只蝴蝶扇动翅膀，会引起对面半球一场飓风。 21.6 信号处理-signalSciPy中的signal模块支持信号处理，提供了：卷积运算、B样条、滤波等各种功能。 微实践 - ECG信号的谱分析及滤波本节的阅读需要傅里叶级数及傅里叶变换的相关数学知识。 示范代码目录下有一个ecgsignal.dat文件，这里存储了作者采集的一段人体心电信号-ECG。这个文件以4字节浮点数存储样本，单位为μV，采样总数 = 文件大小 / 4，采样频率 = 2000样本/秒。需要说明的是，这个心电信号不是标准的医用心电信号，作者在一台其它用途的医用电生理设备上，用左手拿着正电极，右手拿着负电极，简单记录了上述信号。而且，作者故意没有涂用于皮肤电极的导电膏，以便引入“工频干扰”。 分析信号的频谱 - spectrum 心电信号可以视为定义在时间t上的函数，把这个函数进行傅里叶级数展开，可以将其表达成不同频率/周期的正弦函数的和。而这些正弦项的系数，则表明了该种频率的正弦项在信号构成中的重要程度。所谓的频谱分析，就是把时间t上的函数，转换成频率f上的函数，即把信号从时域转换到频域。这种转换，可以通过傅里叶变换实现。在离散的计算机世界里，对应的算法工具称为快速傅里叶变换 - Fast Fourier Transform，简称FFT。 1234567891011121314151617181920212223#Spectrum.pyimport numpy as npfrom matplotlib import pyplot as pltiSampleRate = 2000 #采样频率,每秒2000个样本x = np.fromfile(\"ecgsignal.dat\",dtype=np.float32)iSampleCount = x.shape[0] #采样数t = np.linspace(0,iSampleCount/iSampleRate,iSampleCount)xFFT = np.abs(np.fft.rfft(x)/iSampleCount) #快速傅里叶变换xFreqs = np.linspace(0, iSampleRate/2, int(iSampleCount/2)+1)plt.figure(figsize=(10,6))ax0 = plt.subplot(211) #画时域信号ax0.set_xlabel(\"Time(s)\")ax0.set_ylabel(\"Amp(μV)\")ax0.plot(t,x)ax1 = plt.subplot(212) #画频域信号-频谱ax1.set_xlabel(\"Freq(Hz)\")ax1.set_ylabel(\"Power\")ax1.plot(xFreqs, xFFT)plt.show() 执行结果 先点下方工具栏中的放大镜，然后按住鼠标左键框选放大，可以帮助我们帮察信号及频谱的细节： np.fromfile(“ecgsignal.dat”,dtype=np.float32)从文件读取信号数据，numpy会以二进制格式打开文件，读取数据，并以4个字节为单位，逐一转换成np.float32类型，然后返回一个一维数组。该数组包含全部采样。 np.float32类型表示一个采样浮点数由32个bit，即4个字节构成。 np.linspace(0,iSampleCount/iSampleRate,iSampleCount)则生成了与信号x相同维度的一维数组t，其中的数据对应每个样本的采样时间。其中，iSampleCount为采样总数，iSampleRate为采样频率。如果采样总数=6000，则信号的总时间长度为6000/2000(采样频率)=3秒。后续代码中的ax0.plot(t,x)则以时间t为横轴，信号振幅x为纵轴，在ax0子图上画出时域信号。 np.fft模块支持快速傅里叶变换，其中的rfft()函数对实数信号进行FFT运算。根据计算公式，还需要将返回结果除以iSampleCount以便正确显示波形能量。 rfft()函数的返回值是iSampleCount/2+1个复数，分别表示从0(Hz)到iSampleRate/2(Hz)的频率能量。np.abs()对rfft()返回数组中的复数进行求模(abs)。受限于香农采样定理，采样频率为2000Hz的信号，有效的信号频率最高为1000Hz。 xFreqs = np.linspace(0, iSampleRate/2, int(iSampleCount/2)+1)则负责生成与xFFT中的能量相对应的频率。此时,(xFreqs,xFFT)可视为定义在频率域xFreqs上的“信号”，即原时域信号(t,x)的频谱。后续代码中的ax1.plot(xFreqs, xFFT)则以频率为横轴，能量为纵轴，在ax1子图上画出频谱。 顺便再次指出，plt.subplot(211)将当前图按2行1列划分，在1号位置（即上方位置）创建一张子图ax0，同理，plt.subplot(212)则在2号位置（即下方位置）创建一张子图ax1。 在下方频谱图中，我们看到在50Hz处存在一个巨大的峰，这些能量对应着那些叠加在原始信号上的有规律的周期小波，这就是所谓的工频干扰。读者可以数一数下方上图中从3.0秒至3.2秒的周期小波的周期(峰到峰）个数，应该是10个，0.2秒10个周期对应1秒种50个周期。我国的市电是220V/50Hz交流电，交变的电流流过市电导线，向空间辐射能量，这些辐射能量借助于人体，电极线等与市电导线的耦合电容，进入了信号放大器，形成“干扰”。此外，我们在100Hz处也可以看到频谱能量的峰，100Hz正好是50Hz 的倍频，也是所谓工频干扰的一部分。可以想象，如果同样的干扰发生在美国，其频率应为60Hz，因为当地的市电是110V/60Hz交流电。这里，50Hz的工频干扰我们将使用带阻滤波器，也叫陷波器滤除。 在频谱图中，我们还看到在0Hz附近也有较多能量，这些低频成分对应原始信号里缓慢变化的基线。这些低频成分也不具备诊断意义，需要滤除。我们选择使用一个带通滤波器，滤除3Hz以下的低频信号，同时滤除70Hz以上的高频信号。 滤波器设计 滤波是个宏大的课题，这里我们只能描述一种简便的应用方法，不描述背后的数学原理。 我们需要两个滤波器，其中一个是3-70Hz的带通滤波器，它保留信号中3-70Hz的频率成分，去除低于3Hz的低频部分以及高于70Hz的高频部分。另外一个是48-52Hz的带阻滤波器，别名50Hz陷波器，它去除信号中48-52Hz的成分。 下图展现了我们设计的带通滤波器(左)及带阻滤波器(右)的频率响应。横轴为频率，纵轴为滤波器对该频率信号的增益(gain)，当增益为1.0时，说明该频率信号无障碍通过滤波器，当增益小于1.0时，说明通过滤波器时，该频率信号被衰减。可以看到，当滤波器的阶(order)越高，则滤波器性能越好(频响曲线陡峭)，但计算量也会增加。 相关滤波器设计代码如下: 12345678910111213141516171819202122232425262728293031323334353637#FilterResponse.pydef butterBandPassFilter(lowcut, highcut, samplerate, order): \"生成巴特沃斯带通滤波器\" semiSampleRate = samplerate*0.5 low = lowcut / semiSampleRate high = highcut / semiSampleRate b,a = signal.butter(order,[low,high],btype='bandpass') print(\"bandpass:\",\"b.shape:\",b.shape,\"a.shape:\",a.shape,\"order=\",order) print(\"b=\",b) print(\"a=\",a) return b,adef butterBandStopFilter(lowcut, highcut, samplerate, order): \"生成巴特沃斯带阻滤波器\" semiSampleRate = samplerate*0.5 low = lowcut / semiSampleRate high = highcut / semiSampleRate b,a = signal.butter(order,[low,high],btype='bandstop') print(\"bandstop:\",\"b.shape:\",b.shape,\"a.shape:\",a.shape,\"order=\",order) print(\"b=\",b) print(\"a=\",a) return b,aiSampleRate = 2000 #采样频率plt.figure(figsize=(12,5))ax0 = plt.subplot(121)for k in [2, 3, 4]: b, a = butterBandPassFilter(3,70,samplerate=iSampleRate,order=k) w, h = signal.freqz(b, a, worN=2000) ax0.plot((iSampleRate*0.5/np.pi)*w,np.abs(h),label=\"order = %d\" % k)ax1 = plt.subplot(122)for k in [2, 3, 4]: b, a = butterBandStopFilter(48, 52, samplerate=iSampleRate, order=k) w, h = signal.freqz(b, a, worN=2000) ax1.plot((iSampleRate*0.5/np.pi)*w,np.abs(h),label=\"order = %d\" % k) 控制台输出： 1234567bandpass: b.shape: (5,) a.shape: (5,) order&#x3D; 2b&#x3D; [ 0.00961483 0. -0.01922967 0. 0.00961483]a&#x3D; [ 1. -3.70024346 5.14358108 -3.18588885 0.74255496]bandpass: b.shape: (7,) a.shape: (7,) order&#x3D; 3...bandpass: b.shape: (9,) a.shape: (9,) order&#x3D; 4... 下述讨论中，f0等于采样频率的一半，即代码中的iSampleRate*0.5，或者samplerate*0.5。 从控制台输出可以看到，signal.butter()函数生成滤波器的结果为两个一维数组b和a。数组里存储一些实数，滤波器的阶(order)越大，b,a包含的实数个数越多。b,a是IIR滤波器的系数。btype参数指明了滤波器的类型，bandpass意为带通，bandstop意为带阻。[low,high]则指明了滤波器的截止频率。上述代码说明，这里的low和high应等于截止频率/f0。当采样频率为2000时，f0=2000*0.5=1000，则3Hz的截止频率对应low = 3/1000 = 0.003，70Hz的截止频率对应high = 70 / 1000 = 0.07。 freqz()函数用于计算滤波器的频率响应，返回w,h两个数组。其中，w是圆频率数组，通过w*f0/π可以计算出与其对应的频率，h是w对应频率点的响应，它是一组复数，其幅值表示滤波器的增益特性，相角表示滤波器的相位特性。参数worN表明了要计算的频率的项数，该值越大，计算越精细。 上述代码中，我们生成了阶为2,3,4的3-70Hz带通滤波器共3个，阶为2,3,4的48-52Hz带阻滤波器共3个，然后分别生成并显示了其频率响应曲线，以供读者观察。上述代码中，np.abs()函数用于求复数数组的模。 上图中，我们还画了一条sqrt(0.5)的虚线，这里对应着所谓的-3dB增益。此处，对应频率的信号的功率缩减为最高功率的一半。 滤波 我们应用上述滤波器对信号进行了滤波，结果如下图（局部放大）： 可以看到，在3-70Hz带通滤波器的作用下，0Hz附近的极低频成分消失了，70Hz以后的高频成分也得到有效抑制。同时，我们注意到100Hz的干扰成分仍有残留。 在48-52Hz带阻滤波器的作用下，50Hz附近工频干扰几乎完全消失。上图中，我们看到了基线不飘移，50Hz工频周期波完全去除后的“干净”的ECG信号。这个信号来自于心脏，常在医用心电监护仪上看到。每个“尖波”对应着一次心跳，读者可以计算一下作者记录这段信号时的心率。 相关滤波的代码如下： 12345678910111213#Filter.pyiSampleRate = 2000 #采样频率,每秒2000个样本x = np.fromfile(\"ecgsignal.dat\",dtype=np.float32)#进行带通滤波b,a = butterBandPassFilter(3,70,iSampleRate,order=4)x = signal.lfilter(b,a,x)#进行带阻滤波b,a = butterBandStopFilter(48,52,iSampleRate,order=2)x = signal.lfilter(b,a,x)... #谱分析及画图部分代码略 滤波的代码十分简单。signal.lfilter()将滤波器返回的b,a数组应用于信号x上，滤波后返回一个新数组。读者一定有点好奇，lfilter()内部到底做了些什么。对于FIR-有限脉冲响应滤波器，a组系数不适用，对于输出信号数组y的任意点y[i]，其值为：$$y_i=b_0x_i+b_1x_{i-1}+…+b_px_{i-p}$$​ 这就是个简单的乘积和。对于IIR-无限脉冲响应滤波器，对于输出信号数组y的任意点y[i]，其值为：$$y_i=\\frac{b_0x_i+b_1x_{i-1}+…+b_px_{i-p}-a_1y_{i-1}-a_2y_{i-2}-…-a_qy_{i-q}}{a_0}$$​ 上述两个公式中，p+1为b数组的元素个数；q+1为a数组的元素个数。 巴特沃斯滤波器只是IIR滤波器的一种。 使用firwin()、remez()等函数可以设计FIR滤波器。iirdesign()函数则可以帮助设计IIR滤波器。要想彻底弄明白滤波器背后的数学原理，不是一件容易的事情。 21.7 插值-interpolate插值和拟合（如最小二乘拟合）都试图通过已知的实验离散数据求未知数据。与拟合不同，插值要求曲线通过所有已知数据点。interpolate模块用于此目的。 21.7.1 一维interp1d我们从最简单的一维插值说起。为了让读者明白什么是插值，我们生成了[0,10]上共10个元素的等差数列及其正弦值，模拟所谓的10个实验数据点。这10个实验数据点的散点图如下图中的points子图。 123456789101112#Interpolate.pyfrom scipy import interpolateimport numpy as npfrom matplotlib import pyplot as pltx10 = np.linspace(0,10,10)y10 = np.sin(x10)plt.figure(figsize=(12,6))ax = plt.subplot(231) #2行3列，在位置1创建子图ax.scatter(x10,y10,c='black') #画散点图ax.set_title(\"points\") 执行结果 假设在某项科学试验中，我们测试并记录了上述10个试验点。现在要从这10个试验推测y和x之间的函数关系，并以此为依据，计算其它x所对应的 y值。这个过程就是所谓的“插值”。一眼望去，这些点是散乱没有规律的，难以推断背后的函数关系。在一元函数关系中，该插值可以通过interp1d类型来完成。注意interp1d是一个类型，不是函数。interp1d()是这个类的构造函数的调用形式。 123456789101112131415#Interpolate.pyx100 = np.linspace(0,10,100) #[0,10]的包含100个元素的等差数列colors = ['red','green','blue','purple']for i,kind in enumerate(['nearest','zero','slinear','quadratic']): f = interpolate.interp1d(x10,y10,kind=kind) #从10个实验数据点插值 print(\"type of f:\",type(f)) y100 = f(x100) #应用插值结果计算100个数的“函数”值 ax = plt.subplot(232+i) #2行3列，2+i位置建子图 ax.scatter(x10,y10) ax.plot(x100,y100,c=colors[i]) #画100点的折线图以反应“函数”关系 ax.set_title(kind)plt.subplots_adjust(left=0.05,right=0.95,bottom=0.05,top=0.95, wspace=0.2,hspace=0.2) #调整子图间距等plt.show() 控制台输出： 123type of f: &lt;class &#39;scipy.interpolate.interpolate.interp1d&#39;&gt;...type of f: &lt;class &#39;scipy.interpolate.interpolate.interp1d&#39;&gt; 上述代码的绘图结果见上图中的nearest, zero, slinear, quadratic子图。 interpolate.interp1d类型的构造函数接受(x,y,kind)等参数。其中，x,y提供了实验数据点，kind则指明了插值类型。该构造函数返回一个对象f，这个对象f内部包括了插值后的“函数关系”。f对象是callable-可调用的，也就是说它也是一个函数。f(x100)将[0,10]的包含100个数的等差数列交给f“函数”进行计算，得y100，y100中的数值就是插值推测的结果。如果读者对f到底是对象还是函数感到疑惑，请回顾“面向对象”一章的观点：万物皆对象。 我们逐一使用四种kind进行插值计算，并把相关结果绘制出来供读者观察。可以看到，quadratic插值结果几乎跟原始sin()函数一模一样。plt.subplot(232+i)意味着将图(figure)分成2行3列，在第2+i个位置上创建一个子图 - axes。 kind参数有如下可选值： 插值类型 说明 zero,nearest 阶梯插值，相当于0阶B样条曲线； slinear, linear 线性插值，相当于1阶B样条曲线，简单地说，就是实验数据点的折线连接； quadratic 二阶插值，即2阶B样条曲线； cubic 三阶插值，3阶B样条曲线；事实上，kind参数可以为int，直接指定阶数。 需要注意的是，interp1d对象取得后，也只能计算由实验数据所框定的数值范围的函数。上例中，f([1,9])是合法的，而f([12,19])则会产生异常，因为12,19都超出了由实验数据点所框定的值域。 21.7.2 拟合与外推UnivariateSplineinterp1d的插值曲线要求经过所有实验数据点，并且，不能进行外推：即计算实验数据点范围之外的函数值。UnivariateSpline类的插值比interp1d更高级，允许外推和拟合（曲线不经过实验数据点）。 为解释UnivariateSpline类型，我们先在没有噪声的标准正弦数据点上进行插值和外推。 123456789101112131415#UnivariateSpline.pyimport numpy as npfrom scipy import interpolatefrom matplotlib import pyplot as pltplt.figure(figsize=(12,4))x = np.linspace(0,10,20) #[0,10]含20个值的等差数列y = np.sin(x) #y = x的正弦plt.scatter(x,y,s=20,label=\"points\") #画散点图xs = np.linspace(0,12,100) #[0,12]含100个值的等差数列，12&gt;10,外推ys = interpolate.UnivariateSpline(x,y,s=0)(xs) #由(x,y)插值，函数应用于xsplt.plot(xs,ys,lw=2,label=\"spline,s=0\") #画(xs,ys)，ys由插值函数计算而来plt.plot(xs,np.sin(xs),lw=2,label=\"sin(x)\") #画标准正弦函数(xs,np.sin(xs))plt.legend() #显示图示plt.show() 执行结果 这行代码需要进行解释：ys = interpolate.UnivariateSpline(x,y,s=0)(xs)。类似于interp1d，UnivariateSpline也是一个类型，其构造函数接受(x,y)作为实验数据点，返回一个插值对象。这个对象类型为UnivariateSpline，同时也是一个可调用对象-函数。为帮助读者理解，这行代码可以拆成两行： 12f = interpolate.UnivariateSpline(x,y,s=0)ys = f(xs) 我们使用这个插值对象/函数来计算xs，返回包含部分外推的函数结果ys。请注意，试验数据点中x的值域为[0,10]，而xs的值域为[0,12]，超出了原有范围。 为了反应插值函数的准确性，我们还画了一条标准的正弦曲线sin(x)。可以看到，在值域[0,10]范围内，插值曲线与标准正弦几乎完全重合，但在外推的部分，即[10,12]这个区间，效果并不理想。 上述插值类构造函数的完整调用形式为： ​ UnivariateSpline(x, y, w=None, bbox=[None, None], k=3, s=None, ext=0, check_finite=False) 其中，w可以为每个数据指定权重；k默认为3，指定样条曲线的阶；s则是平滑系数，它使得最终生成的样条曲线满足下述条件：$$sum((w[i] * (y[i]-spl(x[i])))**2, axis=0) &lt;= s$$可以看出，当s&gt;0时，样条曲线-spl不一定通过实验数据点，可视为曲线拟合。当s=0，样条曲线必须通过实验数据点。在本例中，s=0，我们看到所有的实验数据点都在样条曲线”spline,s=0”上。 在实践当中，误差永远存在，可以认为实验数据点永远都包括噪声。接下来，我们给实验数据点加入一些噪声，再试图进行插值拟合。 123456789101112131415#UnivariateSpline2.pyimport numpy as npfrom scipy import interpolatefrom matplotlib import pyplot as pltplt.figure(figsize=(12,4))x = np.linspace(0,20,200) #[0,20]等差数列，200个值y = np.sin(x) + np.random.standard_normal(len(x))*0.16 #带噪声正弦plt.scatter(x,y,s=3,label=\"noisy points\") #散点图：噪声实验数据点xs = np.linspace(0,23,2000) #[0,23]等差数列，2000个值ys = interpolate.UnivariateSpline(x,y,s=8)(xs) #由(x,y)插值，函数应用于xsplt.plot(xs,ys,lw=2,label=\"spline,s=8\") #画(xs,ys)，ys由插值函数计算而来plt.plot(xs,np.sin(xs),lw=2,label=\"sin(x)\") #画标准正弦函数(xs,np.sin(xs))plt.legend()plt.show() 执行结果 np.random.standard_normal()函数生成len(x)个标准正态分布的随机数，这些随机数的取值范围为0-1，乘以0.16以控制其范围。 本次插值过程中，我们指定平滑参数s=8，这将允许样条曲线不经过实验数据点。我们看到，由于噪声的存在，即便在试验数据点的值域[0,20]范围内，插值函数未能与标准正弦曲线完全重合。在外推的值域部分，即[20,23]，则差得更多。 21.7.3 二维插值二元函数形如z = f(x,y)，对其进行插值则需要使用interp2d类型。 123456789101112131415161718192021222324252627282930#interp2d.pyimport numpy as npfrom matplotlib import pyplot as pltfrom matplotlib import cmfrom scipy import interpolateplt.figure(figsize=(12,4))y,x = np.ogrid[-2:2:20j,-2:2:20j]z = (x+y)*np.exp(-x**2-y**2) #20x20的实验数据点extent = [np.min(x),np.max(x),np.min(y),np.max(y)]ax = plt.subplot(131)ax.imshow(z,extent=extent,cmap=cm.rainbow)ax.set_title(\"20x20\")func = interpolate.interp2d(x,y,z,kind='cubic') #二维插值x1 = np.linspace(-2,2,300)y1 = np.linspace(-2,2,300)z1 = func(x1,y1) #根据插值函数计算函数值，要求参数为一维数组ax = plt.subplot(132)ax.imshow(z1,extent=extent,cmap=cm.rainbow)ax.set_title(\"interp2d_300x300\")y2,x2 = np.ogrid[-2:2:300j,-2:2:300j]z2 = (x2+y2)*np.exp(-x2**2-y2**2) #计算标准函数并显示以便对照ax = plt.subplot(133)ax.imshow(z2,extent=extent,cmap=cm.rainbow)ax.set_title(\"original_300x300\")plt.show() 执行结果 上述代码的第一部分生成了函数：$$z(x,y)=(x+y)e^{-x^2-y^2}$$的20x20个实验数据点，作为插值用。这20x20个数据点作为图像描绘了出来，可以看到，图像很粗糙（图左）。 上述代码的第二部分则对实验数据点使用类型interp2d(x,y,z…)进行了插值，得到可执行对象func。然后使用可执行对象func对300x300个(x,y)点计算z值，并描绘成图像（图中）。需要注意的是，二维插值对象要求参数必须是一维数组，其内部计算时，会对输入参数进行类似“广播”的处理。 上述代码的第三部分则计算并描绘了标准的函数图像（图右）。可以看到，插值生成的函数图像与标准的函数图像高度相似。 此外，通过splev, splprep等类型能进行参数曲线的插值。这些参数曲线可以是二维甚至高维空间的曲线。通过pchip类型则可以进行所谓单调插值。 21.8 稀疏矩阵、图像处理、统计及其它本小节简介一下其它无法详细介绍的重要模块。 数学中的矩阵通常用计算机里的多维数组来表示。但如果矩阵很稀疏：即矩形的大多数元素都是0，用ndarray进行存储就非常地浪费。scipy.sparse模块提供了多种表示稀疏矩阵的格式；scipy.sparse.linalg则提供了对稀疏矩阵进行线性代数运算的专用函数；scipy.sparse.csgraph则可以对稀疏矩阵所代表的“图”进行搜索，比如应用著名的Dijkstra算法进行单源最短路径求解。 scipy.ndimage提供了基础的图像处理功能， 包括： 模块 用途 模块 用途 filters 图像滤波 fourier 傅里叶变换 interpolation 图像插值、旋转、仿射变换 measurements 图像测量 morphology 形状学处理 事实上，有比scipy更加强大的图像处理库，比如opencv-python， pillow， scikit-image等。 stats模块提供数理统计计算支持。包括连续、离散概率分布、卡方分布及其检验、t分布及其检验、二项和泊松分布等功能。 spatial模块则提供众多的空间算法，包括凸包、K-d树、沃德罗伊图、德劳内三角化等。 21.9 小结我们真的浅尝则止了，scipy库十分强大。提醒读者，任何时候，当你试图进行一些跟”科学”有关的计算，别忘记先查询一下scipy是否提供相应支持，以避免重新发明轮子。与SciPy不同，Python社区里还有一个叫做SymPy的符号运算库，用它可以进行数学表达式的符号推导和演算。 本文内容节选自作者编著的《Python编程基础及应用》（高等教育出版社）一书。 免费随书B站MOOC:","categories":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/categories/Python/"},{"name":"科学计算","slug":"Python/科学计算","permalink":"http://codelearn.club/categories/Python/%E7%A7%91%E5%AD%A6%E8%AE%A1%E7%AE%97/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/tags/Python/"}]},{"title":"加速扩展库下载 - 修改pip的安装源","slug":"pipsource","date":"2019-10-14T23:35:04.000Z","updated":"2020-09-11T06:22:55.094Z","comments":true,"path":"2019/10/pipsource/","link":"","permalink":"http://codelearn.club/2019/10/pipsource/","excerpt":"因为伟大的墙的原因，pip通过位于国外的源服务器下载扩展安装包的速度特别慢，对初学者不太友好。 上述问题可以通过修改pip的安装源至国内的镜像服务器来解决。","text":"因为伟大的墙的原因，pip通过位于国外的源服务器下载扩展安装包的速度特别慢，对初学者不太友好。 上述问题可以通过修改pip的安装源至国内的镜像服务器来解决。 [本篇文章的内容由重庆大学2018级罗少航同学书写] 1. 先定位并找到你的Python解释器安装路径 2. 新建名为pip的文件夹并打开，此时效果应类似下图 3. 确保如下图所示的复选框被选中。 4. 右键新建，选择文本文档，打开键入图中的内容并保存 该文本的内容如下[方便读者复制粘贴]： 1234[global]timeout = 6000index-url = http://pypi.douban.com/simpletrusted-host = pypi.douban.com 5. 重命名该文件为pip.ini，此时会弹出如图提示框，选择是 6. 最终效果如图 然后， 再使用pip安装扩展或者使用Visual Studio Code下载插件，速度会快很多。 除了douban的源之外，清华的源也不错，其地址为： 1https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple 此外，在使用pip安装库时，也可以通过-i参数临时指定安装源： 1pip install django -i https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple 本文内容节选自作者编著的《Python编程基础及应用》（高等教育出版社）一书。 免费随书B站MOOC:","categories":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/tags/Python/"}]},{"title":"Windows下的截图方法","slug":"snap","date":"2019-10-08T14:14:04.000Z","updated":"2020-09-11T06:29:47.638Z","comments":true,"path":"2019/10/snap/","link":"","permalink":"http://codelearn.club/2019/10/snap/","excerpt":"本文讨论Windows操作系统环境下截图的方法","text":"本文讨论Windows操作系统环境下截图的方法 版权声明 本文可以在互联网上自由转载，但必须：注明出处(作者：海洋饼干叔叔)并包含指向本页面的链接。 本文不可以以纸质出版为目的进行改编、摘抄。 学习过程中撰写实验报告，向老师，学长请教问题，通常需要截图。 方法1：使用QQ的Ctrl+Alt+A快捷键, 框定对应区域后，双击被框定的区域，然后在QQ中按Ctrl-V, 即可。 方法2：仅适用于Windows 10 Win + Shift + S , 然后在QQ中Ctrl-V贴图。 凡是本班同学，请教问题时，请务必在电脑上登录QQ, 截图。不要拍照。 本文内容节选自作者编著的《Python编程基础及应用》（高等教育出版社）一书。 免费随书B站MOOC:","categories":[{"name":"导论","slug":"导论","permalink":"http://codelearn.club/categories/%E5%AF%BC%E8%AE%BA/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/tags/Python/"}]},{"title":"Python下如何创建一个文本格式的进度条","slug":"progressbar","date":"2019-07-30T16:20:04.000Z","updated":"2020-09-11T06:23:06.795Z","comments":true,"path":"2019/07/progressbar/","link":"","permalink":"http://codelearn.club/2019/07/progressbar/","excerpt":"本文讨论Python下如何创建一个文本格式的进度条，就像pip下载时的进度条一样。","text":"本文讨论Python下如何创建一个文本格式的进度条，就像pip下载时的进度条一样。 版权声明 本文可以在互联网上自由转载，但必须：注明出处(作者：海洋饼干叔叔)并包含指向本页面的链接。 本文不可以以纸质出版为目的进行改编、摘抄。 微实践 - 文本进度条 当计算机执行一个耗时较长的任务时，通常需要显示一个进度条给操作者，便于操作者评估执行进展并缓解其焦虑。本小节讨论如何在文本控制台上通过print()函数显示进度条。 当使用print()函数向系统标准输出输出文本时，总是逐行递增的。如果不特定说明，每个print()函数总是会在输出的末尾补充输出一个换行符”\\n”。通过指定print的end参数为换行符之外的其它值，可以避免print()函数的自动换行。 12345#printend.pyprint(\"我还记得几位唐朝诗人：\",\"李白\",end=\",\")print(\"杜甫\",end=\",\")print(\"白居易\",end=\",\")print(\"孟浩然\",end=\",\") 执行结果： 1我还记得几位唐朝诗人： 李白,杜甫,白居易,孟浩然, 要保持文本进度条在多次刷新时不换行， 我们还得借用另外一个转义符：”\\r”。这个转义符将使得控制台输出指针回到当前行的行首。 1print(\"abcdefghijklmn\\r123\") 执行结果： 1123defghijklmn 上述执行结果证明，在输出了”abcdefghijklmn”之后，”\\r”的输出导致控制台输出指针回到了行首，”123”的输出覆盖了abc。 借助于转义符”\\r”，我们设计了下述文本进度条显示函数。 1234567891011121314151617#ProgressBar.pyprogressBefore = 0def printProgressBar(percent, prefix = ''): global progressBefore if percent - progressBefore &lt; 0.001: #只有当进度达到千分之一才刷新，避免频繁刷新进度条 return progressBefore = percent percentStr = (\"&#123;0:.1f&#125;\").format(percent*100) #格式化字符串，参见字符串进阶一章相关内容 filledLength = int(30 * percent) bar = '█' * filledLength + '-' * (30 - filledLength) print('\\r%s |%s| %s%% ' % (prefix, bar, percentStr),end='')if __name__ == \"__main__\": #参见模块与扩展库 - 模块测试相关章节 import time for i in range(1000): printProgressBar((i+1)/1000,prefix=\"Progress:\") time.sleep(0.01) #当前进程暂停10ms 代码说明 - percent参数取值范围0-1，表示百分比进度；prefix表示进度条前方的前缀文本。 - 只有当percent - progressBefore大于等于千分之一时才会刷新进度条，这样做可以避免进度条不必要的频繁刷新。- 进度条的黑色部分是由多个字符█串起来形成的，而█与 - 的个数则根据percent计算而得，两者的个数之和为30。- print()一开始就输出了一个”\\r”，让输出光标回到行首，end=’’则指定print的结尾为空，不要输出默认的’\\n’。 由于”\\r”转义符的应用，每次进度条刷新，输出都会从行首开始，而且输出完成后，end=’’参数避免了自动换行。所以，虽然我们多次通过print()函数输出进度，但总是显示在同一行。 读者可能会对代码if __name__ == “__main__“的作用感到疑惑，这行代码用于包裹模块内的测试用代码，具体细节在第14章讨论。 本文内容节选自作者编著的《Python编程基础及应用》（高等教育出版社）一书。 免费随书B站MOOC:","categories":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/tags/Python/"}]},{"title":"Python下的数值列表 - range(x,y,z)函数","slug":"range","date":"2019-07-30T16:14:04.000Z","updated":"2020-09-11T06:28:51.040Z","comments":true,"path":"2019/07/range/","link":"","permalink":"http://codelearn.club/2019/07/range/","excerpt":"本文讨论Python下的数值列表 - range(x,y,z)函数的应用，并分析其计数过程。","text":"本文讨论Python下的数值列表 - range(x,y,z)函数的应用，并分析其计数过程。 版权声明 本文可以在互联网上自由转载，但必须：注明出处(作者：海洋饼干叔叔)并包含指向本页面的链接。 本文不可以以纸质出版为目的进行改编、摘抄。 1. range(x)、range(x,y)1234567print(\"output of range(5):\")for i in range(5): print(i)print(\"output of range(2,5):\")for x in range(2,5): print(x) 执行结果： 12345678910output of range(5):01234output of range(2,5):234 range(x,y) - range(x,y)函数从x开始计数，到y-1停止，不含y，产生一个整数集合； - 可以看到，range(2,5)产生了数值列表[2,3,4]（4即5-1)； - range(x)是range(0,x)的简写形式，range(5)等效于range(0,5)。 range(x,y)在解释器内部并不是一个严格意义上的列表，而是一个称为range的不常用的数据类型。如下述代码所示： 12345#rangelist2.pyx = range(5)print(x[2])print(x)print(type(x)) 执行结果： 1232range(0, 5)&lt;class &#39;range&#39;&gt; 如果真的需要把range转换成列表，可以通过类型转换实现： 1234#range2list.pyx = range(5)x = list(x)print(type(x),x) 执行结果： 1&lt;class &#39;list&#39;&gt; [0, 1, 2, 3, 4] 2. range(x,y,z)更复杂的range形式： 123#fours.pyfours = list(range(0,17,4))print(fours) 执行结果： 1[0, 4, 8, 12, 16] range(x,y,z) - 可以看出，range(0,17,4)从0开始计数，每计数1次，计数值加4，直到计数值&gt;=17为止。但需要注意，仅那些小于17的计数值会被输出； - range(x,y)等价于range(x,y,1); - range(x)等价于range(0,x,1)。 3 理解range计数过程读者或许对range(x,y,z)的输出结果感到疑惑，看看下面这个流程图。 现以range(0,17,4)为例，依上述流程图说明输出集合为什么是[0,4,8,12,16]。首先，计数取值x=0，然后开始循环： 1234567891011- 0 &lt; 17,输出0；- 计数 &#x3D; 0 + 4 &#x3D; 4；- 4 &lt; 17,输出4; - 计数 &#x3D; 4 + 4 &#x3D; 8; - 8 &lt; 17, 输出8;- 计数 &#x3D; 8 + 4 &#x3D; 12; - 12 &lt; 17, 输出12; - 计数 &#x3D; 12 + 4 &#x3D; 16;- 16 &lt; 17, 输出16;- 16 + 4 &#x3D; 20; - 20 &lt; 17不满足，循环结束。 如果你有C/C++经验，下述代码更容易描述range(x,y,z)的计数过程，事实上，Python的解释器就是用C/C++编写的。 123for (int i=x;i&lt;y;i+=z)&#123; output(i);&#125; 上述range(x,y,z)，如果z&lt;0，相应流程图如下： 作者试了试如下代码： 12numbers = list(range(9,2,-2))print(numbers) 执行结果: 1[9, 7, 5, 3] 该你了，请依上述流程图，人肉执行range(9,2,-2)的计数过程，验证上述输出。 如果你有C/C++经验，下面的代码能更容易地解释z小于0时range(9,2,-2)的计数过程： 123for (int i=x;i&gt;y;i+=z)&#123; output(i);&#125; 本文内容节选自作者编著的《Python编程基础及应用》（高等教育出版社）一书。 免费随书B站MOOC:","categories":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/tags/Python/"}]},{"title":"Python下的异常处理及错误日志记录","slug":"exception","date":"2019-07-18T03:36:04.000Z","updated":"2020-09-11T06:19:42.964Z","comments":true,"path":"2019/07/exception/","link":"","permalink":"http://codelearn.club/2019/07/exception/","excerpt":"Python使用被称为异常的特殊对象来表达执行期间发现的错误。当这些异常没有被捕获并处理时，程序将停止，并向控制台打印错误信息。这个错误信息通常是一个traceback，包含了异常的类型，以及诱发这个异常的代码位置及调用栈细节。","text":"Python使用被称为异常的特殊对象来表达执行期间发现的错误。当这些异常没有被捕获并处理时，程序将停止，并向控制台打印错误信息。这个错误信息通常是一个traceback，包含了异常的类型，以及诱发这个异常的代码位置及调用栈细节。 版权声明 本文可以在互联网上自由转载，但必须：注明出处(作者：海洋饼干叔叔)并包含指向本页面的链接。 本文不可以以纸质出版为目的进行改编、摘抄。 1. 曾经的异常在本书的前半部分，我们已经遇到过很多异常： 异常类 说明 ValueError 值与期望的不符 IndentationError 代码缩进错误 IndexError 序列索引不存在 AssertionError 断言失败 NameError 名字不存在 KeyError 映射（比如字典）中的键不存在 AttributeError 属性错误（对象无指定名字的属性) TypeError 类型出错 SyntaxError 代码语法错误 OSError 操作系统未能执行指定任务 ZeroDivisionError 除0错误 这些异常类，都继承自Exception类型。在本书的前半部分，我们对于这些异常采取了放任的态度: 程序直接报错停止。但一个严谨的程序，应该捕获并处理这些异常。 异常发生后 - 捕获并处理异常，尝试将程序从异常中拯救出来，继续正常运行。 - 捕获并处理异常，至少做一些必要的紧急操作，避免严重后果的发生。比如，汽车的车载控制系统发现发动机的“异常高温”（可能意味着起火）异常，应尝试切断油路，迫使汽车减速停车；一个股票交易系统发现无法恢复的异常，应尝试关闭数据库连接，并将没有保存的文件全部存盘。 - 捕获并处理异常，最低限度，作者认为应该将异常信息保存在错误日志中，以便程序员查找错误发生的原因。 2. try except else finally下述代码展示了一个完整的异常处理程序： 1234567891011121314151617181920212223242526#try.pydef divide(a, b): return a/bwhile True: sFirst = input(\"First number:\") sSecond = input(\"Second number:\") if sFirst == \"q\" or sSecond == \"q\": break try: iFirst = int(sFirst) iSecond = int(sSecond) fResult = divide(iFirst,iSecond) except (ZeroDivisionError) as e: print(\"You can not divide by 0:\",e) except (ValueError,TypeError) as e: print(\"Illegal value been inputted:\",e) print(type(e)) except (Exception) as e: print(\"An exception found, I do not know how to process it.\") raise else: print( sFirst, \"/\", sSecond, \"=\", fResult) finally: print(\"'Finally' will be executed what ever happens.\") 上述程序试图让用户输入两个整数，然后相除并将相除的结果打印出来。当除数为0或者操作者输入的字符串不是一个整数时，均会发生异常。上述try … except … else … finally语句将会捕获并恰当地处理这些异常。这个try…finally语句的工作过程可以概述如下： 首先，解释器将会执行try子句内的代码。在上例中，作者故意把try子句写得比较复杂，还加入了一个本不必要的函数，目的是想告诉读者：try子句内的代码以及间接被try子句内代码调用执行的代码，都受try子句的管辖。 如果try子句的执行没有发生异常，在try子句执行完毕后将执行else子句，然后再执行finally语句。下述输入及其执行结果证明了这一点。作者输入了15和3，字符串到整数的转换没有任何问题，else子句打印了除法运算的结果，finally子句接下来“强行”补充：”不管发生什么，我都来刷存在感”。 1234First number:15Second number:315 &#x2F; 3 &#x3D; 5.0&#39;Finally&#39; will be executed what ever happens. 如果try子句的执行发生了异常，则Python解释器会放弃try子句内后续代码的执行，并根据异常的类型创建一个异常对象。然后，解释器将从前往后逐一检查except子句括号里所包括的异常类型，当实际发生的异常属于该except子句括号内的异常类型时，该except子句将会被执行。最后，finally子句也会被执行。 下例中，我们输入了15和0x38。由于0x38不是一个十进制整数，所以iSecond = int(sSecond)这行代码诱发了一个 ValueError异常。解释器放弃了后续try子句的执行，并执行了第二个except子句以及finally子句。 12345First number:15Second number:0x38Illegal value been inputted: invalid literal for int() with base 10: &#39;0x38&#39;&lt;class &#39;ValueError&#39;&gt;&#39;Finally&#39; will be executed what ever happens. 下例中，我们输入了15和0。此时，divide函数内的a/b产生了ZeroDivisionError异常。解释器放弃了try子句后续代码的执行，并执行了第一个except子句以及finally子句。 当异常发生后，如果异常类型既不属于第一条except语句指定的类型，也不属于第二条except语句指定的类型，此时，第三条except语句多半可以捕获并处理异常。因为，绝大多数异常都是Exception类的子类型。注意，作者说的是绝大多数，也有一些异常，比如SystemExit，KeyboardInterrupt，不是Exception的子类。如果希望捕获并处理这些异常，可以直接使用下述型式的except子句: 12except: print(\"I found an exception that is not sub-class of Exception.\") 如果捕获的异常在当前情境下处理不了，也可以接着向外抛：上述代码中第三条except子句中的raise即为该用途。如果直接raise，抛出的是原有异常。当然，也可以欺骗或者加工一下异常：raise ValueError(“值错了!”) 。 连续输入两个”q”， 上述程序将会正常结束。 所谓的向外抛出异常，有必要解释一下。程序中的try…except…else…finally语句很可能处于另外一个try…finally语句的try子句中。所谓，抛出，就是本try…finally语句不处理该异常，扔给外面那个try…finally来处理。参见下述伪代码，我们看到，dummy函数内的try…except间接处于外部的try…except的try子句管辖内。 123456789101112def dummy(): try: doing something here except: raisetry: doing something before dummy() doing something moreexcept: print(\"Exception catched...\") try…finally语句总结 - 当try子句的执行没有发生异常时，else子句将被执行。 - 当try子句的执行发生异常时，解释器会放弃执行try子句后续代码，并根据异常的类型选择执行except子句，顺序为从上到下。 - except子句捕获异常后，可以尝试将程序从异常中恢复，或者做一些最低限度的后处理，以避免“灾难”性结果。如果处理不了，也可以通过raise语句将异常外抛。 - 不管有没有异常发生，finally子句总会在最后阶段被执行。这使得finally子句特别适合于处理一些善后工作，比如关闭因为异常未及关闭的文件，断开网络连接，关闭数据库连接等。 - 语法上，else子句以及finally子句是可选的，而except子句可以有无限多条。 - Python允许程序员定义自己的异常类型，比如车载电脑的控制程序可能需要一个“发动机转速过高”的异常。这很简单：定义一个Exception的子类就好了。 3. 警告如果有些情况的发生还不是那么严重，可以尝试发出警告。 1234567891011#warn.pyfrom warnings import warndef divide(a,b): fResult = a / b if fResult &lt; 0.0000001: warn(\"The result is very close to Zero!\") return fResultprint(divide(0.1, 10000000000))print(\"Something else.\") 执行结果： 1234d:\\pylearn\\C12_UnitTestException\\warn.py:6: UserWarning: The result is very close to Zero! warn(&quot;The result is very close to Zero!&quot;)1.0000000000000001e-11Something else. 从执行结果可以看出，warn()函数发出了警告，该警告会被打印至屏幕，但程序的执行不会因为该警告而停止：print(“Something else.”)在警告之后继续执行了。 如果你使用别人的模块，还可以通过filterwarnings()函数来过滤该模块产生的警告信息。你可以选择忽略-“ignore”，也可以上纲上线地把该模块的警告转化成异常-“error”。具体请查询Python文档。 4. 出错日志异常发生后，如果异常是预料中的类型，程序员直接处理这些异常并挽救程序即可。而程序发生非意料的异常几乎是历史的必然：程序员是人不是神！ 没有bug的应用程序不存在。这些意料之外的异常发生后，把相关情况记入出错日志（通常是一个文本文件），对于解决问题，十分重要。下述代码中的UserExceptHook函数来自于作者编写的一个实际的应用软件。 123456789101112131415161718192021222324252627282930#excepthook.pyimport sys,tracebackfrom datetime import datetimefError = open(\"except_error.log\", 'a')def UserExceptHook(tp, val, tb): traceList = traceback.format_tb(tb) html = repr(tp) + \"\\n\" html += (repr(val) + \"\\n\") for line in traceList: html += (line + \"\\n\") print(html, file=sys.stderr) print(datetime.now(), file=fError) print(html, file=fError) fError.close()def main(): sFirst = input(\"First number:\") sSecond = input(\"Second number:\") try: fResult = int(sFirst) / int(sSecond) except Exception: print(\"发现异常，但我不处理，抛出去.\") raise else: print( sFirst, \"/\", sSecond, \"=\", fResult)sys.excepthook = UserExceptHookmain()fError.close() sys模块下的excepthook是一个勾子-hook函数。当有程序没有捕获的异常，或者捕获后又抛出来的异常时，解释器就会执行这个勾子函数，然后停止运行。 上述代码自行定义了一个勾子函数，并将其赋值给sys.excepthook。这个函数有三个参数：tp-异常类型、val-异常值、tb-异常跟踪栈。异常跟踪栈可以通过traceback模块的format_tb()函数转换成一个字符串列表，这些字符串表明了异常发生时的程序调用关系。 可以看到，UserExceptHook()函数把异常转换成一个多行字符串，其中，repr()函数将一个对象转换成一个可以打印的表示字符串。然后这个多行字符串被打印至sys.stderr标准错误输出，然后再被打印至fError文件。请注意，fError文件在程序开始执行时即被以”a”-附加模式打开，附加模式保证了后续发生的错误信息不会覆盖原有文件内容。此外，在UserExceptHook()函数的最后一行，fError文件被关闭。因为，该勾子函数执行完成后，程序将会终止，这里是唯一关闭文件确保文件内容被正确写入外存的最后机会。 datetime.now()返回当前系统日期和时间。 作者多次运行上述程序，故意输入一些不恰当的值来诱发异常，最后得到下述错误日志-except_error.log： 1234567891011121314151617182018-11-03 18:05:58.305337&lt;class &#39;ZeroDivisionError&#39;&gt;ZeroDivisionError(&#39;division by zero&#39;) File &quot;D:&#x2F;pylearn&#x2F;C12_UnitTestException&#x2F;excepthook.py&quot;, line 28, in &lt;module&gt; main() File &quot;D:&#x2F;pylearn&#x2F;C12_UnitTestException&#x2F;excepthook.py&quot;, line 20, in main fResult &#x3D; int(sFirst) &#x2F; int(sSecond)2018-11-03 18:06:04.097457&lt;class &#39;ValueError&#39;&gt;ValueError(&quot;invalid literal for int() with base 10: &#39;3.2&#39;&quot;) File &quot;D:&#x2F;pylearn&#x2F;C12_UnitTestException&#x2F;excepthook.py&quot;, line 28, in &lt;module&gt; main() File &quot;D:&#x2F;pylearn&#x2F;C12_UnitTestException&#x2F;excepthook.py&quot;, line 20, in main fResult &#x3D; int(sFirst) &#x2F; int(sSecond) 终于，当使用你编写的软件的客户通过电话向你抱怨程序有时会运行出错时，你可以要求客户把错误日志文件发送给你。通过错误日志，你可以了解软件出错的相关细节，而不必通过客户那些“不准确”甚至“夸大其词”的描述去推断错误发生的原因。 本文内容节选自作者编著的《Python编程基础及应用》（高等教育出版社）一书。 免费随书B站MOOC:","categories":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/tags/Python/"}]},{"title":"numpy,matplotlib - Python绘制二元函数曲面","slug":"func3d","date":"2019-07-18T03:36:04.000Z","updated":"2020-09-11T06:20:11.611Z","comments":true,"path":"2019/07/func3d/","link":"","permalink":"http://codelearn.club/2019/07/func3d/","excerpt":"我们将演示如何借助于ufunc的广播运算计算下述二元函数的在一个xy平面上的值并将其绘制成3D曲面。其中，x和y的取值范围均为[-2,+2]。$$z = xe^{-x^{2}-y^{2}}$$","text":"我们将演示如何借助于ufunc的广播运算计算下述二元函数的在一个xy平面上的值并将其绘制成3D曲面。其中，x和y的取值范围均为[-2,+2]。$$z = xe^{-x^{2}-y^{2}}$$ 为了达到目的，我们需要一个二维的结果数组z，其元素的下标对应参数x,y的取值，其元素的值则为上述函数的函数值。这可以通过广播计算来得到。 版权声明 本文可以在互联网上自由转载，但必须：注明出处(作者：海洋饼干叔叔)并包含指向本页面的链接。 本文不可以以纸质出版为目的进行改编、摘抄。 np.ogrid是个特殊对象，通过切片下标来生成用于广播运算的数组。先看下述程序： 123456#ogrid.pyx,y = np.ogrid[0:3:4j,0:4:5j]print(\"x=\\n\",x)print(\"y=\\n\",y)print(\"x.shape=\",x.shape)print(\"y.shape=\",y.shape) 执行结果： 123456789x&#x3D; [[0.] [1.] [2.] [3.]]y&#x3D; [[0. 1. 2. 3. 4.]]x.shape&#x3D; (4, 1)y.shape&#x3D; (1, 5) 0:3:4j这种切片语法类似于np.linspace(0,3,4)，它表示生成从0到3的包含4个元素的等差数列。这里的j并不表示复数的虚部，它只是一种语法格式。由于广播的需要，x的形状被设置为(4,1)。同理，由于广播需要，y的形状被设置成了(1,5)。这样，通过ogrid生成的x和y数组符合广播运算的规则，可以进行广播运算。 下述代码将x = [-2,+2]，y = [-2, +2]的函数值矩阵以平面图形式绘制。 123456789101112#func2d.pyimport numpy as npfrom matplotlib import pyplot as pltfrom matplotlib import cmy,x = np.ogrid[-2:2:200j,-2:2:200j]z = x * np.exp(-x**2-y**2)extent = [np.min(x),np.max(x),np.min(y),np.max(y)]plt.imshow(z,extent=extent,cmap=cm.gray)plt.colorbar()plt.show() 根据ogrid的输出，y,x分别是形状为(200,1)和(1,200)的数组。z = x * np.exp(-x**2-y**2)的执行过程中将发生广播，结果数组z将会是一个形状为(200,200)的二维数组，元素值为对应x,y的函数值。如果将z视为一个图像，那么其横向x取值范围对应[-2,+2]，纵向y取值范围取应[-2,+2]。 extent = [np.min(x),np.max(x),np.min(y),np.max(y)]将x及y的取值范围放入一个列表。plt.imshow()函数将二维数组z作为图像显示，extent参数指明了横纵坐标的范围，cmap则指定了颜色映射对象，该颜色映射对象负责把z中的元素值转换成像素点的颜色。plt.colorbar()则“聪明”通过颜色条显示z中的函数值与颜色之间的对应关系。plt.show()真正地把图表显示出来。执行结果如下： 下述代码将x = [-2,+2]，y = [-2, +2]的函数值矩阵以3D图形式绘制。 12345678910111213#func3d.pyimport numpy as npimport mpl_toolkits.mplot3dfrom matplotlib import pyplot as pltfrom matplotlib import cmx,y = np.mgrid[-2:2:20j,-2:2:20j]z = x * np.exp(- x**2 - y**2)fig = plt.figure(figsize=(8,6))ax = fig.gca(projection='3d')ax.plot_surface(x,y,z,cmap=cm.ocean)plt.show() ax是表示一个子图，由于ax.plot_surface()函数要求x,y,z三个数组都必须是相同形状的二维数组，所以上述代码中没有使用ogrid来生成广播数组，而是使用了mgrid。mgrid的功能与ogrid相近，区别在于其返回的是已经进行了形状扩充的数组。也就是说，上述通过mgrid生成出来的x,y数组的形状已经是(20,20)。读者可以自行打印x,y的值出来观察mgrid对象的用法。读者如果对matplotlib相关代码感到疑惑，请先略过，本书后续部分将解读matplotlib包的使用。上述程序执行结果如下： 本文内容节选自作者编著的《Python编程基础及应用》（高等教育出版社）一书。 免费随书B站MOOC:","categories":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/categories/Python/"},{"name":"数学之美","slug":"Python/数学之美","permalink":"http://codelearn.club/categories/Python/%E6%95%B0%E5%AD%A6%E4%B9%8B%E7%BE%8E/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/tags/Python/"}]},{"title":"Python实现 - 斐波那契数列与函数的增长","slug":"fib","date":"2019-07-18T03:35:04.000Z","updated":"2020-09-11T06:19:59.238Z","comments":true,"path":"2019/07/fib/","link":"","permalink":"http://codelearn.club/2019/07/fib/","excerpt":"数学家列昂纳多·斐波那契研究了野外兔子的繁殖问题：一般而言，兔子出生两个月后，就有繁殖能力。假设一对兔子每个月能生出一对小兔子而且所有兔子都不死。如果现在往一片没有兔子的新大陆上放生一对新生的兔子，那么一年以后那个大陆上有多少只兔子？两年以后呢？","text":"数学家列昂纳多·斐波那契研究了野外兔子的繁殖问题：一般而言，兔子出生两个月后，就有繁殖能力。假设一对兔子每个月能生出一对小兔子而且所有兔子都不死。如果现在往一片没有兔子的新大陆上放生一对新生的兔子，那么一年以后那个大陆上有多少只兔子？两年以后呢？ 版权声明 本文可以在互联网上自由转载，但必须：注明出处(作者：海洋饼干叔叔)并包含指向本页面的链接。 本文不可以以纸质出版为目的进行改编、摘抄。 第1个月，那对兔子还没有繁殖能力，仍为幼兔。故幼免数量为1对，成兔数量为0对，总对数为1； 第2个月，那对兔子性成熟，变成成兔。故幼兔数量为0对，成兔数量为1对，总对数为1； 第3个月，2月时的成兔1对，生了1对小兔子，故幼兔1对，成兔1对，总对数为2； 第4个月，3月时的成兔1对生了1对小兔子，且3月时的幼兔1对变成了成兔，故幼兔数量为1对，成兔变成了2对，总对数为3… 经过月数 1 2 3 4 5 6 7 8 9 10 11 12 幼仔对数 1 0 1 1 2 3 5 8 13 21 34 55 成兔对数 0 1 1 2 3 5 8 13 21 34 55 89 总对数 1 1 2 3 5 8 13 21 34 55 89 144 简单归纳，容易导出下述结论： 幼免对数 = 前月成兔对数 （每对成兔每月生一对小兔子） 成兔对数 = 前月成兔对数 （成兔不死） + 前月幼兔对数（前月的幼兔长大变成成兔） 总对数 = 幼兔对数 + 成兔对数 观察上述表格，可以发现，上述三行数据，在1,1后的每一个数字，都正好等于前两个数字之和。2 = 1 + 1, 3 = 1+2, 5 = 2 + 3… 89 = 34 + 55… 斐波那契对上述规律进行总结和形式化，得到关于n个月后兔子数量的通项公式如下，这是一个分段函数。 读者希望知道10年，也就是120个月之后的兔子数量吗？ 我们来计算一下。 123456789101112[fib1.py]def fibonacci(n): if n &lt;= 2: return 1 a,b = 1,1 #最近两项的值，a为前前项，b为前项 for x in range(3,n+1): v = a + b #新值 = 前两项之和 a,b = b,v #a = b, b = v return vfor n in range(1,121): #121确保数值列表包括120 print(\"month:\",n,\"rabbits:\",fibonacci(n)) 执行结果： 123456789101112131415month: 1 rabbits: 1month: 2 rabbits: 1month: 3 rabbits: 2...month: 8 rabbits: 21...month: 23 rabbits: 28657...month: 38 rabbits: 39088169...month: 54 rabbits: 86267571272...month: 75 rabbits: 2111485077978050...month: 120 rabbits: 5358359254990966640871840 函数fibonacci(n)计算并返回第n个月后的免子对数。计算结果几乎是反直觉的。如果这块新大陆无限大，食物无限丰富，而且没有灰太狼，那么120个月以后，兔子的总对数为：5358359254990966640871840。恭喜成都的朋友们，他们拥有了”永远”也啃不完的麻辣兔头。 上述fibonacci函数值随参数的增长速度极其惊人。在计算复杂性问题上，研究函数的值随参数的增长速度，是有一件有趣的事情。接下来，我们比较一下下述函数以及斐波那契函数随参数的增长速度：$$y = n^2\\y = n^3$$ 123456789101112131415161718192021222324252627#grow.pydef fibonacci(n): if n &lt;= 2: return 1 a,b = 1,1 #最近两项的值，a为前前项，b为前项 for x in range(3,n+1): v = a + b #新值 = 前两项之和 a,b = b,v #a = b, b = v return vx = list(range(1,11)) #1..10的数值列表n2,n3,fn = [],[],[] #依次为n的平方，n的立方，n值斐波那契for v in x: #依次计算机各函数值 n2.append(v*v) n3.append(v*v*v) fn.append(fibonacci(v))print(\"n^2=\",n2)print(\"n^3=\",n3)print(\"fib(n)=\",fn)from matplotlib import pyplot as plt #绘图部分plt.plot(x,n2,color='black',label=\"$y=n^2$\")plt.plot(x,n3,linestyle=\"-.\",color='black',label=\"$y=n^3$\")plt.plot(x,fn,linestyle=\"--\",color='black',label=\"$y=fibonacci(n)$\")plt.legend()plt.show() 执行结果： 123n^2&#x3D; [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]n^3&#x3D; [1, 8, 27, 64, 125, 216, 343, 512, 729, 1000]fib(n)&#x3D; [1, 1, 2, 3, 5, 8, 13, 21, 34, 55] 上述代码首先生成了一个x列表，其值为[1,2,3,4,5,6,7,8,9,10]；然后对x列表每一个值，逐一计算其平方，立方及斐波那契函数的值。最后使用matplotlib将四个函数绘制出来。matplotlib是一个绘图用的扩展模块，需要通过在命令行中执行pip install matplotlib进行安装。 下图展示了参数取值1-10时，3个函数的增长曲线图： 看起来，n3增长较快，n2和fibonacci(n)增长较慢。这不是事实！ 我们把参数取值范围扩大到1-30，重新绘图，结果如下： 可以看到，斐波那契函数的增长曲线昂首挺胸，而n2以及n3在该尺度下，几乎趴在了地上。读者可以自行试验一下x取值1-100的情况。 相对于斐波那契函数，n3的增长速度实在是太慢了。从数学上讲，斐波那契函数与n3都是n趋近于无穷大时的无穷大，但显而易见，斐波那契函数拥有更高的阶。 本文内容节选自作者编著的《Python编程基础及应用》（高等教育出版社）一书。 免费随书B站MOOC:","categories":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/tags/Python/"}]},{"title":"见微智著 - 从一个小例子看Python中的单元测试","slug":"pyut","date":"2019-07-18T03:24:04.000Z","updated":"2020-09-11T06:27:12.575Z","comments":true,"path":"2019/07/pyut/","link":"","permalink":"http://codelearn.club/2019/07/pyut/","excerpt":"单元测试 据统计，由于软件缺陷（bug），美国经济每年在浪费生产力、返工和实际毁坏上损失了数十亿美元。近期最严重的案例是波音737 Max飞机的两次重大坠机事故，共造成了346人死亡。经过初步调查，该公司的专用软件难辞其咎。因此，通过软件工程方法以及测试减少软件的缺陷，十分重要。","text":"单元测试 据统计，由于软件缺陷（bug），美国经济每年在浪费生产力、返工和实际毁坏上损失了数十亿美元。近期最严重的案例是波音737 Max飞机的两次重大坠机事故，共造成了346人死亡。经过初步调查，该公司的专用软件难辞其咎。因此，通过软件工程方法以及测试减少软件的缺陷，十分重要。 版权声明 本文可以在互联网上自由转载，但必须：注明出处(作者：海洋饼干叔叔)并包含指向本页面的链接。 本文不可以以纸质出版为目的进行改编、摘抄。 代码错误或者软件bug和程序员如影随形。作为程序员，我们经常在担心：“我编写的代码是否正确？我编写的代码有没有bug？”。测试驱动开发提供的测试集可以减轻你的担心。 1. 测试驱动开发测试驱动开发，英文全称Test-Driven Development，简称TDD，是一种不同于传统软件开发流程的新型的开发方法。它的基本思路就是通过测试来推动整个开发的进行。在明确要开发某个功能后，不是直接实现功能部分，而是先思考如何对这个功能进行测试，先完成测试代码的编写，然后再编写相关的功能代码满足这些测试用例。 测试驱动开发的基本过程如下：a. 先明确要实现的功能并进行分析；b. 为该功能的测试设计用例并编写测试代码，并在测试用例设计过程中检视该功能的接口；c. 编写代码实现功能；d. 使用测试用例进行测试；e. 如果测试没有通过，对代码进行重构，直至测试通过为止；f. 使用相同流程循环完成软件其它功能的开发。 读者也可能听说过一种叫做“极限编程”的轻量级软件工程思想。在“极限编程”里，一个重要的规则就是：先写测试，这跟TDD异曲同工。测试驱动开发的一个重要实施手段就是单元测试。 2. 单元测试单元测试是保证软件模块质量的重要手段之一，通过单元测试来管理设计好的测试用例，不仅可以避免测试过程中的人工输入引起的错误，还可以重复利用设计好的测试用例。Python标准库unittest提供了很多用于单元测试的类和方法，其中最常用的是TestCase类，其常用方法如表所示。 名称 功能 名称 功能 assertEqual(a, b) a == b assertIsNone(x) x is None assertNotEqual(a, b) a != b assertIsNotNone(x) x is not None assertTrue(x) bool(x) is True assertIn(a, b) a in b assertFalse(x) bool(x) is False assertNotIn(a, b) a not in b assertIs(a, b) a is b assertIsInstance(a, b) isinstance(a, b) assertIsNot(a, b) a is not b assertNotIsInstance(a, b) not isinstance(a, b) assertAlmostEqual(a, b) round(a-b, 7) == 0 assertNotAlmostEqual(a, b) round(a-b, 7) != 0 assertGreater(a, b) a &gt; b assertGreaterEqual(a, b) a &gt;= b assertLess(a, b) a &lt; b assertLessEqual(a, b) a &lt;= b assertRegex(s, r) r.search(s) assertNotRegex(s, r) not r.search(s) 基于测试驱动开发的思想，我们编写一个类来测试判断素数的函数。首先，我们定义了该素数判断函数的接口：函数名为isPrime，接受一个整数参数num, 如果num是素数，该函数返回True, 否则返回False。该函数的接口可以使用伪代码表示如下。 1bool isPrime(int num) 根据TDD， 先写测试，测试类如下： 1234567891011121314#testisprime.pyfrom prime import isPrimeimport unittestclass IsPrimeTestCase(unittest.TestCase): def testIsPrime(self): self.assertEqual(isPrime(2),True,'素数判断错误') self.assertEqual(isPrime(7),True,'素数判断错误') self.assertEqual(isPrime(12),False,'12不是素数，判断错误') self.assertEqual(isPrime(0),False,'0不是素数，判断错误') self.assertEqual(isPrime(1),False,'1不是素数，判断错误') self.assertEqual(isPrime(-7),False,'负数不是素数')if __name__ == '__main__': unittest.main() 我们看到，测试类中把2,7,12以及比较特殊的0,1等作为参数，交给isPrime(num)函数进行判断，并把返回值与预期的值进行比较。如果返回值与预期值不一致，则会导致断言失败，这个失败的断言还会附带一个说明字符串帮助测试者确定测试未通过的原因。 接下来，根据需求以及在测试用例设计过程中检视过的功能接口实现isPrime()函数，版本为0.1： 123456#prime.py v0.1def isPrime(num): for i in range(2,num): if num % i == 0: return False return True 接下来，运行testisprime.py进行测试，得到如下错误结果： 123456789101112&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;FAIL: testIsPrime (__main__.IsPrimeTestCase)----------------------------------------------------------------------Traceback (most recent call last): File &quot;d:\\pylearn\\C12_UnitTestException\\testisprime.py&quot;, line 9, in testIsPrime self.assertEqual(isPrime(0),False,&#39;0不是素数，判断错误&#39;)AssertionError: True !&#x3D; False : 0不是素数，判断错误----------------------------------------------------------------------Ran 1 test in 0.001sFAILED (failures&#x3D;1) 该错误结果表明，测试没有通过，这说明0.1版本的功能代码存在缺陷。仔细查看，发现对值0的素数判断结果真，而期望值应为假。重新检视isPrime(num)函数的设计，发现该函数遗漏了对值0和1的处理，进行修改，得到prime.py的0.2版本: 12345678#prime.py v0.2def isPrime(num): if num in (0,1): return False for i in range(2,num): if num % i == 0: return False return True 再次运行testisprime.py进行测试，结果如下： 123456789101112&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;FAIL: testIsPrime (__main__.IsPrimeTestCase)----------------------------------------------------------------------Traceback (most recent call last): File &quot;d:\\pylearn\\C12_UnitTestException\\testisprime.py&quot;, line 11, in testIsPrime self.assertEqual(isPrime(-7),False,&#39;负数不是素数&#39;)AssertionError: True !&#x3D; False : 负数不是素数----------------------------------------------------------------------Ran 1 test in 0.001sFAILED (failures&#x3D;1) 又没有通过测试，这次是因为num为负数的情况没有得到处理。审视并修改prime.py，得到0.3版本： 12345678#prime.py v0.3def isPrime(num): if num &lt; 0 or num in (0,1): return False for i in range(2,num): if num % i == 0: return False return True 再次运行测试，结果如下： 1234----------------------------------------------------------------------Ran 1 test in 0.000sOK 这次通过了，如果我们的测试用例设计得充分而又合理，可以认为isPrime(num)函数“合格”了。prime.py的版本号可以从0.3直升至1.0了。 上面这个极其微小的例子是希望浅显地向读者介绍单元测试的基本过程，真实的情况要复杂得多。几乎很少有程序员可以一次性地写出没有缺陷或者极少缺陷的代码，程序总是在不断修正，重构中提升其质量。除了写代码外，如何设计合理有效的测试用例，也是一项专门的学问，它属于软件工程的范畴。读者大致可以看到，对于isPrime(num)这样一个简单的函数，测试用例测试了边界值(0,1)，正数，负数等各种情况，试图覆盖isPrime(num)函数全部可能的执行路径。 本文内容节选自作者编著的《Python编程基础及应用》（高等教育出版社）一书。 免费随书B站MOOC:","categories":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/tags/Python/"},{"name":"单元测试","slug":"单元测试","permalink":"http://codelearn.club/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"}]},{"title":"SciPy - ECG信号的谱分析及数字滤波","slug":"ecgfilter","date":"2019-07-18T02:58:04.000Z","updated":"2020-09-11T06:19:29.112Z","comments":true,"path":"2019/07/ecgfilter/","link":"","permalink":"http://codelearn.club/2019/07/ecgfilter/","excerpt":"本节的阅读需要傅里叶级数及傅里叶变换的相关数学知识。","text":"本节的阅读需要傅里叶级数及傅里叶变换的相关数学知识。 示范代码目录下有一个ecgsignal.dat文件，这里存储了作者采集的一段人体心电信号-ECG。这个文件以4字节浮点数存储样本，单位为μV，采样总数 = 文件大小 / 4，采样频率 = 2000样本/秒。需要说明的是，这个心电信号不是标准的医用心电信号，作者在一台其它用途的医用电生理设备上，用左手拿着正电极，右手拿着负电极，简单记录了上述信号。而且，作者故意没有涂用于皮肤电极的导电膏，以便引入“工频干扰”。 版权声明 本文可以在互联网上自由转载，但必须：注明出处(作者：海洋饼干叔叔)并包含指向本页面的链接。 本文不可以以纸质出版为目的进行改编、摘抄。 1. 分析信号的频谱 - spectrum心电信号可以视为定义在时间t上的函数，把这个函数进行傅里叶级数展开，可以将其表达成不同频率/周期的正弦函数的和。而这些正弦项的系数，则表明了该种频率的正弦项在信号构成中的重要程度。所谓的频谱分析，就是把时间t上的函数，转换成频率f上的函数，即把信号从时域转换到频域。这种转换，可以通过傅里叶变换实现。在离散的计算机世界里，对应的算法工具称为快速傅里叶变换 - Fast Fourier Transform，简称FFT。 1234567891011121314151617181920212223#Spectrum.pyimport numpy as npfrom matplotlib import pyplot as pltiSampleRate = 2000 #采样频率,每秒2000个样本x = np.fromfile(\"ecgsignal.dat\",dtype=np.float32)iSampleCount = x.shape[0] #采样数t = np.linspace(0,iSampleCount/iSampleRate,iSampleCount)xFFT = np.abs(np.fft.rfft(x)/iSampleCount) #快速傅里叶变换xFreqs = np.linspace(0, iSampleRate/2, int(iSampleCount/2)+1)plt.figure(figsize=(10,6))ax0 = plt.subplot(211) #画时域信号ax0.set_xlabel(\"Time(s)\")ax0.set_ylabel(\"Amp(μV)\")ax0.plot(t,x)ax1 = plt.subplot(212) #画频域信号-频谱ax1.set_xlabel(\"Freq(Hz)\")ax1.set_ylabel(\"Power\")ax1.plot(xFreqs, xFFT)plt.show() 执行结果： 先点下方工具栏中的放大镜，然后按住鼠标左键框选放大，可以帮助我们帮察信号及频谱的细节： np.fromfile(“ecgsignal.dat”,dtype=np.float32)从文件读取信号数据，numpy会以二进制格式打开文件，读取数据，并以4个字节为单位，逐一转换成np.float32类型，然后返回一个一维数组。该数组包含全部采样。 np.float32类型表示一个采样浮点数由32个bit，即4个字节构成。 np.linspace(0,iSampleCount/iSampleRate,iSampleCount)则生成了与信号x相同维度的一维数组t，其中的数据对应每个样本的采样时间。其中，iSampleCount为采样总数，iSampleRate为采样频率。如果采样总数=6000，则信号的总时间长度为6000/2000(采样频率)=3秒。后续代码中的ax0.plot(t,x)则以时间t为横轴，信号振幅x为纵轴，在ax0子图上画出时域信号。 np.fft模块支持快速傅里叶变换，其中的rfft()函数对实数信号进行FFT运算。根据计算公式，还需要将返回结果除以iSampleCount以便正确显示波形能量。 rfft()函数的返回值是iSampleCount/2+1个复数，分别表示从0(Hz)到iSampleRate/2(Hz)的频率能量。np.abs()对rfft()返回数组中的复数进行求模-abs。受限于香农采样定理，采样频率为2000Hz的信号，有效的信号频率最高为1000Hz。 xFreqs = np.linspace(0, iSampleRate/2, int(iSampleCount/2)+1)则负责生成与xFFT中的能量相对应的频率。此时,(xFreqs,xFFT)可视为定义在频率域xFreqs上的“信号”，即原时域信号(t,x)的频谱。后续代码中的ax1.plot(xFreqs, xFFT)则以频率为横轴，能量为纵轴，在ax1子图上画出频谱。 顺便再次指出，plt.subplot(211)将当前图按2行1列划分，在1号位置（即上方位置）创建一张子图ax0，同理，plt.subplot(212)则在2号位置（即下方位置）创建一张子图ax1。 在下方频谱图中，我们看到在50Hz处存在一个巨大的峰，这些能量对应着那些叠加在原始信号上的有规律的周期小波，这就是所谓的工频干扰。读者可以数一数下方上图中从3.0秒至3.2秒的周期小波的周期(峰到峰）个数，应该是10个，0.2秒10个周期对应1秒种50个周期。我国的市电是220V/50Hz交流电，交变的电流流过市电导线，向空间辐射能量，这些辐射能量借助于人体，电极线等与市电导线的耦合电容，进入了信号放大器，形成“干扰”。此外，我们在100Hz处也可以看到频谱能量的峰，100Hz正好是50Hz 的倍频，也是所谓工频干扰的一部分。可以想象，如果同样的干扰发生在美国，其频率应为60Hz，因为当地的市电是110V/60Hz交流电。这里，50Hz的工频干扰我们将使用带阻滤波器，也叫陷波器滤除。 在频谱图中，我们还看到在0Hz附近也有较多能量，这些低频成分对应原始信号里缓慢变化的基线。这些低频成分也不具备诊断意义，需要滤除。我们选择使用一个带通滤波器，滤除3Hz以下的低频信号，同时滤除70Hz以上的高频信号。 2. 滤波器设计滤波是个宏大的课题，这里我们只能描述一种简便的应用方法，不描述背后的数学原理。 我们需要两个滤波器，其中一个是3-70Hz的带通滤波器，它保留信号中3-70Hz的频率成分，去除低于3Hz的低频部分以及高于70Hz的高频部分。另外一个是48-52Hz的带阻滤波器，别名50Hz陷波器，它去除信号中48-52Hz的成分。 下图展现了我们设计的带通滤波器(左)及带阻滤波器(右)的频率响应。横轴为频率，纵轴为滤波器对该频率信号的增益-gain，当增益为1.0时，说明该频率信号无障碍通过滤波器，当增益小于1.0时，说明通过滤波器时，该频率信号被衰减。可以看到，当滤波器的阶-order越高，则滤波器性能越好(频响曲线陡峭)，但计算量也会增加。 相关滤波器设计代码如下: 12345678910111213141516171819202122232425262728293031323334353637#FilterResponse.pydef butterBandPassFilter(lowcut, highcut, samplerate, order): \"生成巴特沃斯带通滤波器\" semiSampleRate = samplerate*0.5 low = lowcut / semiSampleRate high = highcut / semiSampleRate b,a = signal.butter(order,[low,high],btype='bandpass') print(\"bandpass:\",\"b.shape:\",b.shape,\"a.shape:\",a.shape,\"order=\",order) print(\"b=\",b) print(\"a=\",a) return b,adef butterBandStopFilter(lowcut, highcut, samplerate, order): \"生成巴特沃斯带阻滤波器\" semiSampleRate = samplerate*0.5 low = lowcut / semiSampleRate high = highcut / semiSampleRate b,a = signal.butter(order,[low,high],btype='bandstop') print(\"bandstop:\",\"b.shape:\",b.shape,\"a.shape:\",a.shape,\"order=\",order) print(\"b=\",b) print(\"a=\",a) return b,aiSampleRate = 2000 #采样频率plt.figure(figsize=(12,5))ax0 = plt.subplot(121)for k in [2, 3, 4]: b, a = butterBandPassFilter(3,70,samplerate=iSampleRate,order=k) w, h = signal.freqz(b, a, worN=2000) ax0.plot((iSampleRate*0.5/np.pi)*w,np.abs(h),label=\"order = %d\" % k)ax1 = plt.subplot(122)for k in [2, 3, 4]: b, a = butterBandStopFilter(48, 52, samplerate=iSampleRate, order=k) w, h = signal.freqz(b, a, worN=2000) ax1.plot((iSampleRate*0.5/np.pi)*w,np.abs(h),label=\"order = %d\" % k) 控制台输出： 1234567bandpass: b.shape: (5,) a.shape: (5,) order&#x3D; 2b&#x3D; [ 0.00961483 0. -0.01922967 0. 0.00961483]a&#x3D; [ 1. -3.70024346 5.14358108 -3.18588885 0.74255496]bandpass: b.shape: (7,) a.shape: (7,) order&#x3D; 3...bandpass: b.shape: (9,) a.shape: (9,) order&#x3D; 4... 下述讨论中，f0等于采样频率的一半，即代码中的iSampleRate*0.5，或者samplerate*0.5。 从控制台输出可以看到，signal.butter()函数生成滤波器的结果为两个一维数组b和a。数组里存储一些实数，滤波器的阶-order越大，b,a包含的实数个数越多。b,a是IIR滤波器的系数。btype参数指明了滤波器的类型，bandpass意为带通，bandstop意为带阻。[low,high]则指明了滤波器的截止频率。上述代码说明，这里的low和high应等于截止频率/f0。当采样频率为2000时，f0=2000*0.5=1000，则3Hz的截止频率对应low = 3/1000 = 0.003，70Hz的截止频率对应high = 70 / 1000 = 0.07。 freqz()函数用于计算滤波器的频率响应，返回w,h两个数组。其中，w是圆频率数组，通过w*f0/π可以计算出与其对应的频率，h是w对应频率点的响应，它是一组复数，其幅值表示滤波器的增益特性，相角表示滤波器的相位特性。参数worN表明了要计算的频率的项数，该值越大，计算越精细。 上述代码中，我们生成了阶为2,3,4的3-70Hz带通滤波器共3个，阶为2,3,4的48-52Hz带阻滤波器共3个，然后分别生成并显示了其频率响应曲线，以供读者观察。上述代码中，np.abs()函数用于求复数数组的模。 上图中，我们还画了一条sqrt(0.5)的虚线，这里对应着所谓的-3dB增益。此处，对应频率的信号的功率缩减为最高功率的一半。 3. 滤波我们应用上述滤波器对信号进行了滤波，结果如下图（局部放大）： 可以看到，在3-70Hz带通滤波器的作用下，0Hz附近的极低频成分消失了，70Hz以后的高频成分也得到有效抑制。同时，我们注意到100Hz的干扰成分仍有残留。 在48-52Hz带阻滤波器的作用下，50Hz附近工频干扰几乎完全消失。上图中，我们看到了基线不飘移，50Hz工频周期波完全去除后的“干净”的ECG信号。这个信号来自于心脏，常在医用心电监护仪上看到。每个“尖波”对应着一次心跳，读者可以计算一下作者记录这段信号时的心率。 相关滤波的代码如下： 12345678910111213#Filter.pyiSampleRate = 2000 #采样频率,每秒2000个样本x = np.fromfile(\"ecgsignal.dat\",dtype=np.float32)#进行带通滤波b,a = butterBandPassFilter(3,70,iSampleRate,order=4)x = signal.lfilter(b,a,x)#进行带阻滤波b,a = butterBandStopFilter(48,52,iSampleRate,order=2)x = signal.lfilter(b,a,x)... #谱分析及画图部分代码略 滤波的代码十分简单。signal.lfilter()将滤波器返回的b,a数组应用于信号x上，滤波后返回一个新数组。读者一定有点好奇，lfilter()内部到底做了些什么。对于FIR-有限脉冲响应滤波器，a组系数不适用，对于输出信号数组y的任意点y[i]，其值为：$$y_i=b_0x_i+b_1x_{i-1}+…+b_px_{i-p}$$​ 这就是个简单的乘积和。对于IIR-无限脉冲响应滤波器，对于输出信号数组y的任意点y[i]，其值为：$$y_i=\\frac{b_0x_i+b_1x_{i-1}+…+b_px_{i-p}-a_1y_{i-1}-a_2y_{i-2}-…-a_qy_{i-q}}{a_0}$$​ 上述两个公式中，p+1为b数组的元素个数；q+1为a数组的元素个数。 巴特沃斯滤波器只是IIR滤波器的一种。 使用firwin()、remez()等函数可以设计FIR滤波器。iirdesign()函数则可以帮助设计IIR滤波器。要想彻底弄明白滤波器背后的数学原理，不是一件容易的事情。 本文内容节选自作者编著的《Python编程基础及应用》（高等教育出版社）一书。 免费随书B站MOOC:","categories":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/categories/Python/"},{"name":"科学计算","slug":"Python/科学计算","permalink":"http://codelearn.club/categories/Python/%E7%A7%91%E5%AD%A6%E8%AE%A1%E7%AE%97/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/tags/Python/"},{"name":"SciPy","slug":"SciPy","permalink":"http://codelearn.club/tags/SciPy/"}]},{"title":"数学之美 - Python视角下的Peter de Jong吸引子","slug":"pdj","date":"2019-07-16T23:35:04.000Z","updated":"2020-09-11T06:22:34.724Z","comments":true,"path":"2019/07/pdj/","link":"","permalink":"http://codelearn.club/2019/07/pdj/","excerpt":"据说蝴蝶扇动翅膀这样一件小事，可能最终会引起对面半球的一场飓风。 ​ — 混沌理论","text":"据说蝴蝶扇动翅膀这样一件小事，可能最终会引起对面半球的一场飓风。 ​ — 混沌理论 上面这行话来源于2004年的电影《蝴蝶效应》的开篇字幕。更早期，这段话则与气象学家Edward Lorenz有关。他发现简单的热对流现象居然能引起令人无法想象的气象变化，在对相关发现进行数学分析后，Lorenz于1963年提出了混沌理论 - Chaos Theory。混沌理论认为在混沌系统中，初始条件十分微小的变化，经过不断放大，对其未来状态会造成极其巨大的差别。 经过多年的发展，该理论已在气象、经济、化学、信息等诸领域得到广泛应用。但如果以混沌理论为关键词在Google上进行搜索，还会发现一些美轮美奂的艺术作品，这些艺术作品都与混沌理论中的吸引子有关。 版权声明 本文可以在互联网上自由转载，但必须：注明出处(作者：海洋饼干叔叔)并包含指向本页面的链接。 本文不可以以纸质出版为目的进行改编、摘抄。 1. Peter de Jong吸引子所谓吸引子 - Attractor，是动力系统里的一个状态，系统演化会趋向那个方向靠拢。Peter de Jong是一个奇异吸引子。奇异吸引子上的运动对初始值表现出极强的敏感依赖性，在初始值上的微不足道的差异，就会导致运动轨道的截然不同。奇异吸引子往往具有非整数维，如2.06维、1.2365维等。 Peter de Jong吸引子就是一个奇异吸引子，它可以由下述迭代方程描述：$$x_{n+1} = sin(ay_{n})-cos(bx_{n})\\y_{n+1} = sin(cx_{n})-cos(dy_{n})$$这个方程有4个参数，分别为a，b，c，d。随意指定x0和y0的值，比如(0,0)，通过上述公式，可计算得x1和y1。然后以x1和y1为基础，可计算得x2，y2 …… 这样一直迭代-iterate计算，我们就可以获得N个平面上的点(xi,yi)，把这些点在坐标系中画出来，就得到Peter de Jong吸引子的图像。 1234567891011121314151617181920212223#SimplePeterDeJong.pyfrom math import sin,cosfrom matplotlib import pyplot as pltdef iteration(): a,b,c,d = 0.970,-1.899,1.381,-1.506 x,y = 0,0 xdata,ydata = [],[] for i in range(1000000): xNew = sin(a*y) - cos(b*x) yNew = sin(c*x) - cos(d*y) x,y = xNew,yNew xdata.append(x) ydata.append(y) return xdata,ydataxdata,ydata = iteration()plt.figure(figsize=(6,6))plt.title(\"Peter de Jong Attractor\")plt.scatter(xdata,ydata,s=0.005)plt.show() 程序只有寥寥数行。首先我们从math模块导入了正弦-sin和余弦-cos函数；还导入了matplotlib中的pyplot模块并取名为plt。matplotlib是著名的C/C++语言编写的绘图包，可以很简单地生成各种图表。 iteration()函数进行迭代计算，首先初始化x = 0, y = 0，然后迭代计算100万个点，并把相应数据存入xdata,ydata列表并返回。xdata,ydata列表中存储了100万个点，其中第i个点的x轴坐标数据为xdata[i]，y轴坐标数据为ydata[i]。 plt.figure(figsize=(6,6))创建了一个长6英寸，宽6英寸的图-Figure，plt.title()函数设置了图的标题，plt.scatter()函数则在xy平面上绘制散点图，相应点的坐标数据包含在xdata及ydata列表中，s参数指定了点的绘制尺寸。plt.show()则把绘制好的图显示在屏幕上。程序运行结果如下： 在上图中，可以看到，x,y坐标的取值范围都是[-2, +2]。这是因为正弦函数和余弦函数的值域都是[-1, +1]，上述x,y取值为一个sin()减去一个cos()，两者各取极值，可得[-2,+2]的值域。 这个图表示了Peter de Jong吸引子的点的分布。它表现出混沌特性，当a,b,c,d的参数值不同时，图像差异会很大。为了把图变得美观一点，我们引入颜色。 2. 彩色PDJ吸引子1234567891011121314151617181920212223#ColoredPeterDeJong.py...def iteration(): e,f = 0.7,-1.1 a,b,c,d = 0.970,-1.899,1.381,-1.506 x,y,z = 0,0,0 xdata,ydata,zdata = [],[],[] for i in range(1000000): xNew = sin(a*y) - cos(b*x) yNew = sin(c*x) - cos(d*y) zNew = sin(e * x) - cos(f * z) x,y,z = xNew,yNew,zNew xdata.append(x) ydata.append(y) zdata.append(z) return xdata,ydata,zdataxdata,ydata,zdata = iteration()...plt.scatter(xdata,ydata,s=0.005,c=zdata)plt.show() 这段代码同前述代码有以下区别。首先，我们引用了新的参数e,f，并引入了z值。该z值以类似于x,y的方式被迭代计算，并通过zdata列表返回。 在plt.scatter()函数中，c=zdata表示每个散点的颜色从zdata列表中获取，即第i个散点的颜色数据为zdata[i]。至于matplotlib如何把zdata当中的浮点数据转换成实际的颜色，在这里作者没有深入探究。新程序的执行结果如下图。 3. 修改PDJ参数​ 作者尝试了几个不同的a,b,c,d参数，得到下述吸引子图像。 a,b,c,d = -0.709,1.638,0.452,1.740 a,b,c,d = 1.641,1.902,0.316,1.525 a,b,c,d = 1.4,-2.3,2.4,-2.1 a,b,c,d = 2.01,-2.53,1.61,-0.33 严格地说，上述吸引子图像远没有达到“艺术”效果。要想把上述吸引子图像画成“艺术”效果，需要图像渲染算法的知识，在这里没办法展开。其中一种比较有名的算法称之为分形火焰算法 - fractal flame algorithm。 本文内容节选自作者编著的《Python编程基础及应用》（高等教育出版社）一书。 免费随书B站MOOC:","categories":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/categories/Python/"},{"name":"数学之美","slug":"Python/数学之美","permalink":"http://codelearn.club/categories/Python/%E6%95%B0%E5%AD%A6%E4%B9%8B%E7%BE%8E/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/tags/Python/"},{"name":"吸引子","slug":"吸引子","permalink":"http://codelearn.club/tags/%E5%90%B8%E5%BC%95%E5%AD%90/"}]},{"title":"计算机是如何工作的？","slug":"computer","date":"2019-06-19T07:35:04.000Z","updated":"2020-09-11T06:18:38.413Z","comments":true,"path":"2019/06/computer/","link":"","permalink":"http://codelearn.club/2019/06/computer/","excerpt":"本文作为《Python编程基础与实践》一书的附录，向读者介绍计算机基础结构及工作原理。","text":"本文作为《Python编程基础与实践》一书的附录，向读者介绍计算机基础结构及工作原理。 版权声明 本文可以在互联网上自由转载，但必须：注明出处(作者：海洋饼干叔叔)并包含指向本页面的链接。 本文不可以以纸质出版为目的进行改编、摘抄。 占坑 本文内容节选自作者编著的《Python编程基础及应用》（高等教育出版社）一书。 免费随书B站MOOC:","categories":[{"name":"导论","slug":"导论","permalink":"http://codelearn.club/categories/%E5%AF%BC%E8%AE%BA/"}],"tags":[{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"http://codelearn.club/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"name":"体系结构","slug":"体系结构","permalink":"http://codelearn.club/tags/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"}]},{"title":"Visual Studio Code中的断点调试","slug":"vscdebug","date":"2019-06-16T06:50:04.000Z","updated":"2020-09-11T06:30:06.857Z","comments":true,"path":"2019/06/vscdebug/","link":"","permalink":"http://codelearn.club/2019/06/vscdebug/","excerpt":"本文描述Visual Studio Code的断点调试方法，帮助读者理解循环执行过程。","text":"本文描述Visual Studio Code的断点调试方法，帮助读者理解循环执行过程。 版权声明 本文可以在互联网上自由转载，但必须：注明出处(作者：海洋饼干叔叔)并包含指向本页面的链接。 本文不可以以纸质出版为目的进行改编、摘抄。 1. 简介在程序有BUG/缺陷，需要修复时，断点调试是发现缺陷的重要方法。对于初学者而言，断点调试还有另外一个用途：帮助理解程序背后的逻辑。 本文以下述程序为例，讲述在Visual Studio Code中的断点调试方法。 12345678910names = ['Peter Anderson', 'Frank Bush', 'Tom Henry','Jack Lee', 'Dorothy Henry']sName = \"NOTFOUND\"for x in names: if x.endswith(\"Henry\"): sName = x break print(x, \"not ends with 'Henry'.\")print(\"I found a Henry:\", sName) 2. 打断点在Visual Studio Code中打开相关代码文件，用鼠标在行号3的左方空白处单击（下图红点处），便会出现红色的断点-breakpoint。如果在相同位置再次单击，断点便会消失。在同一个程序中，断点可以打很多个。 3. 开始调试选择Debug-&gt;Start Debugging菜单项，或者直接按下F5快捷键（使用笔记本的读者注意：F5键可能同时复用了其它功能，需要配合Fn键使用); 然后在弹出的菜单里选择Python File / Debug the currently active Python file; 调试过程启动，程序开始运行，然后遇到了第3行的断点，停了下来。请读者注意，当前第3行是黄色高亮的，这说明程序执行完了1-2行，第3行处于等待执行状态。 上图的左方，VARIABLES/变量栏则列出了全部的LOCAL/局部变量。可以看到，作为第1行代码的执行结果，名字为names的变量存在，其值为一个列表。因为第3行代码尚未执行， 所以目前sName变量尚不存在。 4. 单步前进 - Step Into在前图的上方，有一个工具栏，其中，第三个按钮（方向向下的键头）的弹出标签为Step Into(F11)。这个按键的作用为单步前行。按一下这个按键，或者直接按F11，会发现程序向前执行了一行，第4行变为高亮待执行。作为第3行代码的执行结果，sName变量出现在左方VARIABLES栏中。如果把鼠标移至代码中的sName上方，Visual Studio Code还会显示sName变量的当前值为NOTFOUND。如下图： 5. 继续单步前进-研究循环再次点击Step Into, 第4行被执行，第5行变为高亮待执行。请读者注意，根据for循环, x变量取值names列表的第1个元素，其值为’Peter Anderson’。 显然，第5行的逻辑判断不成立，第6，7行不会被执行。再次按下Step Into后，第8行高亮待执行： Step Into执行第8行，下方控制台会输出相应的print结果，然后程序执行点回到了第4行，准备开始下一轮循环： 再次Step Into后，第5行高亮待执行。此时，x取值names列表的第2个元素，其值为’Frank Bush’: 同样，Frank Bush也不是Henry，第5行的逻辑判断不成立，6，7不执行，第8行执行 … 按Step Into两次，程序重新回到第4行，准备开始第三轮循环: 再次按下Step Into， 第5行高亮待执行。此时，x取值names列表的第3个元素，其值为’Tom Henry’。请注意，VARIABLES栏中x变量的值。 这一次不一样了，x以”Henry”结尾，所以第5行的逻辑判断成立，再次按下Step Into，程序来到了第6行: Step Into执行完第6行后，sName的值从’NOTFOUND’变成了’Tom Henry’，程序停在了第7行： 按照语义，break语句执行将导致循环直接结束，第8行不会执行，剩下的names列表中的’Jack Lee’, ‘Dorothy Henry’会被忽略，程序直接来到第9行。由于第9行是空行， Visual Studio Code直接来到第10行。请读者注意，根据缩进规则，第10行与第4行的for循环属于同一层级，不属于循环体内部代码。 再次Step Into, 第10行执行结束，下方控制台打印了“I found a Henry: Tom Henry。程序调试自动结束： 6. continue, while希望上述调试过程可以帮助读者理解for循环及break语句。 如果读者对continue, while循环等感到疑惑，也可以对相关代码进行调试研究。 7. Step Out, Step OverVisual Studio Code的调试工具栏内，还有Step Out, Step Over等按钮。不同于Step Into(单步前进)， Step Out, Step Over用于在调试过程中避免过分深入函数或者循环内部。 本文内容节选自作者编著的《Python编程基础及应用》（高等教育出版社）一书。 免费随书B站MOOC:","categories":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/categories/Python/"}],"tags":[{"name":"IDE","slug":"IDE","permalink":"http://codelearn.club/tags/IDE/"}]},{"title":"《Python编程基础及应用》在线MOOC","slug":"pyvideo","date":"2019-06-14T23:35:04.000Z","updated":"2020-09-11T06:27:55.736Z","comments":true,"path":"2019/06/pyvideo/","link":"","permalink":"http://codelearn.club/2019/06/pyvideo/","excerpt":"本文提供《Python编程基础及应用》一书配套的在线MOOC的最新访问地址。","text":"本文提供《Python编程基础及应用》一书配套的在线MOOC的最新访问地址。 BILIBILI https://www.bilibili.com/video/av34409478/ 网易云课堂 https://study.163.com/course/introduction/1006199001.htm 中国大学MOOC 建设中 读者QQ交流群1 本文内容节选自作者编著的《Python编程基础及应用》（高等教育出版社）一书。 免费随书B站MOOC:","categories":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/tags/Python/"}]},{"title":"PyQt扩展在VSC中的配置及基本使用方法","slug":"pyqtconfig","date":"2019-06-13T07:33:14.000Z","updated":"2020-09-11T06:25:03.343Z","comments":true,"path":"2019/06/pyqtconfig/","link":"","permalink":"http://codelearn.club/2019/06/pyqtconfig/","excerpt":"本文介绍在Visual Studio Code中PyQt扩展的配置及基本使用方法。","text":"本文介绍在Visual Studio Code中PyQt扩展的配置及基本使用方法。 版权声明 本文可以在互联网上自由转载，但必须：注明出处(作者：海洋饼干叔叔)并包含指向本页面的链接。 本文不可以以纸质出版为目的进行改编、摘抄。 PyQt工具简介Qt/PyQt中包括一系列的工具，其中： Qt Designer: 用即见即所得的方式设计图形界面，成果表现为扩展名为ui的文件。 可执行文件：pyqt5designer 。 UI Compiler: 将上述ui文件“编译”成Python程序。执行该Python程序便可以得ui文件所描述的图形界面。可执行文件: pyuic5。 Qt Linguist: 语言学家，可以便捷的实现软件的国际化，即生成软件的法语、英语、日语或者其它语种版本。工作模式大致可以描述成：先用pylupdate5扫描源代码中全部可翻译的字符串，然后用linguist翻译相应的字符串至目标语言，接下来用lrelease工具发布。软件运行时，加载法语版本的语言学家文件，软件界面就是法语，加载日语版本的语言学家文件，软件界面就是日语。可执行文件：linguist,pylupdate5,lrelease。 Resource Compiler: 资源编译器。UI文件设计过程中可以需要使用到各种图片，这些图片以资源文件的形式组织，扩展名为qrc；资源编译器负责将 qrc格式的资源文件编译成py文件，其中，图片被转换成bytes字节列。可执行文件： pyrcc5。 ​ PyQt扩展安装为了使用这些Qt工具，我们需要在Visual Studio Code中安装下述扩展或者其它类似功能的扩展并对扩展进行配置。Visual Studio Code上的扩展安装方法请回顾第一章相关内容。 pyqt5, pyqt5-tools作为Python扩展库，其安装路径位于Python安装路径的Lib\\site-packages子目录下。而上述Qt/PyQt工具的可执行文件，则可以在Python安装路径的Scripts路径下找到。在作者计算机上，该目录为： C:\\Users\\Alex\\AppData\\Local\\Programs\\Python\\Python38\\Scripts。 由于作者安装 Python解释器时选择将Python路径加入了系统路径。因此，上述C:\\Users\\Alex\\AppData\\Local\\Programs\\Python\\Python38\\Scripts路径在操作系统环境变量PATH中。引用上述目录中的可执行文件时，路径部分可以省略。 PyQt扩展的配置在Visual Studio Code中的Extensions管理页面，点击Qt for Python扩展的Manage齿轮按钮， 然后，按照提示逐一设置各种可执行文件/模块的路径及运行参数信息。 为方便读者，下表列出相关配置项的值。 配置项 值 备注 Path:Designer pyqt5designer.exe 文件在Python安装路径的Scripts目录下，该目录在系统路径中，故可直接使用 Path:Linguist / 本例中用不上，可不设置 Path:Lrelease / 本例中用不上，可不设置 Path:Pylupdate pylupdate5 -verbose -ts ./“${fileBasenameNoExtension}.ts” Path:Pyrcc pyrcc5 -o ./“${fileBasenameNoExtension}_rc.py” 注意_rc部分 Path:Pyuic pyuic5 -d -o ./“Ui_${fileBasenameNoExtension}.py” 注意Ui_部分 Path:Qmlscene / 本例中用不上，可不设置 创建新的UI文件在Visual Studio Code项目目录的空白位置右击鼠标，选择New Form(Qt Designer UI File) 注意: 由于一个Bug的存在，需要先在点击并打开任意一个ui文件（如下图中的MainWidget.ui)后，再在项目目录的空白处右击并选择New Form，否则会出错。 打开已有的UI文件在Visual Studio Code项目目录中单击打开UI文件（比如下图中的MainWidget.ui)，然后右击鼠标，在弹出菜单中选择Edit Form(Qt Designer UI File)。 资源文件的编译在Visual Studio Code中打开资源文件，如Images.qrc， 然后在编辑框中右击鼠标，并在弹出菜单中选择 Compile Resource File into Qt for Python File。 资源文件编译后，生成Images_rc.py文件。 本文内容节选自作者编著的《Python编程基础及应用》（高等教育出版社）一书。 免费随书B站MOOC:","categories":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/tags/Python/"}]},{"title":"《Python编程基础及应用》随书资料的下载","slug":"pycodedown","date":"2019-06-11T15:35:04.000Z","updated":"2020-09-11T06:23:28.376Z","comments":true,"path":"2019/06/pycodedown/","link":"","permalink":"http://codelearn.club/2019/06/pycodedown/","excerpt":"本页提供《Python编程基础及应用》一书的随书代码及其它资源的下载。 下载 - 随书源代码 https://codelearn.club/download/pylearn.zip (国外源，下载较慢) http://www.ircchina.com/filedownload/199810 （国内源，下载较快）","text":"本页提供《Python编程基础及应用》一书的随书代码及其它资源的下载。 下载 - 随书源代码 https://codelearn.club/download/pylearn.zip (国外源，下载较慢) http://www.ircchina.com/filedownload/199810 （国内源，下载较快） 下载 - 教学PPT 第2章习题及答案 第3章习题及答案 第4章习题及答案 第5章习题及答案 第6章习题及答案 第7章习题及答案 第8章习题及答案 第9章习题及答案 第10章习题及答案 第11章习题及答案 第12章习题及答案 第13章习题及答案 第14章习题及答案 第15章习题及答案 第16章习题及答案 第17章习题及答案 第18章习题及答案 第19章习题及答案 第20章习题及答案 第21章习题及答案 第22章习题及答案 第23章习题及答案 本文内容节选自作者编著的《Python编程基础及应用》（高等教育出版社）一书。 免费随书B站MOOC:","categories":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/categories/Python/"}],"tags":[{"name":"Book","slug":"Book","permalink":"http://codelearn.club/tags/Book/"}]},{"title":"Visual Studio Code里《Python编程实践》随书代码的打开及使用","slug":"pycodeuse","date":"2019-06-11T15:35:04.000Z","updated":"2020-09-11T06:23:42.799Z","comments":true,"path":"2019/06/pycodeuse/","link":"","permalink":"http://codelearn.club/2019/06/pycodeuse/","excerpt":"Visual Studio Code里《Python编程基础及应用》随书代码的打开及使用。","text":"Visual Studio Code里《Python编程基础及应用》随书代码的打开及使用。 版权声明 本文可以在互联网上自由转载，但必须：注明出处(作者：海洋饼干叔叔)并包含指向本页面的链接。 本文不可以以纸质出版为目的进行改编、摘抄。 1. 代码下载https://codelearn.club/2019/06/pycodedown/ 2. 解压缩代码下载后，请将代码解压缩到一个不含中文字符的文件夹内，如下图。可以看到，每一章的代码是一个子目录。 3. 用Visual Studio Code打开章节子目录以第二章为例，鼠标右键单击第二章代码子目录C2_VariableDataTypes，在弹出菜单中选择Open with Code. 接下来即可看到Visual Studio Code运行，并打开了相应的章节项目目录。 4. 运行程序文件在左侧单击datatypes.py，即可看到datatypes.py文件被打开，且处于可编辑状态。 选择Debug -&gt; Start Without Debugging菜单项，即可运行程序： 运行程序的结果被显示在Visual Studio Code的下方： 注意，有时候需要向下拉动右方的滚动条，才能看到输出结果。 本文内容节选自作者编著的《Python编程基础及应用》（高等教育出版社）一书。 免费随书B站MOOC:","categories":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/categories/Python/"}],"tags":[{"name":"Book","slug":"Book","permalink":"http://codelearn.club/tags/Book/"}]},{"title":"使用pip安装Python扩展库的方法","slug":"pipinstall","date":"2019-06-09T00:35:04.000Z","updated":"2020-09-20T10:20:39.153Z","comments":true,"path":"2019/06/pipinstall/","link":"","permalink":"http://codelearn.club/2019/06/pipinstall/","excerpt":"本文讨论Python扩展库的安装方法","text":"本文讨论Python扩展库的安装方法 版权声明 本文可以在互联网上自由转载，但必须：注明出处(作者：海洋饼干叔叔)并包含指向本页面的链接。 本文不可以以纸质出版为目的进行改编、摘抄。 使用pip进行安装对于Windows, 在开始菜单中找到并进入命令提示符，对于Linux或者Mac OS X, 请进入终端-Terminal. 在命令行中输入 pip install 模块名，然后回车-Enter, 即可安装模块。下图中，正在安装django(一种Python Web应用开发库)。 如果安装完成，系统会显示如下的信息： Successfully installed … 如果Windows命令提示符报错 “pip不是内部或者外部的命令”， 则说明在安装Python解释器时没有勾选下述选项，考虑后续使用方便，建议卸载Python解释器后重新安装。 Add Python 3.7 to PATH 在上述安装过程中，pip会从网络下载安装包。因此，安装时请保持网络连接通畅。由于相关服务器大多在国外，因此安装时经常会因为网络连接问题导致失败。此时，你需要使用国内的镜像源，详情见本文最后一节。 如果上述命令报告：Requirement already satisfied, 这说明这个模块之前已经成功安装过。 通常，你还会在pip的输出中看到下述内容： 12You are using pip version 19.0.3, however version 19.2.3 is available.You should consider upgrading via the &#39;python -m pip install --upgrade pip&#39; command. 这不是错误！ 它只是提示你你的pip工具的版本不够新，建议你升级。一般不必升级。 如果终端报告: pip不是内部或者外部命令， 也不是可运行的程序。这说明你在安装Python解释器的过程中Add to Path那个选项没有打勾。最容易的解决方案是卸载掉Python解释器后重新安装。安装时请务必按照随书网文中的步骤谨慎进行。 PIP是Python的包管理工具。 在部分Linux系统下，Python 2 和 Python 3的pip是分开的，为Python 3安装包，需要运行pip3。 如何验证模块是否安装成功? 在命令行中运行Python解释器，import numpy没有报错，说明numpy模块已成功安装；import flask报错，说明flash模块还没有成功安装；exit()命令退出解释器。 注意，部分模块的模块名与import时使用的名称可能不同，比如opencv的模块名为opencv-python，但导入时应使用import cv2。 模块被安装到了哪里？在Python解释器中，import sys, sys.path可以看到Python解释器在系统中的安装路径。比如作者计算机上的图径为C:\\Users\\Alex\\AppData\\Local\\Programs\\Python\\Python37。 在这个路径的Lib\\site-packages路径下，可以看到那些被安装的模块的文件。 安装失败怎么办有时候安装会失败，通常表现为安装突然中断，并有红字的错误信息。最大的可能是因为网速太慢，具体说是国内到pip官方软件仓库服务器的网速太慢。解决方案： 通过-i 参数指定国内下载源，比如，下述命令试图从国内清华的镜像源安装django模块： 1pip install django -i https://pypi.tuna.tsinghua.edu.cn/simple 本文内容节选自作者编著的《Python编程基础及应用》（高等教育出版社）一书。 免费随书B站MOOC:","categories":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/tags/Python/"}]},{"title":"说说程序中的命名规则","slug":"namemethod","date":"2019-06-08T23:35:04.000Z","updated":"2020-09-11T06:21:58.830Z","comments":true,"path":"2019/06/namemethod/","link":"","permalink":"http://codelearn.club/2019/06/namemethod/","excerpt":"程序里有很多东西需要命名， ​ 良好的命名习惯可以提高编程效率； 减少出错； ​ 良好命名的程序清晰易读。 ​ 好的名称可以提供很多有价值的信息。 本文解释作者在《Python编程基础及应用》一书中所使用的命名规则。","text":"程序里有很多东西需要命名， ​ 良好的命名习惯可以提高编程效率； 减少出错； ​ 良好命名的程序清晰易读。 ​ 好的名称可以提供很多有价值的信息。 本文解释作者在《Python编程基础及应用》一书中所使用的命名规则。 命名示例 变量、类的数据成员 iSum sName fPrice 函数名称 add() convert() del() empty() push_back() pop() getPrice() setPrice() draw() render() repaint() 类型名称 Student GraphDrawer Campus Engine FloatBuffer Lesson Monitor Printer EMailPacket 版权声明 本文可以在互联网上自由转载，但必须：注明出处(作者：海洋饼干叔叔)并包含指向本页面的链接。 本文不可以以纸质出版为目的进行改编、摘抄。 正确， 错误 vs 好，相对不好， 坏只要符合所用语言的命名规则的命名原则上都是“正确”的。 不同的人有不同的命名习惯。 没有标准答案，只有主观的好或者相对不好的判断。 但真的很重要： ​ 良好的命名习惯可以提高编程效率； 减少出错； ​ 良好命名的程序清晰易读。 ​ 好的名称可以提供很多有价值的信息。 规则1 全程使用英文，不准用拼音 ▪KHBH XH ZHYE DQJG - 猜得出这些名称是什么意思吗？ sCustomerNo, sStudentNo fAccountBalance fCurrentPrice Too long for you ? sCusNo, sStuNo, fAccBalance , fCurPrice 规则2 变量/类的数据成员的命名类型名缩写(小写） + 英文单词或其缩写（首字母大写） 类型 解释 缩写 举例 float 浮点数 f fPrice fSum fAmount fScore fHeight fWeight int 整数 i iCount / iCnt iStudentCount iWidth iHeight iCapacity string 字符串 s sStudentNo sMemo sHint sDiagnostics sContent sName bool 布尔型 b bFound bCaptured bFull bHungry bDied bMarried bAvailable 如果变量表达的是一个集合（数组或者list), 用小写的英文单词的复数形式： ​ students members prices wheels teachers universities shoes arms 规则3 函数的命名一个英文单词： 小写 add() convert() del() empty() try() pop() push() 两个英文单词： 第二个单词首字母大写 动+名 addAmount() setPrice() getPrice() setEmpty() pushDown() riseUp() toString() toDouble() 规则4 类型的命名由一个或者两个英文单词构成，每个单词的首字母均大写 FloatBuffer PrinterQueue Student Lesson Movie Song Employee Team Board Company Supplier GoldFish CellPhone GraphDrawer 在面向对象程序设计当中，一个文件通常只包括一个类型，通常文件名由类型名 + . + 扩展名构成: Student.py Company.h Company.cpp PrinterQueue.java 规则5 例外如果有一个临时变量，仅在上下几行局部代码中被使用，用完即弃，可以用小写单字母：(代码阅读者容易通过上下文确定变量的类型和用途) 12345s = s + “, Done”print(s)for i in range(100): print(i) 当心中文目录及中文文件名很多开发环境及软件对中文的支持并不好，永远不要使用任何包含中文的目录或文件名： 示例 正/误 d:/学习资料/python/实验1 X d:/Learing/python/Test1 √ 忠告命名这件事不同的人有不同的看法。 认真命好每个名， 尽量遵守规则。 表面上花时间，实际上省时间。 程序如果需要交给教师检查或者请求教师协助，两件事情先做好： 确认命名符合要求； 把程序排列整齐，检查缩进，分行。 本文内容节选自作者编著的《Python编程基础及应用》（高等教育出版社）一书。 免费随书B站MOOC:","categories":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/tags/Python/"},{"name":"语法","slug":"语法","permalink":"http://codelearn.club/tags/%E8%AF%AD%E6%B3%95/"}]},{"title":"Python解释器的安装","slug":"pythoninstall","date":"2019-06-08T23:35:04.000Z","updated":"2020-09-11T06:26:39.717Z","comments":true,"path":"2019/06/pythoninstall/","link":"","permalink":"http://codelearn.club/2019/06/pythoninstall/","excerpt":"本文描述Python官方解释器的下载及安装方法，主要考虑Windows系统。 Mac OS X以及Linux系统也有涉及。","text":"本文描述Python官方解释器的下载及安装方法，主要考虑Windows系统。 Mac OS X以及Linux系统也有涉及。 版权声明 本文可以在互联网上自由转载，但必须：注明出处(作者：海洋饼干叔叔)并包含指向本页面的链接。 本文不可以以纸质出版为目的进行改编、摘抄。 Python解释器软件可以在www.python.org官网上下载。下载前，读者可能需要先了解自己的计算机是64位或者32位系统。 对于Windows系统，可以在系统属性页面查得相关信息。 Python官网可能会同时提供多个版本，包括Beta版本（测试中的极可能包含错误的版本）供用户选择，建议读者下载稳定-Stable版本。对于32位系统，下载时应选择x86版本，对于64位操作系统，下载时应选择x86-64的版本。由于作者的系统是Windows 10 64位系统，所以作者选择”Windows x86-64 executable installer”进行下载。 下载完成后，作者得到了一个名为python-3.7.3-amd64.exe的可执行文件。对于这种可执行文件，下载后浏览器或者操作系统出于安全考虑可能会让你确认是否保留该文件，请选择保留。 在文件夹中鼠标左键双击运行，请务必勾选下方的两个选项，其中，Add Python 3.7 to PATH将Python相关目录加入操作系统的PATH环境变量。然后选择Install Now进行安装。 安装大约持续一两分钟，结束后点Close按钮即可。 注意：请不要在一台计算机上同时安装Python解释器的多个版本，这通常会导致初学者难以解决的混乱。 使用Mac OS X系统的读者 ​ 基本的安装方法差异不大，只是读者在下载安装包时，需要下载Mac OS X对应用版本。 使用Ubuntu等Linux系统的读者 请在终端-Terminal下执行下述命令，进行安装。 1sudo apt-get install python3 本文内容节选自作者编著的《Python编程基础及应用》（高等教育出版社）一书。 免费随书B站MOOC:","categories":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/tags/Python/"}]},{"title":"Python解释器的简单使用","slug":"pythonuse","date":"2019-06-08T23:35:04.000Z","updated":"2020-09-11T06:27:02.358Z","comments":true,"path":"2019/06/pythonuse/","link":"","permalink":"http://codelearn.club/2019/06/pythonuse/","excerpt":"本文简单描述Python官方解释器的使用方法。","text":"本文简单描述Python官方解释器的使用方法。 版权声明 本文可以在互联网上自由转载，但必须：注明出处(作者：海洋饼干叔叔)并包含指向本页面的链接。 本文不可以以纸质出版为目的进行改编、摘抄。 在Windows系统下，Python解释器可以在终端命令行中启动。读者可以在Windows系统菜单中选择命令提示符，以进入终端。在Mac OS X或者Linux系统中，终端通常称为Terminal。 在终端中输入python，然后回车-Enter，即可运行Python解释器。如果终端提示Python不是可运行的程序或者命令，那说明前述安装过程不正确或者安装启动时那个重要的勾没有打上，请卸载后重新安装。在Linux等其它系统中，启动Python 3版本的解释器可能需要输入python3命令，直接输入python很可能运行的是Python 2版本的解释器。 解释器里的&gt;&gt;&gt;符号后可以看到光标在闪烁，这里我们输入a = 3 + 2，然回按回车键；接下来输入a，再回车，可以看到系统报告a的值为5。在&gt;&gt;&gt;后输入命令exit()，解释器软件退出。 部分读者在终端/命令提示符会遇到命令无法输入的困难，这很可能跟输入法设置有关。建议初学者尽量将输入法切换至EN(英语)。 本文内容节选自作者编著的《Python编程基础及应用》（高等教育出版社）一书。 免费随书B站MOOC:","categories":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/tags/Python/"}]},{"title":"Visual Studio Code的扩展安装及配置","slug":"vscconfig","date":"2019-06-08T23:35:04.000Z","updated":"2020-09-11T06:29:56.986Z","comments":true,"path":"2019/06/vscconfig/","link":"","permalink":"http://codelearn.club/2019/06/vscconfig/","excerpt":"本文描述Visual Studio Code的扩展安装及配置方法。","text":"本文描述Visual Studio Code的扩展安装及配置方法。 版权声明 本文可以在互联网上自由转载，但必须：注明出处(作者：海洋饼干叔叔)并包含指向本页面的链接。 本文不可以以纸质出版为目的进行改编、摘抄。 界面左侧的这个图标用于管理Visual Studio Code的扩展 -Extensions。 在扩展页里，读者可以看到已经安装好的扩展，比如上述名为Python的扩展，以及系统推荐安装的扩展。必要时，读者还可以在Marketplace中搜索安装特定的扩展。正是这些扩展，赋予Visual Studio Code编译不同语言代码的能力，它既可以用于编辑Python，也可以编译C++, Java等语言代码。 读者可能会发现你的Visual Studio Code界面的配色，以及字体等与作者的不同。为了方便印刷和演示，作者对软件进行了设置。读者可以通过File-Preferences-Settings菜单项进行设置界面。在这里，读者可以设置界面的字体-Font, 界面的外观-Appearance等选项。 通过菜单File-Preferences-Keyboard Shortcuts可以调出软件全部的快捷键。等读者建立起一定的熟练程度后，适当记忆并使用这些快捷键有助于提高工作效率。 本文内容节选自作者编著的《Python编程基础及应用》（高等教育出版社）一书。 免费随书B站MOOC:","categories":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/categories/Python/"}],"tags":[{"name":"IDE","slug":"IDE","permalink":"http://codelearn.club/tags/IDE/"}]},{"title":"Visual Studio Code的下载与安装","slug":"vscinstall","date":"2019-06-08T23:35:04.000Z","updated":"2020-09-11T06:30:17.086Z","comments":true,"path":"2019/06/vscinstall/","link":"","permalink":"http://codelearn.club/2019/06/vscinstall/","excerpt":"本文描述Visual Studio Code的下载及安装方法。","text":"本文描述Visual Studio Code的下载及安装方法。 版权声明 本文可以在互联网上自由转载，但必须：注明出处(作者：海洋饼干叔叔)并包含指向本页面的链接。 本文不可以以纸质出版为目的进行改编、摘抄。 Visual Studio Code是由微软公司提供的免费代码编辑工具，可以在下述网址下载。同样地，读者需要根据自己的操作系统类型和位数(32/64位)选择对应的版本。 https://code.visualstudio.com/Download 作者选择的是Windows-System Installer 64bit版本。下载完成的软件是一个名为VSCodeSetup-x64-1.35.0.exe的可执行文件。 双击该文件启动安装。 选择“下一步”继续。 MIT协议是一种开源软件许可协议，其名源自“麻省理工学院”，这种协议赋予被授权者极大的自由和很少的限制。选择“我接受协议”，然后选“下一步”。在后续安装过程中，一直选“下一步”。 在这一页，我们建议读者将全部选项打上勾，这将方便软件的后续使用。 选择“安装”。安装完成后，读者应能在Windows系统的桌面上找到一个名为Visual Studio Code的图标。如果桌面上没有，在系统的开始菜单里应能找到： 在桌面上双击该图标，或者在系统开始菜单里选择该图标，可以启动Visual Studio Code软件。 本文内容节选自作者编著的《Python编程基础及应用》（高等教育出版社）一书。 免费随书B站MOOC:","categories":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/categories/Python/"}],"tags":[{"name":"IDE","slug":"IDE","permalink":"http://codelearn.club/tags/IDE/"}]},{"title":"Visual Studio Code的简单使用","slug":"vscuse","date":"2019-06-08T23:35:04.000Z","updated":"2020-09-11T06:30:40.020Z","comments":true,"path":"2019/06/vscuse/","link":"","permalink":"http://codelearn.club/2019/06/vscuse/","excerpt":"本文描述Visual Studio Code的基本使用方法。","text":"本文描述Visual Studio Code的基本使用方法。 版权声明 本文可以在互联网上自由转载，但必须：注明出处(作者：海洋饼干叔叔)并包含指向本页面的链接。 本文不可以以纸质出版为目的进行改编、摘抄。 1.打开或者创建项目目录Visual Studio Code是一个跨语言的代码编辑工具，可以简单地使用目录-Folder来管理程序文件。选择File-Open Folder…菜单。 然后在某个盘下创建一个不含中文字符的英文目录，比如PyLearn, 选中，然后选“选择文件夹”。作者强烈建议，不要在程序目录或者程序的文件名中使用中文字符，英文是编程世界的通用语言，使用中文字符可能带来一些意想不到的问题。 界面左上角的图标为EXPLORER图标，点击它可以打开或者关闭位于界面左侧的EXPLORER。 2. 添加py程序文件在EXPLORER中，可以看到打开的PyLearn目录，点击目录右方的New File加号按钮，增加一个名为1.py的文件。点击New Folder加号按钮，则可以在PyLearn目录下添加子目录。 1.py中点前面的”1”称之为文件的基本名，点之后的”py”则为文件的扩展名。一个文件的扩展名为py说明文件中包括的是Python语言书写的程序。双击1.py可以打开该文件进行编辑。我们在文件中输入如下内容： 请注意，上述内容是往左顶格输入的，即字母p前没有空格；另个，整行内容全部是英文字符，没有中文字符。 3. 安装PyLint扩展 此时，软件可能会提示你安装一个跟Python有关的扩展-extension，请选择”Install”。 4. 程序运行，查看结果安装完扩展后，就可以尝试执行1.py文件内的代码了。保持1.py被打开，然后选择Debug-Start Without Debugging，即可运行1.py程序。 如果你在软件的下方找到了上述 “Hello”输出，那么说明，你已准备好了本书所需要的软件环境。 请读者注意上图中的红色箭头所指向的滚动条，有时，需要向下拉动这个滚动条至最下端，才可以看到Visual Studio Code的最新输出。 作者认为这是Visual Sudio Code的一个小小的设计缺陷，希望读者读到这些文字时，该缺陷已经得到修正。 本文内容节选自作者编著的《Python编程基础及应用》（高等教育出版社）一书。 免费随书B站MOOC:","categories":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/categories/Python/"}],"tags":[{"name":"IDE","slug":"IDE","permalink":"http://codelearn.club/tags/IDE/"}]},{"title":"Lorenz洛伦兹微分方程求解","slug":"pylorenzintegrate","date":"2019-02-11T03:35:04.000Z","updated":"2020-09-11T06:24:07.747Z","comments":true,"path":"2019/02/pylorenzintegrate/","link":"","permalink":"http://codelearn.club/2019/02/pylorenzintegrate/","excerpt":"本小节求解Lorenz微分方程：在“数学之美”那一章里，为方便读者理解，Lorenz吸引子轨迹的计算采用了比较“原始”的方法。采用integrate模块中的odeint()函数可以更加方便地完成计算。Lorenz吸引子由下述三个微分方程定义：$$\\frac{dx}{dt}=\\sigma(y-x), \\quad \\frac{dy}{dt}=x(\\rho-z)-y,\\quad \\frac{dz}{dt}=xy-\\beta z$$","text":"本小节求解Lorenz微分方程：在“数学之美”那一章里，为方便读者理解，Lorenz吸引子轨迹的计算采用了比较“原始”的方法。采用integrate模块中的odeint()函数可以更加方便地完成计算。Lorenz吸引子由下述三个微分方程定义：$$\\frac{dx}{dt}=\\sigma(y-x), \\quad \\frac{dy}{dt}=x(\\rho-z)-y,\\quad \\frac{dz}{dt}=xy-\\beta z$$ 版权声明 本文可以在互联网上自由转载，但必须：注明出处(作者：海洋饼干叔叔)并包含指向本页面的链接。 本文不可以以纸质出版为目的进行改编、摘抄。 微实践 - Lorenz吸引子常微分方程组求解​ 在“数学之美”那一章里，为方便读者理解，Lorenz吸引子轨迹的计算采用了比较“原始”的方法。采用integrate模块中的odeint()函数可以更加方便地完成计算。Lorenz吸引子由下述三个微分方程定义：$$\\frac{dx}{dt}=\\sigma(y-x), \\quad \\frac{dy}{dt}=x(\\rho-z)-y,\\quad \\frac{dz}{dt}=xy-\\beta z$$​ 其中，σ, ρ, β为参数。这些方程定义了三维空间中的一个无质量点(x,y,z)的各轴坐标相对于时间的速度矢量。我们这里需要计算随着时间t的变化，无质量点(x,y,z)的运动轨迹，也就是一组时间点上的系统状态。 ​ 源代码如下： 123456789101112131415161718192021import numpy as npfrom scipy import integrateimport matplotlib.pyplot as pltfrom mpl_toolkits.mplot3d import Axes3Ddef lorenz(p,t,s,r,b): x,y,z = p.tolist() #无质量点的当前位置(x,y,z) print(\"x,y,z,t:\",x,y,z,t) #帮助理解odeint的执行过程 return s*(y-x),x*(r-z)-y,x*y-b*z #返回dx/dt,dy/dt,dz/dtt = np.arange(0,30,0.01)track1 = integrate.odeint(lorenz,(0.0,1.00,0.0),t,args=(10.0,28.0,2.6))track2 = integrate.odeint(lorenz,(0.0,1.01,0.0),t,args=(10.0,28.0,2.6))print(\"type(track1):\",type(track1),\"track1.shape:\",track1.shape)fig = plt.figure(figsize=(12,6))ax = fig.gca(projection='3d') #获取当前子图，指定三维模式ax.plot(track1[:,0],track1[:,1],track1[:,2],lw=1.0,color='r') #画轨迹1 ax.plot(track2[:,0],track2[:,1],track2[:,2],lw=1.0,color='g') #画轨迹2 ...plt.show() 控制台输出： 123456...x,y,z,t: -5.64346434502397 -6.711791064199058 21.875348370569984 12.728116763457338x,y,z,t: -5.6434643216721705 -6.7117909582448 21.875348207825766 12.728116763457338x,y,z,t: -5.776218568580239 -7.038353710472807 21.677470196579595 12.739506857199522...type(track1): &lt;class &#39;numpy.ndarray&#39;&gt; track1.shape: (3000, 3) ​ 首先，定义了函数lorenz()，它的任分是计算无质量点坐标各方向相对于时间t的微分值。参数s,r,b分别对应方程组中的σ, ρ, β，t为时间（在函数里没有用到），p是一个ndarray，p.tolist()将其转换成一个列表，其中包括当前无质量点的坐标。 ​ t = np.arange(0,30,0.01)以0.01有间隔，生成从0至30(不含)的等差数列，它代表了一组离散的时间点。 ​ integrate.odeint()则进行微分方程求解，参数lorenz指明了微分计算函数，(0.0,1.00,0.0)则为无质量点的位置初始值；t为离散时间点；args指定了要传递给lorenz函数的额外参数，对应s,r,b，为固定值。odeint()会迭代调用lorenz()函数，用于生成无质量点的运动轨迹。上述控制台输出的结果可以帮助读者理解x,y,z坐标及t的变化过程。 ​ t是一个长度为3000的一维数组，odeint()返回结果为一个形状为(3000,3)的二维数组，用3000个离散的三维空间点来表示无质量点的运动轨迹。据信，odeint()会将lorenz()函数返回的微分值再乘以dt以获得dx,dy和dz，这个过程其实跟我们在“数学之美”那一章的模拟计算过程类似，但更高效，更精确。 ​ track1[:,0]对track1二维数组进行下标切片，得到3000个元素的一维数组，表示3000个空间点的x坐标，y和z坐标以类似方式获得。 ​ 我们可以看到，track1-红和track2-绿仅在系统初始值上有细微差异，但随着时间的推进，其运动轨迹差异越来越大，表现出“混沌”性：南美洲一只蝴蝶扇动翅膀，会引起对面半球一场飓风。 本文内容节选自作者编著的《Python编程基础及应用》（高等教育出版社）一书。 免费随书B站MOOC:","categories":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/categories/Python/"},{"name":"科学计算","slug":"Python/科学计算","permalink":"http://codelearn.club/categories/Python/%E7%A7%91%E5%AD%A6%E8%AE%A1%E7%AE%97/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/tags/Python/"},{"name":"SciPy","slug":"SciPy","permalink":"http://codelearn.club/tags/SciPy/"},{"name":"integrate","slug":"integrate","permalink":"http://codelearn.club/tags/integrate/"},{"name":"混沌","slug":"混沌","permalink":"http://codelearn.club/tags/%E6%B7%B7%E6%B2%8C/"},{"name":"Lorenz","slug":"Lorenz","permalink":"http://codelearn.club/tags/Lorenz/"}]},{"title":"Python求解数值积分-定积分求解","slug":"pyintegrate","date":"2019-02-10T23:35:04.000Z","updated":"2020-09-11T06:16:50.603Z","comments":true,"path":"2019/02/pyintegrate/","link":"","permalink":"http://codelearn.club/2019/02/pyintegrate/","excerpt":"本小节求解下述定积分：$$\\int_{0.7}^4(cos(2πx)e^{-x}+1.2)\\mathrm{d}x$$","text":"本小节求解下述定积分：$$\\int_{0.7}^4(cos(2πx)e^{-x}+1.2)\\mathrm{d}x$$ 版权声明 本文可以在互联网上自由转载，但必须：注明出处(作者：海洋饼干叔叔)并包含指向本页面的链接。 本文不可以以纸质出版为目的进行改编、摘抄。 数值积分-integrate​ integrate模块提供了好几种数值积分的方法，包括常微分方程组(ODE)的数值积分。相关函数列表如下： 函数名 作用 函数名 作用 quad() 一元定积分 dblquad() 二元定积分 triquad() 三元定积分 odeint() 计算常微分方程组的数值解 微实践 - 定积分求解​ 本小节求解下述定积分：$$\\int_{0.7}^4(cos(2πx)e^{-x}+1.2)\\mathrm{d}x$$​ 为了方便说明，我们先使用下述代码画出示意图： 1234567891011121314import numpy as npfrom matplotlib import pyplot as pltx = np.linspace(0,6,1000)y = np.cos(2*np.pi*x)*np.exp(-x)+1.2plt.axis([np.min(x),np.max(x),0,np.max(y)]) #坐标范围plt.plot(x,y,label=\"$cos(2πx)e^&#123;-x&#125;+1.2$\") #画曲线，带图示plt.fill_between(x,y1=y,y2=0,where=(x&gt;=0.7)&amp;(x&lt;=4), #填充积分区域 facecolor='blue',alpha=0.2)plt.text(0.5*(0.7+4),0.4,r\"$\\int_&#123;0.7&#125;^4(cos(2πx)e^&#123;-x&#125;+1.2)\\mathrm&#123;d&#125;x$\", horizontalalignment='center',fontsize=14) #增加说明文本plt.legend() #显示图示plt.show() 执行结果： ​ plt.axis()函数设定了图的坐标范围。fill_between(x,y1=y,y2=0,where=(x&gt;=0.7)&amp;(x&lt;=4)…)则用于填充积分区域，其中，x和y1构成曲线1; x和y2=0构成曲线2(也就是横坐标线)；该函数填充两条曲线之间x值域为[0.7,4]的部分，where参数指明了这个值域。facecolor指定填充颜色，alpha参数指定透明度。 ​ plt.text()则在图上添加文本，前两个参数指定了文本的坐标位置，horizontalalignment=’center’要求文本在指定的位置水平居中摆放(指定位置位于文本的水平中心)。r”$…$“为文本内容：字符串前加表示放弃对字符串内的内容进行\\转义；两个”为文本内容：字符串前加r表示放弃对字符串内的内容进行\\转义；两个$包含起来说明其中的内容为LaTeX格式的公式。 ​ 显然，上述定积分就是上图中阴影部分的面积。 ​ 方法1：分成小矩形，计算面积和 1234567import numpy as npx = np.linspace(0.7,4.0,1000)y = np.cos(2*np.pi*x)*np.exp(-x)+1.2dx = x[1] - x[0] #每个矩形的宽度fArea = np.sum(y*dx) #矩形宽*高，再求和print(\"Integral area:\",fArea) 执行结果： 1Integral area: 4.032803310221616 ​ 上述代码中，把曲线的阴影部分分成1000个矩形，每个矩形的宽都是dx，第i个矩形的高则是yi。每个矩形的长乘宽，再求和，得积分面积。 ​ 方法2：使用quad()函数进行积分 123456789import mathfrom scipy import integratedef func(x): print(\"x=\",x) #用于展示quad()函数对func的多次调用 return math.cos(2*math.pi*x)*math.exp(-x)+1.2fArea,err = integrate.quad(func,0.7,4)print(\"Integral area:\",fArea) 执行结果： 1234567x&#x3D; 2.35x&#x3D; 0.7430542279466668x&#x3D; 3.9569457720533334x&#x3D; 2.4613227224815875...x&#x3D; 3.4178741117287044Integral area: 4.029065401143393 ​ 首先，我们定义了一个函数func()，它根据x计算y值。当对单个数值进行计算时，numpy的ufunc并不具备速度优势，所以我们使用了math模块。 ​ integrate.quad()专门用于计算一元定积分，fArea,err = integrate.quad(func,0.7,4)取x值域[0.7,4]进行数值积分，在积分过程中，会反复调用func()函数计算y值。其返回一个元组，包括积分结果及误差。 ​ integrate.quad()计算的积分会比方法1的矩形面积求和方法更加精确。 本文内容节选自作者编著的《Python编程基础及应用》（高等教育出版社）一书。 免费随书B站MOOC:","categories":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/categories/Python/"},{"name":"科学计算","slug":"Python/科学计算","permalink":"http://codelearn.club/categories/Python/%E7%A7%91%E5%AD%A6%E8%AE%A1%E7%AE%97/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/tags/Python/"},{"name":"SciPy","slug":"SciPy","permalink":"http://codelearn.club/tags/SciPy/"},{"name":"integrate","slug":"integrate","permalink":"http://codelearn.club/tags/integrate/"}]},{"title":"深入讨论Python中的序列切片语法","slug":"pyslice","date":"2019-02-10T23:35:04.000Z","updated":"2020-09-12T04:15:46.125Z","comments":true,"path":"2019/02/pyslice/","link":"","permalink":"http://codelearn.club/2019/02/pyslice/","excerpt":"本小节深入探讨Python中的序列切片语法。切片-slicing可以获取序列的子序列（列表，字符串…)： 12345678numbers = [x for x in range(10)]print(\"numbers:\",numbers)print(\"numbers[3:9]:\",numbers[3:9])print(\"numbers[3:]:\",numbers[3:])print(\"numbers[:9]:\",numbers[:9])print(\"numbers[-6:-1]:\",numbers[-6:-1])print(\"numbers[1:9:2]:\",numbers[1:9:2])print(\"numbers[-1:1:-2]:\",numbers[-1:1:-2])","text":"本小节深入探讨Python中的序列切片语法。切片-slicing可以获取序列的子序列（列表，字符串…)： 12345678numbers = [x for x in range(10)]print(\"numbers:\",numbers)print(\"numbers[3:9]:\",numbers[3:9])print(\"numbers[3:]:\",numbers[3:])print(\"numbers[:9]:\",numbers[:9])print(\"numbers[-6:-1]:\",numbers[-6:-1])print(\"numbers[1:9:2]:\",numbers[1:9:2])print(\"numbers[-1:1:-2]:\",numbers[-1:1:-2]) 版权声明 本文可以在互联网上自由转载，但必须：注明出处(作者：海洋饼干叔叔)并包含指向本页面的链接。 本文不可以以纸质出版为目的进行改编、摘抄。 切片切片-slicing可以获取序列的子序列（列表，字符串…)： 12345678numbers = [x for x in range(10)]print(\"numbers:\",numbers)print(\"numbers[3:9]:\",numbers[3:9])print(\"numbers[3:]:\",numbers[3:])print(\"numbers[:9]:\",numbers[:9])print(\"numbers[-6:-1]:\",numbers[-6:-1])print(\"numbers[1:9:2]:\",numbers[1:9:2])print(\"numbers[-1:1:-2]:\",numbers[-1:1:-2]) 执行结果： 1234567numbers: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]numbers[3:9]: [3, 4, 5, 6, 7, 8]numbers[3:]: [3, 4, 5, 6, 7, 8, 9]numbers[:9]: [0, 1, 2, 3, 4, 5, 6, 7, 8]numbers[-6:-1]: [4, 5, 6, 7, 8]numbers[1:9:2]: [1, 3, 5, 7]numbers[-1:1:-2]: [9, 7, 5, 3] 说明 - 切片功能强大到令人发挥的程度，同时也复杂到令人费解； - numbers[3:9]从下标3开始复制元素，直到下标8(9-1)； - numbers[3:]等价于numbers[3:10]，从下标3开始复制元素，直到末尾，即下标9(10-1)； - numbers[:9]等价于numbers[0:9]，从下标0开始复制元素，直到下标8(9-1)； - numbers[-6:-1]等价于numbers[4:9]，其中len(numbers)-6=4, len(numbers)-1=9； - numbers[1:9:2]从下标1开始复制元素，每复制1个元素，下标+2, 直到下标达到或超过9结束（注意不包括下标为9的元素); - numbers[-1:1:-2]从下标len(numbers)-1，即下标9开始复制元素，每复制1个元素，下标-2，直到下标&lt;=1结束（注意不包括下标为1的元素)。 ​ 综上，numbers的切片的完整形式为: numbers[x:y:z]，z为步长，缺省值为1，x为起始下标，y为终止下标。z &gt; 0时，x缺省为0, 包括最左端的元素， y缺省为len(numbers)，包括最右端的元素，最右端元素的下标为len(numbers)-1。注意，当z值为负数时，切片方向为从右往左，起始下标x应包括最右方（也就是最后一个）元素，故x的缺省值为len(numbers)-1；终止下标y则为-1， 这有点让有费解：因为如果y为0的话，列表的下标0元素将不会被包括在切片中。如果你还感到疑惑，请看下一小节。 深入理解切片​ 切片的过程事实上跟数值列表range(x,y,z)的计数过程十分类似，由于这个切片过程适用于所有序列(字符串，列表…)，故下图中我们用seq[x:y:z]表示序列及其切片参数，首先考虑z&gt;0的情况： ​ 现以numbers[1:9:2]为例，依上述流程图说明输出集合为什么是[1,3,5,7]。首先，下标取值x=1，然后开始循环： 123456789- 下标1 &lt; 9成立，复制numbers[1],即值1; - 下标&#x3D;1+2&#x3D;3; - 下标3 &lt; 9成立，复制numbers[3],即值3； - 下标&#x3D;3+2&#x3D;5; - 下标5 &lt; 9成立，复制numbers[5],即值5；- 下标&#x3D;5+2&#x3D;7; - 下标7 &lt; 9成立，复制numbers[7],即值7；- 下标&#x3D;7+2&#x3D;9; - 下标9 &lt; 9不成立，循环结束。 ​ 如果你有C/C++经验，看下面的代码秒懂，因为Python的解释器就是用C/C++编写的。 123for (int i=x;i&lt;y;i+=z)&#123; copy(seq[i]);&#125; ​ 当z&lt;0时，seq[x:y:z]的切片流程图如下： ​ ​ 当z&lt;0时，切片过程事实上是从序列尾部往头部方向行进的，由于z是负数，所以下标=下标+z事实上导致下标减小。如果你有C/C++经验，看下面的代码秒懂，因为Python的解释器就是用C/C++编写的。 123for (int i=x;i&gt;y;i+=z)&#123; copy(seq[i]);&#125; ​ 该你了，请依上述流程图，人肉执行numbers[-1:1:-2]的切片过程，看看输出结果跟Python解释器输出是否一致。提示，-1表示倒数第1个元素，即len(numbers)-1=9。 ​ 妙用切片12345678910numbers = [x for x in range(10)]numbersCopy = numbers[:]print(\"id:\", id(numbers), numbers)print(\"id:\", id(numbersCopy), numbersCopy)numbersReversed = numbers[::-1]print(\"numbersReversed:\",numbersReversed)numbers[3:5] = 77,88print(\"numbers:\",numbers) 执行结果： 1234id: 2611651371592 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]id: 2611651371656 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]numbersReversed: [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]numbers: [0, 1, 2, 77, 88, 5, 6, 7, 8, 9] ​ 从上述代码及执行结果可以看出，numbers[:]产生了numbers的副本，其效果等价于numbers.copy(), numbers与numbersCopy的id值不同；而numbers[::-1]从尾部往前进行切片，其切片正好将序列倒序。这与numbers.reverse()有区别，numbers.reverse()会导致numbers列表被改变，且不会返回新列表；而numbers[::-1]会保持numbers列表不变，并生成一个新的列表。 ​ 请注意倒数第二行代码，对列表的切片还可以用于批量修改列表元素。从结果可见，numbers[3:5] = 77,88等价于numbers[3] = 77和numbers[4] = 88。 字符串切片​ 作为一种序列，字符串的切片方法与列表几乎完全相同，见下述代码： 1234numbers = '0123456789'print(numbers[2:5])print(numbers[1:9:2])print(numbers[:3:-2]) 执行结果： 1232341357975 本文内容节选自作者编著的《Python编程基础及应用》（高等教育出版社）一书。 免费随书B站MOOC:","categories":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/tags/Python/"},{"name":"切片","slug":"切片","permalink":"http://codelearn.club/tags/%E5%88%87%E7%89%87/"}]},{"title":"深入理解Python的数据类型及名字绑定","slug":"pynamebinding","date":"2019-02-10T22:35:04.000Z","updated":"2020-09-12T04:16:57.594Z","comments":true,"path":"2019/02/pynamebinding/","link":"","permalink":"http://codelearn.club/2019/02/pynamebinding/","excerpt":"​ 本小节深入讨论Python中的数据类型与名字绑定的关系，了解赋值过程的内部细节。","text":"​ 本小节深入讨论Python中的数据类型与名字绑定的关系，了解赋值过程的内部细节。 版权声明 本文可以在互联网上自由转载，但必须：注明出处(作者：海洋饼干叔叔)并包含指向本页面的链接。 本文不可以以纸质出版为目的进行改编、摘抄。 数据类型及名字绑定​ 除了已经讨论过的整数-int、 浮点数-float、 布尔型-bool、字符串-str、列表-list之外，还有一些数据类型尚待讨论。 元组-只读的列表​ 元组-tuple就是只读的列表。所谓只读，是指一个元组创建出来以后， 其值或者元素可以获取，但不能修改。上一章所讲述的关于列表的嵌套、in、not in、统计、运算等都适用于元组，切片也适用。注意切片并不会导致原始列表/元组被修改，其只会创建一个新列表/元组。 ​ 那些会导致列表发生修改的成员函数，比如remove(), sort()则不适用于元组，因为元组是只读的。 123456789patient = ('2012011', 'Eric Zhang', 'male', 77, True, (67,22,78))print(type(patient), patient)print(len(patient))print(patient[1:4])print(patient.count(True))print(True in patient)print(max((1,3,5)))print((1,2) + (2,3) + (4,))print((1,2) * 5) 执行结果： 12345678&lt;class &#39;tuple&#39;&gt; (&#39;2012011&#39;, &#39;Eric Zhang&#39;, &#39;male&#39;, 77, True, (67, 22, 78))6(&#39;Eric Zhang&#39;, &#39;male&#39;, 77)1True5(1, 2, 2, 3, 4)(1, 2, 1, 2, 1, 2, 1, 2, 1, 2) ​ 可以看到，元组用()框起来定义。上面的代码展示了元组的嵌套、len()函数、切片、max()、count()成员函数、in、拼接、运算等操作，其方法和用途与列表完全相同。 ​ 请注意上述代码中最后一行这个奇怪的表达”(4,)“, 这是告知解释器，这是由一个元素构成的元组，而不是打了括号的整数4。 ​ 下述操作则不适用于元组，因为这些操作预期会改变元组的值，而元组是只读的。 123456patient = ('2012011', 'Eric Zhang', 'male', 77, True, (67,22,78))#下述代码是发生执行错误patient[1] = 'NEW VALUE'patientSort = patient.sort()patient.remove(77)patient.clear() 生成与转换12345678numbers = tuple([1,2,3])print(numbers)chars = tuple('abc')print(chars)digits1 = (x for x in range(9))print(\"digits1:\", digits1)digits2 = tuple(x for x in range(9))print(digits2) 执行结果： 1234(1, 2, 3)(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;)digits1: &lt;generator object &lt;genexpr&gt; at 0x0000019D5458BA20&gt;(0, 1, 2, 3, 4, 5, 6, 7, 8) 可以看到，tuple()函数接受一个列表、字符串或者一个生成者对象-generator object作为参数，并返回一个元组。注意，digits1 = (x for x in range(9))被认为是一个生成者对象-generator object。 bytes​ 本节是介绍性内容，初学者如果对底层细节不感兴趣，可以略过。 ​ 在工业应用中，比如用Python语言编写工业机器人的控制程序，我们经常需要跟硬件直接通信。在数字电路里，永远是二进制的，所以我们所描述的全部数据类型在计算机内部最终全部以二进制形式存储和传输。bytes是只读的“二进制字节流”类型。 123456789buffer = b'abcdefghijklmn'print(buffer,type(buffer),\"len=\",len(buffer))print(buffer[2:9:2])buffer = b'\\x11\\xff\\x77'print(\"%x\" % (buffer[1]))buffer = bytes(i+0x10 for i in range(10))print(buffer) 执行结果： 1234b&#39;abcdefghijklmn&#39; &lt;class &#39;bytes&#39;&gt; len&#x3D; 14b&#39;cegi&#39;ffb&#39;\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19&#39; ​ 上述代码及执行结果展示了bytes的定义，len()函数、切片等基本操作。bytes()函数可以把一个生成者对象转换为bytes。一个字节如果看作无符号整数的话， 可以存储0-255之间的任何值。所以bytes作为字节流，其每个字节可以存任何0-255之间的任意整数，不限于’a’,’2’ 这些”可见”字符。 转换12345678x = 65534bufferLittle = x.to_bytes(2, 'little')print(\"little endian:\", bufferLittle)bufferBig = x.to_bytes(2,'big')print(\"big endian:\", bufferBig)y = int.from_bytes(b'\\xfe\\xff','little')print(y) 执行结果： 123little endian: b&#39;\\xfe\\xff&#39;big endian: b&#39;\\xff\\xfe&#39;65534 ​ 如上，int的to_bytes()成员函数将一个整数转换成指定字节长度(示例中为2)的bytes，第2个参数’little’指明了字节编码顺序。现存的CPU在存储和处理数据时，存在little endian和big endian两种标准，其中，little endian高位字节存高地址，big endian则正好相反。常用的Intel x86 CPU（用于PC系统）以及ARM CPU(常见于智能手机及其它嵌入式系统，智能电视之类)都是little endian的。 ​ int的from_bytes()成员函数则把bytes重新打包成Python的int对象。 ​ 借助于struct模块，我们可以更方便地把int, float和其它数据类型同bytes进行相互转换。 bytearray​ 本节是介绍性内容，初学者如果对底层细节不感兴趣，可以略过。 ​ bytearray可以译作字节数组，其功用与bytes类似，区别在于，bytearray不是只读的，可修改。 1234567buffer = bytearray(0x00 for x in range(10))print(type(buffer), buffer)buffer = bytearray(b'abcdefghijklmn')buffer[1] = ord('B')print(buffer)print(buffer[3:11:3]) 执行结果： 123&lt;class &#39;bytearray&#39;&gt; bytearray(b&#39;\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00&#39;)bytearray(b&#39;aBcdefghijklmn&#39;)bytearray(b&#39;dgj&#39;) ​ 上述代码及执行结果展示了bytearray的定义，切片方法。其中，ord()函数来自于英文order, 它将一个字符转换成其对应的ASCII码整数。 ​ ASCII码是一个表格，将每个字符与一个整数对应，这个整数事实上就是字符在计算机内部的实际存储值。 按位与、或、移位​ 本节是介绍性内容，初学者如果对底层细节不感兴趣，可以略过。 12345678x = 0xaaprint(\"x =\", bin(x))print(\"x &amp; 0x7f =\", bin(x &amp; 0x7f))print(\"x | 0x77 =\", bin(x | 0x77))y = 0x00ffy = y &lt;&lt; 8print(\"y =\", hex(y)) 执行结果： 1234x &#x3D; 0b10101010x &amp; 0x7f &#x3D; 0b101010x | 0x77 &#x3D; 0b11111111y &#x3D; 0xff00 ​ 上述代码及执行结果展示了按位与-&amp;、按位或-|、左移位-&lt;&lt;操作符的使用方法。这些操作符只有当你跟底层硬件打交道时才会用得到。 ​ 所谓按位与，即是把原始比特值做逻辑与运算，1看作真，0看作假，结果也用1或0表示： ​ 1 &amp; 1 = 1; 1 &amp; 0 = 0; 0 &amp; 0 = 0。 ​ 按位或即是把原始比特值做逻辑或运算。左移位&lt;&lt;操作符则是把全部比特向左移指定位数，右边补0。除此之外，还有按位取反~，按位异或^，右移位&gt;&gt;等操作符，各位等到用时再查资料即可。 序列​ 列表-list、字符串-str、元组-tuple、bytes、bytearray都可视作序列类型。共同点在于： 可以通过下标或索引访问其元素（只读类型只可获取，不得修改）； 可通过切片操作获取其子序列。 作为序列类型，上述类型的使用方法有很多相通之处。 名字绑定​ 在第4章，我们已经见识了将一个列表从一个变量赋值给另一个变量后的令人疑惑的操作结果： 12345person1 = ['10000', 'Jack Ma', 'male', 47, 'CEO']person2 = person1person2[1] = \"Tom Henry\"print(person1)print(person2) 执行结果: 12[&#39;10000&#39;, &#39;Tom Henry&#39;, &#39;male&#39;, 47, &#39;CEO&#39;][&#39;10000&#39;, &#39;Tom Henry&#39;, &#39;male&#39;, 47, &#39;CEO&#39;] ​ 看起来，似乎person2和person1指向的是同一个列表实体。因为person2被修改后，person1也跟着改变了。初学者很容易感到疑惑，本章试图从原理层面讲清楚这个重要的问题。 再看a=112345678a = 1print(\"id:\",id(a))a = 2print(\"id:\",id(a))b = aprint(\"id of a:\", id(a), \"id of b:\",id(b))a += 1print(\"id:\",id(a)) 执行结果： 1234id: 140720188347424id: 140720188347456id of a: 140720188347456 id of b: 140720188347456id: 140720188347488 ​ id()函数返回对象在Python解释器内部的编号，每一个对象都是一个唯一的id号，你可以把id号想象成该对象在内存中的地址。可以看到，a每经过一次赋值，其id号是不同的。 ​ 之前，我们是这样描述a = 1的： a是一个变量/对象，赋值操作符=把类型为整数的对象1传递给了变量/对象a，赋值之后a是一个类型为整数的变量/对象，其值为1。这种描述方法是传统习惯，目的是方便你在课程前期能够看懂，但这不是事实。 名字、对象及绑定 a = 1执行结果： - 值1是一个对象-object，它有内存地址(id号)；- a只是一个名字-name，所谓赋值，就是把这个名字绑定在相应的对象上。 同理，a = 2被执行时， 解释器会将名字a绑定在值为2的整数对象上。由于2是一个跟1不同的对象，所以id(a)会返回不同的地址。如下图： a = 2执行结果： ​ 请注意，此时，值为1的对象此时仍然存在，但没有名字与其绑定。事实上，对象内部会有专门的引用计数来表明这个对象当前与多少个名字绑定，当对象的引用计数下降到0后，Python解释器会在恰当的时候从内存中销毁这个对象，这个机制称为“垃圾回收”。 b = a执行结果： - 如图：b = a中的赋值并没有创建新对象; - 赋值操作只是简单地把名字b也绑定到名字a绑定的对象上; - 由于a,b都绑定了同一个对象，所以id(a)与 id(b)的值相同。 ​ Python的这种操作方式有其合理之处，特别是对于那些体量比较大的对象，比如列表，赋值时不创建复制品而是简单地执行名字绑定，可以快速地完成形式上的赋值。大多数情况下，这没有什么问题。如上例，虽然名字a和名字b被绑在了同一个值为2的对象上，但无论是通过名字a还是名字b取值，都可得到2；当其中一个名字，比如b被赋以不同的新值时，名字b又会被绑定到别的对象上，名字a不受影响。 ​ 同理，a += 1 等价于 a = a + 1, 通过计算后，解释器把名字a绑定在了值为3的另一个对象上，所以我们又看到了新的不同的id(a)值。 ​ 需要注意的是，Python解释器可能会出于执行速度优化的考虑，倾向于将名字尽可能绑定在系统已有的对象上，而不是创建新对象。 1234a = 3b = int(a ** 2 / 3)print(a,b)print(id(a),id(b)) 执行结果: 123 3140720185398368 140720185398368 ​ a被赋值为3, b也被赋值为计算出来的结果3，与预期的不一样，a和b并没有并绑定到两个不同的值为3的整数对象，而是被绑定到同一个值为3的整数对象。作者相信这是某种形式的解释器优化的结果，解释器试图尽可能快地执行代码。 is 和 ==12345a = 3b = 3.0print(\"a==b:\",a==b)print(\"a is b:\",a is b)print(id(a),id(b)) 执行结果： 123a&#x3D;&#x3D;b: Truea is b: False140720188347488 2675211874712 ​ 每个名字所绑定的对象都至少包括三个属性：id-就是对象的内存地址；type-类型；value-对象的值。a is b将a的id与b的id作比较，只有两者相同时才返回True，这里显然a,b没有绑定到同一个对象，所以a is b返回False；a == b将两个对象的值进行比较，3等于3.0，故返回True。在实践中，为了避免不必要的麻烦，建议尽量使用==而不是is。 只读数据类型​ 下表列出了我们已经讨论过的全部数据类型： 只读数据类型 可修改数据类型 整数-int, 浮点数-float，字符串str，布尔-bool, 二进制字节流-bytes,元组-tuple 列表-list, 二进制字节数组-bytearray ​ 对于只读类型，编程者完全可以忽略名字绑定这件事，任何赋值操作的最终结果都会跟你的期望一致。 123456789values = (3,2,1)valuesCopy = valuesvaluesCopy = (1,2,3)print(values, \"-\", valuesCopy)string = \"string\"stringCopy = stringstringCopy = \"new string\"print(string, \"-\", stringCopy) 执行结果： 12(3, 2, 1) - (1, 2, 3)string - new string ​ 可以看到，上述代码中，valuesCopy与values, stringCopy与string都曾经同时绑定到同一个只读类型对象，由于对象是只读的，所以对象无法修改，任何对valuesCopy, stringCopy的赋值都将创建一个新对象，values，string名字绑定的原有对象不受影响。 可修改数据类型​ 终于到了可以解决疑惑的时间了。列表-list, 二进制字节数组-bytearray属于可修改数据类型，当列表、bytearray被赋值给多个名字时，可能会导致意料之外的结果，需要十分小心。 12345person1 = ['10000', 'Jack Ma', 'male', 47, 'CEO']person2 = person1person2[1] = \"Tom Henry\"print(person1)print(person2) 执行结果: 12[&#39;10000&#39;, &#39;Tom Henry&#39;, &#39;male&#39;, 47, &#39;CEO&#39;][&#39;10000&#39;, &#39;Tom Henry&#39;, &#39;male&#39;, 47, &#39;CEO&#39;] ​ 请注意，第2行person2 = person1之后，两个名字事实上绑定到了同一个列表对象。由于列表是可修改类型，对person2的修改事实上是对person1和person2共同绑定的同一个对象的修改。所以，修改完成后，person1和person2打印出来的值相同。事实上，如果打印一下id(person1)和id(person2)，结果肯定是一样的。 ​ 大多数情况下，两个名字绑定同一个列表对象并没有什么不好，比如，当一个列表作为函数实参传递给形参时，这种名字绑定的方法可以非常快地完成形式上的参数传递，执行效率非常高。但如果你在函数内部修改了列表的元素值，外面那个名字所绑定的列表也会跟着改变（事实上就是同一个），这可能不是你所期望的。为了避免这种情况的发生，可以借助于列表的copy()成员函数制造一个完全独立的副本，也可以借助列表的切片,比如 person1[:]来产生一个全新的副本。还可以借助于copy模块的copy()及deepcopy()函数来完成对象复制。下面的代码展示了这些方法在bytearray和list上的应用。 12345678910111213import copychars = bytearray(b'abcdefghijklmn')charsCopy = chars.copy()charsCopy2 = chars[:]print(id(chars),\"-\",id(charsCopy),\"-\",id(charsCopy2))numbers = [0,1,2,3,4,5,6,7]numbersCopy = numbers.copy()numbersCopy2 = numbers[:]numbersCopy3 = copy.copy(numbers)numbersCopy4 = copy.deepcopy(numbers)print(id(numbers),\"-\",id(numbersCopy),\"-\",id(numbersCopy2), \"-\",id(numbersCopy3),\"-\",id(numbersCopy4)) 执行结果： 122090502934232 - 2090502931208 - 20905029509602090503871624 - 2090503792584 - 2090503872008 - 2090503871560 - 2090503871880 ​ 可以看到，上述名字对应对象的id值均不相同，是相互独立的对象和名字。 ​ 当列表有嵌套时，copy()和deepcopy()是有差异的。copy()只会复制列表本身，复制出来的列表(设名为b)与原列表(设名为a)的相同元素位仍可能绑定在一个相同的子列表对象上，此时，修改a的这个子列表事实上就是修改b的同一个子列表。deepcopy()会将列表及其嵌套列表完整复制，以避免上述情况。 123456a = [1,2,3,[3,2,1]]b = a.copy()print(id(a),id(b))print(id(a[3]),id(b[3]))b[3][2] = 99print(a,b) 执行结果： 1231989546107528 19895466019281989546107464 1989546107464[1, 2, 3, [3, 2, 99]] [1, 2, 3, [3, 2, 99]] ​ 可以看出，通过浅拷贝copy()后，a,b绑定的是两个独立的列表对象。但由于列表有子列表[3,2,1]，两个列表对象的下标3位置仍然绑定了同一个子列表对象，这从id(a[3])和id(b[3])的值可以看出来。些时，修改b[3]的元素值事实上就是在修改a[3]的对应元素值。借助于b = copy.deepcopy(a)，不光列表会被复制，子列表以及子列表的子列表也会被复制，这样b与a之间不再有任何联系。 1234567import copya = [1,2,3,[3,2,1]]b = copy.deepcopy(a)print(id(a),id(b))print(id(a[3]),id(b[3]))b[3][2] = 99print(a,b) 执行结果： 1231723423500488 17234234992721723423628168 1723423628488[1, 2, 3, [3, 2, 1]] [1, 2, 3, [3, 2, 99]] ​ 列表的任意元素位置也可以看作是一个名字，它同具体的对象相绑定。 ​ 虽然我们已经了解了名字、对象、绑定这些背后的秘密，但本书的后续部分，我们有时仍将沿用变量、赋值这些术语，因为习惯。 本文内容节选自作者编著的《Python编程基础及应用》（高等教育出版社）一书。 免费随书B站MOOC:","categories":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/tags/Python/"},{"name":"名字绑定","slug":"名字绑定","permalink":"http://codelearn.club/tags/%E5%90%8D%E5%AD%97%E7%BB%91%E5%AE%9A/"}]},{"title":"使用numpy进行9宫格图像拼接","slug":"imagesconcatenate","date":"2019-01-20T03:35:04.000Z","updated":"2020-09-11T06:21:13.342Z","comments":true,"path":"2019/01/imagesconcatenate/","link":"","permalink":"http://codelearn.club/2019/01/imagesconcatenate/","excerpt":"本节内容要用到opencv-python模块，请先行安装。本例程中使用到的图片保存在pictures子目录下。本例的任务是要将9张JPG格式图片按三行三列拼接成下述九宫格。","text":"本节内容要用到opencv-python模块，请先行安装。本例程中使用到的图片保存在pictures子目录下。本例的任务是要将9张JPG格式图片按三行三列拼接成下述九宫格。 版权声明 本文可以在互联网上自由转载，但必须：注明出处(作者：海洋饼干叔叔)并包含指向本页面的链接。 本文不可以以纸质出版为目的进行改编、摘抄。 微实践：九宫格图像拼接本节内容要用到opencv-python模块，请先行安装。本例程中使用到的图片保存在pictures子目录下。本例的任务是要将9张JPG格式图片按三行三列拼接成下述九宫格。 12345678910111213#pictures9.pyimport globimport numpy as npfrom cv2 import imread,imwrite #cv2来自OpenCV-Python扩展库imgs,heights,widths = [],[],[]for f in glob.glob(\"pictures/*.jpg\"): img = imread(f,-1) print(\"original:\",img.shape) h,w = img.shape[:2] heights.append(h) widths.append(w) imgs.append(img) 控制台输出: 12345original: (960, 1280, 3)...original: (793, 1280, 3)...original: (960, 1280, 3) glob.glob(“pictures/*.jpg”)返回一个序列，该序列包括当前目录之pictures子目录下的所有扩展名为jpg的图片文件的文件名(含路径)。读者可以在上述循环中加上print(f)把这些文件名打出来看看。 imread()函数来自opencv-python扩展库，它读取一个图片，并返回一个多维数组。我们打印了这些多维数组的形状，典型如(960,1280,3)：它表示对应图片高960个像素，宽1280个像素，每个像素由3个值构成，分别表示该像素红、绿、蓝三个通道的颜色值。请读者注意，本例中的9张图片的高度值并不相等。 img.shape[:2]取出了图像/多维数组的高度和宽度，分别赋值给h和w。所有的图片高、宽均存入heights、widths列表备用。所有的图片/多维数组均存入imgs列表备用。 显然，(960,1280)的图片尺寸对于九宫格拼接而言太大了，需要分别提取缩略图。 123456789101112#pictures9.py#制作缩略图，纵横向每3个像素抽一个minHeight = min(heights)minWidth = min(widths)for i,x in enumerate(imgs): imgs[i] = x[:minHeight:3,:minWidth:3,:] print(\"thumbnail:\",imgs[i].shape)#横向沿轴1拼接img = np.concatenate(imgs,1)print(\"concatenated by axis1:\",img.shape)imwrite(\"concatenated_1.jpg\",img) 控制台输出： 1234thumbnail: (265, 427, 3)...thumbnail: (265, 427, 3)concatenated by axis1: (265, 3843, 3) 我们首先获得了全部图像的最小高度 - min(heights)和最小宽度 - min(widths)。然后，遍历并逐一使用多维数组的切片下标语法提取缩略图：横纵向都从每3个像素中抽1个像素。根据打印出来的值，我们可以看到，所有的缩略图都是265 x 427个像素。 接下来，我们使用np.concatenate()函数将imgs列表中的9张图沿1轴拼接（横向拼接）至img。根据打印的结果，横向拼接后的图片尺寸为265 x 3843。imwrite()则将img存至文件”concatenated_1.jpg”。读者可以在项目目录中找到这个照片，如下： 下述代码及其执行结果可以帮助读者理解concatenate()函数的作用：可以看到，对于二维数组而言，沿0轴拼接相当于纵向延长数组，沿1轴拼接则相当于横向延长数组。 123456789101112#con.pyimport numpy as npa = np.array([[1,2],[3,4]])b = np.array([[11,22],[33,44]])print(\"a=\\n\",a)print(\"b=\\n\",b)c = np.concatenate([a,b],0) #沿0轴拼接，纵向延长print(\"np.concatenate([a,b],0)=\\n\",c)c = np.concatenate([a,b],1) #沿1轴拼接，横向延长print(\"np.concatenate([a,b],1)=\\n\",c) 执行结果： 1234567891011121314a&#x3D; [[1 2] [3 4]]b&#x3D; [[11 22] [33 44]]np.concatenate([a,b],0)&#x3D; [[ 1 2] [ 3 4] [11 22] [33 44]]np.concatenate([a,b],1)&#x3D; [[ 1 2 11 22] [ 3 4 33 44]] 借助于concatenate()函数，我们可以先将图片0-2横向拼接，再将图片3-5横向拼接，接着再将图片6-8横向拼接。最后再将拼接结果纵向拼接，即得3x3的九宫格： 12345678#pictures9.py#方法1img0 = np.concatenate(imgs[:3],1) #沿1轴横向拼接img1 = np.concatenate(imgs[3:6],1)img2 = np.concatenate(imgs[6:],1)img9 = np.concatenate([img0,img1,img2],0) #沿0轴纵向拼接print(\"3x3_0, shape:\",img9.shape)imwrite(\"3x3_0.jpg\",img9) 控制台输出： 13x3_0, shape: (795, 1281, 3) 上述3x3_0.jpg应该与本例开始处的图片相同，该文件也存入了当前项目目录，读者自行查证。除了上面这个方法外，下面这个方法也可以达到相同的效果，但真的很难理解。在下述代码中，img1.swapaxes(1,2)将img1的1轴与2轴进行了交换。 123456#方法2img = np.concatenate(imgs,0) #将9图沿0轴纵向拼img1 = img.reshape(3,3,265,427,3) #改变形状至5维数组img9 = img1.swapaxes(1,2).reshape(795,1281,3) #1轴和2轴交换，再改变形状print(\"3x3_1, shape:\",img9.shape)imwrite(\"3x3_1.jpg\",img9) 控制台输出： 13x3_1, shape: (795, 1281, 3) 读者可以查证3x3_1.jpg的最终效果。 读者可以试着执行下述代码来观察轴交换的效果： 12345678910#swapaxes.pyimport numpy as npa = np.array([[1,2],[3,4]])print(\"a=\\n\",a)print(\"a.swapaxes(0,1):\\n\",a.swapaxes(0,1))b = np.array([[1,2,3,4],[5,6,7,8]])print(\"b=\\n\",b)print(\"b.reshape(2,2,2)=\\n\",b.reshape(2,2,2))print(\"b.reshape(2,2,2).swapaxes(1,2))=\\n\",b.reshape(2,2,2).swapaxes(1,2)) ​ 与多维数组操作有关的函数列表如下： 函数名 作用 函数名 作用 concatenate() 拼接多个数组 vstack/hstack() 沿0/1轴拼接数组 column_stack() 按列连接多个一维数组 split,array_split() 将数组分为多段 transpose() 重设轴的顺序 swapaxes() 交换两个轴的顺序 本文内容节选自作者编著的《Python编程基础及应用》（高等教育出版社）一书。 免费随书B站MOOC:","categories":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/categories/Python/"},{"name":"图像处理","slug":"Python/图像处理","permalink":"http://codelearn.club/categories/Python/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/tags/Python/"},{"name":"numpy","slug":"numpy","permalink":"http://codelearn.club/tags/numpy/"},{"name":"图像处理","slug":"图像处理","permalink":"http://codelearn.club/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"},{"name":"OpenCV","slug":"OpenCV","permalink":"http://codelearn.club/tags/OpenCV/"}]},{"title":"Python, Cython绘制美妙绝伦的Mandelbrot集, 曼德博集分形图案","slug":"python-mandelbrot","date":"2019-01-19T15:48:13.000Z","updated":"2020-09-11T06:26:50.537Z","comments":true,"path":"2019/01/python-mandelbrot/","link":"","permalink":"http://codelearn.club/2019/01/python-mandelbrot/","excerpt":"上世纪60-70年代，美籍数学家曼德博 - Benoit B. Mandelbrot几乎单枪匹马的创立了一个新的数学分支，即分形几何学 - fractal geometry。这个新的数学分支有助于人类探索物理现象背后的数学规律，分形混沌之旋风，横扫数学、理化、生物、大气、海洋以至社会学科，在音乐、美术领域也产生了一定的影响。","text":"上世纪60-70年代，美籍数学家曼德博 - Benoit B. Mandelbrot几乎单枪匹马的创立了一个新的数学分支，即分形几何学 - fractal geometry。这个新的数学分支有助于人类探索物理现象背后的数学规律，分形混沌之旋风，横扫数学、理化、生物、大气、海洋以至社会学科，在音乐、美术领域也产生了一定的影响。 分形艺术 - fractal art不同于普通的电脑绘画，它利用分形几何学和计算机强大的运算能力，将数学公式反复迭代运算，再结合作者的审美及艺术性的塑造，从而将抽象神秘的数学公式变成一幅幅精美绝伦的艺术画作。 版权声明 本文可以在互联网上自由转载，但必须：注明出处(作者：海洋饼干叔叔)并包含指向本页面的链接。 本文不可以以纸质出版为目的进行改编、摘抄。 本文配套在线视频： https://www.bilibili.com/video/av34409478/?p=45 1. Mandelbrot集1.1 定义​ 说明：阅读Mandelbrot集相关内容需要一点复数及复平面的知识，缺乏相关背景知识的读者可以略过，不影响后续内容的理解。 ​ Mandelbrot(曼德布洛特)集是在复平面上构成分形图案的点的集合。它可以用下述复二次多项式定义：$$f_{c}(z)=z^{2}+c$$​ 这里的c = x + yi是一个复数，如果把实部x和虚部y视为复平面上的横纵坐标的话，那么c对应该复平面上的一个点。从z=0开始，反复应用上述二次多项式进行迭代计算，z值将不断变化，其或者延伸至无限大，或者停留在有限半径的圆内部。如果是后者，我们称参数c导致了不发散的迭代z序列，此时，c点属于Mandelbrot集合，否则不属于。 1.2 计算​ 计算机显然没有办法进行无穷尽的计算才确认c所导致的迭代z值是否发散，所以我们简单地计算c点的逃逸时间 - 也就是经过多少轮迭代计算，z值的模超过2。在绘图过程中，该逃逸时间将作为c点在平面上的颜色。 12345678def getEscapeTime(c): \"计算参数c的逃逸时间，该逃逸时间将用作点的颜色\" z = 0 for i in range(100): if abs(z) &gt; 2: return i z = z*z + c return i ​ 如代码所示，abs(z)用于计算复数的模，在该代码中，逃逸时间最大为100-1 = 99。同时，应注意到，Python原生支持复数运算，z*z + c就是在复数之间的运算，其代码与普通实数间的运算没有什么不同。 ​ 接下来，就可以计算Mandelbrot集合了。广义的Mandelbrot集合是个无穷大的复平面，显然，我们只可能画其中一小块。下述代码计算以(xCenter,yCenter)为中心点，semiWidth为半宽的正方形区域内的Mandelbrot集。这个正方形区域x坐标范围为xCenter±semiWidth，y坐标范围为yCenter±semiWidth。考虑到计算机只能计算离散点，所以该正方形区域将被分成N*N个点进行计算。当N=600时，下述函数的结果矩阵就是一个600x600的图像，矩形元素值代表该点的颜色。 12345678import numpy as npdef computeMandelbrot(xCenter,yCenter,semiWidth,N): xFrom,xTo,yFrom,yTo = xCenter-semiWidth,xCenter+semiWidth,\\ yCenter-semiWidth,yCenter+semiWidth y,x = np.ogrid[yFrom:yTo:N*1j,xFrom:xTo:N*1j] c = x + y*1j print(\"c.shape:\",c.shape,\"x.shape:\",x.shape,\"y.shape:\",y.shape) return np.frompyfunc(getEscapeTime,1,1)(c).astype(np.float) ​ 上述代码的理解并不容易，需要先从多维数据np.ndarray的广播运算开始。对于复杂的问题，做一点小规模的模拟运算可以帮助理解。 123456import numpy as npy,x = np.ogrid[1:4:4j,1:3:3j]print(\"y=\")print(y)print(\"x=\",x)print(\"shape of y:\",y.shape,\"shape of x:\",x.shape) 执行如果如下： 1234567y&#x3D;[[1.] [2.] [3.] [4.]]x&#x3D; [[1. 2. 3.]]shape of y: (4, 1) shape of x: (1, 3) ​ np.ogrid是一个特殊对象，它使用切片元组作为下标，专门用于生成用来广播的数组。1:4:4j有点类似于np.linspace(1,4,4)，用于生成从1到4（含4）的有4个元素的等差数列，这里的j并不表示复数，只是一种表达形式。可以看到，ogrid生成的y是一个4行1列的二维数组，x则是一个1行3列的二维数组。其值见上。 12z = y*1jprint(\"z = y*1j =\",z) 执行结果： 1234z &#x3D; y*1j &#x3D; [[0.+1.j] [0.+2.j] [0.+3.j] [0.+4.j]] ​ y*1j是把复数1j同y里的每一个元素相乘，并返回相同形状（维度)的数组。由于numpy模块并不是Python的原生内容，所以这里的*号并不是普通意义的Python乘法，它事实上是一个被重载的操作符函数，这个函数位于numpy模块，是用C语言书写的。可见，y*1j的结果元素的实部全是0，虚部则等于原元素值乘以1j。 ​ 再来看看x + z会得到什么，注意这里的z就是y*1j的结果。 123c = x + zprint(c)print(\"shape of c:\",c.shape) 执行结果： 12345[[1.+1.j 2.+1.j 3.+1.j] [1.+2.j 2.+2.j 3.+2.j] [1.+3.j 2.+3.j 3.+3.j] [1.+4.j 2.+4.j 3.+4.j]]shape of c: (4, 3) ​ x是一个1行3列的二维数组，z = y*1j是一个4行1列的二维数组。两者相加事实上也是实际的被重载的numpy模块内的操作符函数，该函数将两个数组的对应元素相加。问题来了，两个数组的形状/维度不同，如何确定元素间的对应性呢？ numpy进行了所谓“广播”运算，结果数组c将取x,z的各轴的最大值，其结果维度为(4,3)也就是4行3列。对于c的各个元素，比如c[3][2]为例，其值应等于x[3][2] + z[3][2]，由于x[3][2]并不存在，广播规则取x[0][2] = 3代替；同样地，z[3][2]也不存在，广播规则取z[3][0] = 0. + 4.j代替；所以，c[3][2] = 3 + 0. + 4.j = 3. + 4.j。请注意，结果元素的实部来自于x数组，虚部来自于z数组，也就是y*1j的结果数组。 ​ 这里所述的“广播规则”是指当输入数组的某个轴的长度为1时，取值时均取该轴的下标0值。比如x[3][2]，由于x数组的0轴长度为1，故x[3][2]的0轴下标改取0，即x[0][2]。 ​ 请读者再次观察c数组内的复数，把它看作一幅图像，从上向下，虚部的值在等差递增；从左向右，实部的值在等差递增。 1234xFrom,xTo,yFrom,yTo = xCenter-semiWidth,xCenter+semiWidth,\\ yCenter-semiWidth,yCenter+semiWidthy,x = np.ogrid[yFrom:yTo:N*1j,xFrom:xTo:N*1j]c = x + y*1j ​ 现在这段程序容易理解了，它使用与上述解读过程相同的方法把以(xCenter,yCenter)为中心点，semiWidth为半径的复平面正方形区域等分成了N行N列，多维数组c的维度即为(N,N)。c中的元素为复数，其实部在xFrom至xTo之间等差横向变化，其虚部在yFrom至yTo间等差纵向变化。 ​ 再来看函数最后一行代码： 1return np.frompyfunc(getEscapeTime,1,1)(c).astype(np.float) ​ getEscapeTime(c)是之前已经定义好的一个Python语言函数，它接受一个复数参数c并计算返回这个复数参数对应的逃逸时间。np.frompyfunc()函数将二维数组c中的复数元素逐一交给getEscapeTime()进行计算，得到一个与c形状相同的结果数组。c里有多少个元素，getEscapeTime()函数就会执行多少次。执行这个结果数组的astype函数将结果数组中的元素全部转换成np.float类型。上述参数1,1表示getEscapeTime()函数接受1个参数，返回1个结果元素。 ​ 综上，computeMandelbrot()函数最后返回了一个N行N列的二维数组，数组元素为np.float类型，表明了该点的逃逸时间；而元素所在的行列编号则间接表示了元素点在结果图像/复平面中的坐标。 1.3 绘图​ 我们使用matplotlib绘制了Mandelbrot集的局部。左图的中心点c = 0.27322626 + 0.595153338j, 正方形半宽为0.2；右图的中心点与左图相同，半宽为0.23，相当于把左图放大了25倍。 ​ 接下来分析代码。 123456789101112131415from matplotlib import cm...def drawMandelbrot(ax,xCenter,yCenter,semiWidth,N,cmap): \"(xCenter,yCenter)-中心点，semiWidth-矩形半宽，N*N像素.\" ax.set_axis_off() ds = computeMandelbrot(xCenter,yCenter,semiWidth,N) ax.imshow(ds,cmap=cmap) #在子图-ax上绘制图像，ds是计算而得的二维数组，其元素为逃逸时间def refresh(): c = cm.get_cmap(para.cmaps[para.idxColorMap%len(para.cmaps)]) drawMandelbrot(para.ax0, para.x, para.y, semiWidth=0.2, N=600,cmap=c) drawMandelbrot(para.ax1, para.x, para.y, semiWidth=0.2 ** 3, N=600,cmap=c) para.fig.canvas.draw() #要求图-Fig重绘 ​ pyplot中的图称为figure，图内包含一个或者多个子图-axes。drawMandelbrot()函数负责在子图上计算并画出Mandelbrot集图像。ax.set_axis_off()隐藏了子图的坐标，然后计算得到N*N像素的结果图像数组ds，接着使用ax.imshow()函数将ds在子图上画出来。该函数将ds二维数据视为一幅二维图像，ds内的每一个元素则对应图像中的一个像素点。imshow()函数内的cmap函数对应一个颜色映射对象，该对象负责把元素的值（就是复数c的逃逸时间）转换成对应的颜色。 ​ refresh()函数则两次调用drawMandelbrot()函数画出左子图-ax0和右子图-ax1。注意，两次绘图的中心点坐标是一样的，区别是半宽不同，一个是0.2，一个是0.23。matplotlib中的cm负责管理颜色映射对象，通过cm.get_cmap()函数可以通过字符串类型的名称比如’rainbow’获得对应的颜色映射对象。para.fig.canvas.draw()函数则通知图/fig重绘。这里，我们看到一个名为para的对象，下述代码做出了解释。 12345678910111213141516171819202122232425262728from matplotlib import pyplot as plt...#操作者通过按上下箭头改变图像描绘颜色def on_key_release(event): #按键松开勾子函数 if event.key == 'up': para.idxColorMap+=1 elif event.key == 'down': para.idxColorMap-=1 else: return refresh()class Para: #一个仅有名字的Para类用于存储全局参数 passpara = Para()para.x, para.y = 0.27322626, 0.595153338para.idxColorMap = 0para.cmaps = ['flag', 'prism', 'ocean', 'gist_earth', 'terrain', 'gist_stern', 'gnuplot', 'gnuplot2', 'CMRmap', 'cubehelix', 'brg','gist_rainbow', 'rainbow', 'jet', 'nipy_spectral', 'gist_ncar']para.fig = plt.figure(figsize=(12,6),dpi=100)para.fig.canvas.mpl_connect('key_release_event',on_key_release)plt.subplots_adjust(0,0,1,1,0.0,0)para.ax0 = plt.subplot(121)para.ax1 = plt.subplot(122)refresh()plt.show() ​ 考虑到阅读本章的读者可能并不具备面向对象程序设计的知识背景，所以本章尽量避免自定义类。但作者又非常不喜欢数量过多的全局变量。作者定义了一个仅有名字的Para类并实例化了一个para对象，其中将存储那里跨函数被使用的“全局”变量。这样，理论上，全部变量只有一个，那就是para。 ​ plt.figure()函数创建了一个长12英寸，宽6英寸的图-figure，注意dpi/每英寸点数被设定为100，这意味着图长1200像素，宽600像素。 ​ para.fig.canvas.mpl_connect()函数将按键弹起事件与on_key_release()函数相关联，即图-figure处于活动状态时，操作者按下一个键并松开时，on_key_release(event)函数将被执行，event参数包括了事件的相关信息：比如事件的类型，哪个键被松开等等。这个on_key_release()函数与特定事件相绑定，俗称“勾子函数” - hook function。 ​ plt.subplots_adjust()函数调整了子图间的间距和边距，使得整个显示窗口被充分利用。 ​ plt.subplot(121)在当前图-figure对象内创建了一个子图-axes，并存于para.ax0。121参数被该函数以非常特别的方式处理，它表示将当前图的可见区域分成1行2列，在其中1号位置创建一个子图，即结果中的左子图。同理，plt.subplot(122)将当前图的可见区域分成1行2列，在其中2号位置创建一个子图，即结果中的右子图。 ​ refresh()函数将计算并画出两个子图。plt.show()则把窗口显示出来。 ​ 接下来，我们研究一下勾子函数on_key_release(event)。这个函数使得操作者按上下箭头可以改变当前图像颜色并重绘。para.cmaps列表存储了一系列可用的映射对象的名称，para.idxColorMap则记录了当前使用的映射对象在para.cmaps列表中的下标。on_key_release(event)函数判断event对应的按键类型，如果是up，para.idxColorMap+1，如果是down, para.idxColorMap-1。on_key_release()函数通过调用refresh()函数再实现图的重绘，在refresh函数内部，para.idxColorMap以len(para.cmaps)取模后再使用。这是因为，para.idxColorMap的加减没有进行越界检查，para.idxColorMap可能为负数，也可能为超过para.cmaps长度的正数，取模可以保证获得合法的下标。 ​ 需要提醒读者的是，一幅子图有600*600 = 36万个像素，两幅子图有72万个像素。每个像素的计算都会调用一次getEscapeTime()函数，而这个函数是Python语言写的，并且里面要进行不超过100次的循环运算，执行速度很慢。所以读者运行出界面后，按上下箭头时不要太心急，按一下后要等刷新结束再按下一次。 2. Cython加速Mandelbrot集​ 用纯Python语言写就的Mandelbrot集绘图程序速度太慢了！ 但Python是所谓的胶水语言，可以很方便地通过C或者其它语言来书写扩展库，numpy, scipy, matploblib都是这些扩展库的杰出代表。 ​ 至少有两个途径可以加速Mandelbrot集的计算速度。方法1是直接用C语言书写计算逃逸时间的函数，然后使用mingw、g++或者Visual C++编译器将其编译成目标模块，然后在Python语言里调用。这非常麻烦，因为函数的参数需要手工解析，还需要记忆和使用大量的Python API。 ​ 方法2则是Cython。Cython在语法上基本与Python相同，同时又允许直接定义和调用C语言函数、定义变量类型等功能。Cython的编译器会把Cython的源程序编译成C语言程序，再经由C语言编译器编译成Python模块。由于Python解释器本身也是由C语言写就，并经由C语言编译器编译的，所以Cython里可以很方便地访问Python类型对象。 2.1 环境准备​ 世界发展得太快，当读者阅读本书时，下述信息或许已经过时。 ​ 作者使用的是Windows 10环境下的64位的Python3.7解释器， 所以作者安装了微软的Visual Studio社区版的”使用C++的桌面开发”部分，其中包括了VC 2017 version 15.9 v14.16以及相关的Windows SDK。该软件可以从 https://visualstudio.microsoft.com 获得。请注意，Visual Studio是一个非常宠大的IDE软件，除上述必要部分之外的请不要选择，否则非常耗时而且占据硬盘空间。 ​ 如果读者使用的是Linux, 则系统自带的gcc编译通常足够使用。Linux下Cython代码的编译过程与下述过程相当，但细节或有区别。 ​ 读者还需要安装Cython模块，在Windows命令行或者Linux终端中运行pip install cython即可。 2.2 重写逃逸时间计算函数​ 在PyCharm中新建一个文件(New-&gt;File)，命名为MandelbrotComp.pyx。其内为Cython代码： 123456789def getEscapeTime(complex c): &quot;计算参数c的逃逸时间，该逃逸速度将用作点的颜色&quot; cdef complex z &#x3D; 0 cdef int i for i in range(255): if z.real * z.real + z.imag*z.imag &gt; 4: return i z &#x3D; z*z + c return i ​ 可以看到，上述代码与之前纯Python写的getEscapeTime()函数主要有如下的不同： ​ 首先，所有的变量/对象都有类型声明，大部分通过cdef关键字定义。c,z的类型为complex，i的类型为int。强类型是C/C++的特点，也是C/C++可以编译出高效机器码的必要条件。 ​ 第二，我们没有再使用abs来计算复数z的模，这可能有两个原因：1). 原生C语言没有用于复数求模的abs()函数，沿用abs()函数很可能会导致该模块再次内部调用Python的abs()函数；2). 复数的求模运算需要求平方根，而平方根的求解运算代价较高。而且，平方根的求解在此处是不必要的，我们直接求z的实部和虚部的平方之和，再比较其是否大于4事实上等价于比较z的模是否大于2。 2.3 编译为扩展模块​ 按照Cython文档的建议，我们准备了一个setup.py文件，其内容如下： 12345from distutils.core import setupfrom Cython.Build import cythonizesetup(name='Mandelbrot Computation', ext_modules=cythonize(\"MandelbrotComp.pyx\")) 请注意，setup.py与MandelbrotComp.pyx以及预期使用该扩展块的Mandelbrot绘图程序均在同一目录下。然后通过Windows开始菜单进入”适用于VS 2017的x64本机工具命令提示”，通过cd命令切换至setup.py及MandelbrotComp.pyx所在目录。再执行python setup.py build_ext –inplace命令。 ​ 如下图所示，需要说明的是，下图事实上是个黑黑的终端界面，cd等命令可以追溯到40年前的DOS操作系统，也就是Windows操作系统的前身。该命令提示界面与普通Windows命令行的主要区别在于通过执行vcvarsall.bat批处理命令， 该界面内对环境变量Path进行了临时设置，以确保VC编译器-cl.exe，以及相关的C语言头文件，库文件可以被找到。读者不要在普通的Windows命令行下做下述工作，setup.py会报告找不到编译器或者C语言头文件。 1234567891011121314适用于VS2017的x64本机工具命令提示************************************************************************ Visual Studio 2017 Developer Command Prompt v15.9.4** Copyright (c) 2017 Microsoft Corporation**********************************************************************[vcvarsall.bat] Environment initialized for: &#39;x64&#39;C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community&gt;d:D:\\&gt;cd PythonD:\\Python&gt;cd MathBeautyD:\\Python\\MathBeauty&gt;python setup.py build_ext --inplace ​ 一切顺利的话，上述命令将报告“已完成代码的生成”。此时，可以在PyCharm里看到代码目录下多出来两个文件，其中一个名为MandelbrotComp.c。这是由Cython编译MandelbrotComp.pyx生成的C语言程序，作者抄出来一个小片段： 12345678910111213for (__pyx_t_1 = 0; __pyx_t_1 &lt; 0x64; __pyx_t_1+=1) &#123; __pyx_v_i = __pyx_t_1; __pyx_t_2 = ((((__Pyx_CREAL(__pyx_v_z) * __Pyx_CREAL(__pyx_v_z)) + (__Pyx_CIMAG(__pyx_v_z) * __Pyx_CIMAG(__pyx_v_z))) &gt; 4.0) != 0); if (__pyx_t_2) &#123; __Pyx_XDECREF(__pyx_r); __pyx_t_3 = __Pyx_PyInt_From_int(__pyx_v_i); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 7, __pyx_L1_error) __Pyx_GOTREF(__pyx_t_3); __pyx_r = __pyx_t_3; __pyx_t_3 = 0; goto __pyx_L0; &#125; __pyx_v_z = __Pyx_c_sum_double(__Pyx_c_prod_double(__pyx_v_z, __pyx_v_z), __pyx_v_c);&#125; ​ 由于是机器“写”出来的C代码，特别难理解。作者找到了那个从0到100(不含100)的循环，0x64是十六进制，它就是十进制的100。 ​ 另外一个生成出来的文件名为MandelbrotComp.cp37-win_amd64.pyd。读者的Python版本或者操作系统如果与作者的不同，该名称或有差异。这个文件就是编译好的Python扩展模块。 2.4 调用扩展模块123456789from MandelbrotComp import getEscapeTimedef computeMandelbrot(xCenter,yCenter,semiWidth,N): xFrom,xTo,yFrom,yTo = xCenter-semiWidth,xCenter+semiWidth,\\ yCenter-semiWidth,yCenter+semiWidth y,x = np.ogrid[yFrom:yTo:N*1j,xFrom:xTo:N*1j] c = x + y*1j print(\"c.shape:\",c.shape,\"x.shape:\",x.shape,\"y.shape:\",y.shape) return np.frompyfunc(getEscapeTime,1,1)(c).astype(np.float) ​ 上述pyd文件与绘图代码在同一目录下。使用该扩展模块与使用其它模块没有什么不同。from MandelbrotComp import getEscapeTime导入了该模块并引用了函数名。np.frompyfunc()则函数则直接使用该函数对象。此时，当numpy的C程序将c二维数组中的元素逐一交给getEscapeTime()函数计算时，该函数由于是C语言编写，其执行速度有了质的提升。读者可以运行随书代码中的InteractiveMandelbrot.py，体会一下速度变化。 ​ 需要说明的是，如果读者使用的不是Windows，那么InteractiveMandelbrot.py无法直接运行。C语言的编译结果与硬件平台(Intel x86或者ARM体系结构)、操作系统等有关。在Windows下编译的机器代码是无法在Linux下直接运行的。读者需要重新编译MandelbrotComp.pyx文件为扩展模块。 2.5 交互Mandelbrot绘图​ 作者随书提供了一个名为InteractiveMandelbrot.py的文件，该绘图程序提供了交互功能。操作者除了可以使用上下箭头来改变绘图颜色之外，还可以使用鼠标的左右键来放大/缩小图像。按下Esc键，则图像还原。 123para.semiWidth &#x3D; 1.5para.figWidth,para.figHeight &#x3D; 700,700para.fig.canvas.mpl_connect(&#39;button_release_event&#39;,on_button_release) ​ 为了实现上述功能，作者在para对象增加了figWidth, figHeight以表示绘图窗口的像素宽度和高度。para.semiWidth则表明当前的绘图半宽。当该绘图半宽变小，则相当于图像被放大。 ​ 当鼠标按键被松开时，on_button_release()勾子函数被调用。 12345678def on_button_release(event): para.x = (para.x - para.semiWidth) + 2*para.semiWidth*event.xdata/para.figWidth para.y = (para.y - para.semiWidth) + 2*para.semiWidth*event.ydata/para.figHeight if event.button == 1: para.semiWidth /= 3.0 elif event.button == 3: para.semiWidth *= 3.0 refresh() ​ 该函数首先借助于para.figWidth, figHeight, 鼠标点击坐标event.xdata, event.ydata等信息重新计算了新的绘图中心点para.x, para.y。 ​ 如果是鼠标左键弹起(event.button==1)，则减少绘图半宽-para.semiWidth，放大图像。否则增大绘图半宽，缩小图像。refresh()函数则负责重绘，绘图中心点以及半宽从para.x, para.y, para.semiWidth取值。 1234567891011def on_key_release(event): if event.key == 'up': para.idxColorMap+=1 elif event.key == 'down': para.idxColorMap-=1 elif event.key == 'escape': para.x, para.y = -0.5, 0.0 para.semiWidth = 1.5 else: return refresh() ​ 在on_key_release()勾子函数内，’escape’键弹起时，恢复para.x, para.y, para.semiWidth的初值并重绘，图像还原成初始状态。 ​ 下面是中心点为(-0.5, 0.0)，半宽为1.5的“全局”图像（图1）以及不同轮次放大的局部图像。 本文内容节选自作者编著的《Python编程基础及应用》（高等教育出版社）一书。 免费随书B站MOOC:","categories":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/categories/Python/"},{"name":"数学之美","slug":"Python/数学之美","permalink":"http://codelearn.club/categories/Python/%E6%95%B0%E5%AD%A6%E4%B9%8B%E7%BE%8E/"},{"name":"分形","slug":"Python/分形","permalink":"http://codelearn.club/categories/Python/%E5%88%86%E5%BD%A2/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/tags/Python/"},{"name":"Mandelbrot","slug":"Mandelbrot","permalink":"http://codelearn.club/tags/Mandelbrot/"},{"name":"分形数学","slug":"分形数学","permalink":"http://codelearn.club/tags/%E5%88%86%E5%BD%A2%E6%95%B0%E5%AD%A6/"},{"name":"曼德博集","slug":"曼德博集","permalink":"http://codelearn.club/tags/%E6%9B%BC%E5%BE%B7%E5%8D%9A%E9%9B%86/"},{"name":"Cython","slug":"Cython","permalink":"http://codelearn.club/tags/Cython/"}]},{"title":"实践 - 使用Python画一棵递归分形树","slug":"python-buildtree","date":"2019-01-19T12:48:13.000Z","updated":"2020-09-11T06:26:26.118Z","comments":true,"path":"2019/01/python-buildtree/","link":"","permalink":"http://codelearn.club/2019/01/python-buildtree/","excerpt":"本实践中，作者要介绍用Python在Tkinter上画一棵树的方法。通过本实践，读者可以：练习面向对象的程序设计方法；了解生成器的使用方法；运用递归函数；了解Tkinter画图的基本方法；以及学习“树”这种重要的数据结构。","text":"本实践中，作者要介绍用Python在Tkinter上画一棵树的方法。通过本实践，读者可以：练习面向对象的程序设计方法；了解生成器的使用方法；运用递归函数；了解Tkinter画图的基本方法；以及学习“树”这种重要的数据结构。 版权声明 本文可以在互联网上自由转载，但必须：注明出处(作者：海洋饼干叔叔)并包含指向本页面的链接。 本文不可以以纸质出版为目的进行改编、摘抄。 本实践中，作者要介绍用Python在Tkinter上画一棵树的方法。通过本实践，读者可以：练习面向对象的程序设计方法；了解生成器的使用方法；运用递归函数；了解Tkinter画图的基本方法；以及学习“树”这种重要的数据结构。 ​ 在本书配套的网站上，你可以下载到本实践的全部代码。本章要画的图“大概”长成下面这样。为什么说是大概呢？ 因为树的结构是在一定约束条件下随机生成的。 1. 数据结构 - 树​ 要完成本实践，读者首先要了解一点数据结构 - data structure的知识。数据结构大概是指计算机内部表达和组织数据的方式。 1.1 树 ​ 树-Tree是一种数据结构，它用于模拟真实世界中的树形结构，通常描绘成上图的样子。为了说明方便，作者把每个节点用字母作了标识。 ​ T是一棵树，树上的每个圆圈称之为一个节点-node，其中，a是树T的根节点 - root node。节点可以有后代 - descendents，其中，直接的后代称为儿子节点 - child。上图中，b,c,d是节点a的儿子，h,i是节点d的儿子。有儿子的节点称为内节点，没有儿子的节点称为叶子-leaf。上图中，e,f,k等节点没有儿子，作者用粗线圆作了标识，它们是叶子。 ​ T’是树T的一棵子树-sub tree，其根节点为d，我们称树T’是树T中以d节点为根的子树。理论上，任何一个节点其及全部后代都可视为一棵树。 ​ 上树中右侧的数字0,1,2,3表示节点在树中的深度-depth。a节点的深度为0，g,h节点的深度为1，j,k,l节点的深度为3。 1.2 树的递归表示123456789101112class TreeNode: def __init__(self,label): self.sLabel = label self.children = []a = TreeNode('a')b = TreeNode('b')c = TreeNode('c')d = TreeNode('d')a.children.extend([b,c,d])b.children.extend([TreeNode('e'),TreeNode('f')])... ​ 上边的代码展示了一个表示树的Python递归结构。TreeNode类有一个sLabel属性，存储节点的标签。此外，该类还有一个类型为列表的数据成员children，这里面存储该结点的全部儿子节点。而儿子节点的类型也为TreeNode，其也有children列表用于存储该儿子节点的儿子。当一个TreeNode对象的children列表为空时，表明该节点为叶子。 ​ 上述代码的后几行建立了前小节中树结构的一部分。其中a为根节点，a有b,c,d三个儿子，而b又有两个儿子e和f… 2. Top-Left坐标系 ​ 在图形程序设计中，一般采用Top-Left坐标系。如上图，以屏幕或者窗口的左上角为原点，横向为x轴，纵向为y轴。位置越靠右，x越大；位置越靠下，y越大。窗口内的任意一个点，可用一对(x,y)构成，这一对(x,y)值，称为该点的坐标。 3. 实例中的树表达123456789101112131415class Point: def __init__(self, x, y): self.x = x self.y = yclass TreeNode: maxDepth = 8 nBranches = 3 def __init__(self, bottom, top, depth=0): self.bottom = bottom self.top = top self.drawingTop = top self.depth = depth self.children = [] self.__generateDescendents() ​ 如代码所示，Point类有成员x和y，表明一个坐标点。TreeNode类表示一个树节点。类成员maxDepth表示树所允许的最大深度。类成员nBranches表示“建议”的树分叉数，即一根树支将分出多少根下层树支。此处之所以用了“建议”一词，是因为实际树的生成过程中分支数会引入随机成分。 ​ TreeNode对象的children属性是其儿子列表，depth表示该节点在树中的深度。TreeNode对象的另外几个属性需要结合下图来理解，这是作者在树上取下的一个小树支。下图中，a是一个TreeNode节点，其bottom表示以该节点为根的子树的“下”顶点；其top表示以该节点为根的子树的“上”顶点。注意，这里的上下打了引号，那是因为实践中，树支因地球引力，可能事实上倒垂向下。 ​ drawingTop定义为该节点自身（不含其子孙）的描绘用“上”顶点。a节点在树中的实际表现为一段树支，树支的描绘范围即为bottom至drawingTop点。从drawingTop一直到top则是a的子孙们的描绘区域。下图中，b,c,d为a的儿子，b,c,d也是TreeNode类型，其bottom应等于a的drawingTop。 ​ 此外，TreeNode类构造函数的最后一行执行了一个“不公开”成员函数__generateDescendents()，这个函数将递归生成以该节点的根的子树，该子树中节点的深度不超过TreeNode.maxDepth。该部分内容见后节。 变量、函数、类的判定准则 - 新手们写出来的程序通常可读性和健壮性都有问题。作者建议，当读者试图定义一个变量、函数、类时，都必须满足如下规则：如果其作用和取值可以用简洁明了没有歧义的讲清楚，那么其存在可能是合理的。如果说不清道不明，那么读者需要另寻它法。本实践中的，TreeNode之bottom,top,drawingTop，受限于其复杂性，很难用一句话描述，但至少借助于图示，是可以讲清楚的。 - Python之禅里有“If the implementation is easy to explain, it may be a good idea”。这里，请读者品味其含义。 4. 树的递归生成4.1 分叉树支生成12345678910111213141516171819class TreeNode: ... def __generateDescendents(self): \"Recursively build sub-tree of the current node.\" n = random.randint(TreeNode.nBranches//2,round(TreeNode.nBranches*1.5)) n = n if n &gt;=1 else 1 r = 0.20 + random.random() * 0.2 x = self.bottom.x + (self.top.x - self.bottom.x) * r y = self.bottom.y + (self.top.y - self.bottom.y) * r self.drawingTop = Point(x, y) if self.depth &lt; self.maxDepth: a = math.pi * 0.5 / n for i in range(n): angleOffset = a * (n-1) / 2 - a * i + math.pi angleOffset *= (0.9 + random.random() * 0.2) son = self.__bornSon(self.drawingTop, self.top, angleOffset) self.children.append(son) ​ 上述__generateDescendents()函数在节点的构造函数中被调用。从下到下解释该函数。 ​ 首先，函数确定当前树支的分叉数，也就是当前节点的儿子的数量n。可以看到，n随机取值为TreeNode.nBranches的0.5到1.5倍。为了稳妥起见，程序还限定n值至少为1。 ​ 接下来，程序确定当前树支的描绘顶点，即当前节点的drawingTop。drawingTop的确定也引入了随机性，从bottom顶点出发，往top顶点方向，前进总距离的0.2 - 0.4倍，即确定为drawingTop顶点。这里，random.random()返回[0,1)之间的随机浮点数，1之后的)号表明返回值不包含1，这说明，r的取值为0.2 - 0.4(不含)。 ​ 然后，如果当前节点的深度-depth小于约定的最大深度-maxDepth，则生成该节点的n个儿子结点，也就是当前树支的n个分叉。这里的代码比较复杂，涉及了弧度和三角函数的数学知识，简要描述之。如前节所述，当前节点/树支的drawingTop即为儿子节点/分叉的bottom。在当前节点/树支的drawingTop点，沿当前树支的伸展方向，左右各45度，共90度(即 π/2)范围内逐一”均布”生成n个分叉儿子节点。这里的“均布”是大致的，上述代码中的angleOffset被乘以了0.9-1.1的随机数。__bornSon(self.drawingTop, self.top, angleOffset)函数以当前树支的drawingTop为bottom，以“以当前树支为根的子树”的top为top，生成一个分叉儿子结点，分叉的伸展角度为当前树支的伸展角度加上偏移角angleOffset。 一个儿子生成完后，再将其加入到children列表中。 4.2 生成一个儿子123456789101112131415161718class TreeNode: ... def __bornSon(self, bottom, top, angleOffset): \"Born a son of current node, with designated offset angle.\" xWidth = top.x - bottom.x #Width of sub-tree yHeight = top.y - bottom.y #Height of sub-tree angleSubTree = math.atan(yHeight / xWidth) if xWidth !=0 else math.pi/2 if (angleSubTree &lt; 0 and bottom.y &gt; top.y) or \\ (angleSubTree &gt; 0 and bottom.y &lt; top.y): angleSubTree += math.pi angleSon = angleSubTree + angleOffset r = 0.9 + random.random() * 0.2 c = math.sqrt(xWidth ** 2 + yHeight ** 2) * r xOffset = c * math.cos(angleSon) yOffset = c * math.sin(angleSon) topNew = Point(xOffset + bottom.x, yOffset + bottom.y) return TreeNode(bottom, topNew, self.depth + 1) ​ 接上节，该函数需要沿其子树的伸展方向偏转一个偏移角生成一个儿子。 ​ 函数首先通过bottom，top之间的相对位置关系，使用反正切函数计算得到子树的伸展角angleSubTree。请注意，由于反正切函数的局限性(值域为(-π/2, +π/2)，不能表达全部圆周角度），代码不得不再次通过bottom, top的相对关系对angleSubTree进行修正。接下来，子节点的伸展角angleSon等于子树伸展角加上偏移角。 ​ 有了分支子节点的伸展角angleSon，再借助子树的对角线长度c乘以0.9-1.1随机数，使用正余弦函数计算出分支子节点的top - topNew。然后，函数以topNew为“上”顶点构造一个TreeNode对象，子节点的深度为当前节点深度加1。 ​ 需要特别说明的是，__bornSon()函数通过TreeNode构造函数生成一个子结点，而该子结点的构造函数又会执行__generateDescendents()函数生成其后代。所以，只要我们通过TreeNode的构造函数构造一个根节点-root node，该节点的构造函数会执行__generateDescendents()生成其子结点，而子结点的构造又会导致子结点的子结点被生成出来，… ，最终，生成了一棵完整的树。在生成后代的过程中，只有当当前节点的深度小于约定的最大深度时，才会尝试生成后代，因此，递归有恰当的边界条件会导致其终结。这种情况，我们也称递归函数会收敛。 4.3 生成整棵树12345678910111213141516171819202122232425class TreeBuilder: def setPara(bottom,top,nBranches=3,maxDepth=8): TreeBuilder.bottom = bottom TreeBuilder.top = top TreeBuilder.nBranches = nBranches TreeBuilder.maxDepth = maxDepth def buildTree(depthOffset=0): TreeBuilder.maxDepth += depthOffset TreeBuilder.maxDepth = TreeBuilder.maxDepth \\ if TreeBuilder.maxDepth &lt;=10 else 10 TreeBuilder.maxDepth = TreeBuilder.maxDepth \\ if TreeBuilder.maxDepth &gt;=2 else 2 print(\"Build a tree, branches:&#123;&#125;,depth:&#123;&#125;.\". format(TreeBuilder.nBranches,TreeBuilder.maxDepth)) TreeNode.maxDepth = TreeBuilder.maxDepth TreeNode.nBranches = TreeBuilder.nBranches t = TreeNode(TreeBuilder.bottom,TreeBuilder.top) RenderHelper.showTree(t) ... TreeBuilder.setPara(bottom=Point(1024/2,768-20), top=Point(1024/2,768*0.1)) TreeBuilder.buildTree() ​ TreeBuilder是一个所谓的“帮助”类，可以看到其两个函数都没有self参数，都属于类函数的范畴。也就是说，这两个函数的执行不以TreeBuilder类型对象的存在为前提。 ​ 在主程序中，我们首先通过TreeBuilder.setPara()函数设置了将要生成的树的bottom“下”顶点及top“上”顶点，1024和768是窗口的宽度和高度，可以看出，bottom左右居中，距窗口下边缘20个像素；top左右居中，距窗口上边缘10%。建议的树支分叉数nBranches以及树的最大深度maxDepth使用了默认值。 ​ 接下来，主程序调用TreeBuilder.buildTree()函数构造并显示一棵树。这个函数允许通过一个深度偏移量来改变原设定最大深度。在调整完深度并把深度及建议分叉数存入TreeNode.maxDepth和TreeNode.nBranches后，函数简单粗暴地构造了一个TreeNode对象t，这个t即为树的根节点。请注意，由于前小节所述的递归的原因，这个以t为根的树会被完整地生成出来，其深度为TreeNode.maxDepth。 ​ 请读者注意，作者对TreeBuilder.maxDepth进行了限定，不允许其超过10。原因很简单，树的节点的总数量随深度呈指数级增长，超过10的深度的树可能需要非常长的运行时间，甚至可能会超过你的计算机的存储或计算能力。 ​ 在buildTree()函数的最后，执行了RenderHelper.showTree(t)将树显示出来。 5 树的显示5.1 计算机里的颜色表示​ 画家可以仅凭“红”，“绿”，“蓝”调出他所需要的所有颜色，计算机也可以。计算机通常用三个字节来表示一种颜色，从左往右分别表示红、绿、蓝三种颜色成分，取值为0-255，即十六进制的0x00 - 0xff。通过三种颜色成分的不同组合，我们可以得到任意颜色。这种用红-Red，绿-Green，蓝-Blue来组合构成颜色的模型称为RGB模型。 RGB 说明 009000 红为0x00，绿为0x90，蓝为0x00，综合颜色为翠绿 ff0000 红为0ff，绿为0x00，蓝为0x00，综合颜色为红 909000 红为0x90，绿为0x90，蓝为0x00，综合颜色为黄 ffffff 三种颜色均为0xff，综合颜色为白 000000 三种颜色均为0x00，综合颜色为黑 606060 三种颜色均为0x60，综 合颜色介于黑和白之间，是灰色，值越大，灰越浅 ​ 在印刷业，使用的配色方案跟计算机里有所不同，他们使用青-Cyan、品红-Magenta和黄-Yellow来组合构成所有颜色，即所谓减色法，又称CMY模型。 5.2 树的遍历12345678910class TreeNode: ... def bfs(self): #breadth first search nodesQueue = [self] while True: if len(nodesQueue)==0: break x = nodesQueue.pop(0) yield x nodesQueue.extend(x.children) ​ 显示一棵树，即是迭代列举树的全部节点，并将其全部画出来。列举树的全部节点，又称为树的遍历。作者在这里使用了树的宽/广度优先遍历算法。 ​ 为了便于读者理解，作者以上面这棵小树为例，说明宽度优先遍历的过程。对A节点执行bfs()函数，队列nodesQueue初始化为[A]。遍历过程将一直持续到nodesQueue队列为空，即len(nodesQueue)==0为止。 ​ 首先，从队列中弹出A并yield。请注意，这里的bfs()函数被写成了生成器函数，关于生成器函数的工作原理，请参考本书相关章节。这里简单地认为yield x语句将x结点“抛”给使用方即可。 ​ A被yeild后，A的儿子结点被加入nodesQueue - [B,D]。接下来，弹出并yield B，B的儿子结点C被加入nodesQueue - [D,C]。接着，弹出并yield D，D的儿子结点E被加入nodesQueue - [C,E]。接下来，弹出并yield C，C没有儿子，故nodesQueue只剩下一个节点 - [E]。接着，E被弹出并yield，E的儿子F被加入nodesQueue - [F]。最后，F被弹出并yield，F是叶子，没有儿子可以加入nodesQueue，所以nodesQueue为空，全部节点已经成功列举，遍历结束。 ​ 如果列出全部节点的列举顺序，应该是A,B,D,C,E,F,正好是树的结点一层一层的逐层列举。这种列举了某个节点后，立即列举离这个节点最近的全部儿子的遍历方法称为“宽度优先”。与“宽度优先”对应的是“深度优先”，相关内容在数据结构课程中会得到深入研究。 5.2 树的显示1234567891011class RenderHelper: canvas = None def showTree(tree): \"Render a tree on canvas.\" assert RenderHelper.canvas != None, \"Please set canvas first.\" RenderHelper.tree = tree for x in RenderHelper.canvas.find_all(): RenderHelper.canvas.delete(x) for x in tree.bfs(): RenderHelper.__renderNode(x) RenderHelper.canvas.update() ​ 同样地，RenderHelper是一个帮助类，可以在不经实例化的情况下使用其类函数。canvas是主程序设置进来的Tkinter”画布”。showTree(tree)函数负责在canvas上把树“画”出来。 ​ 可以看到，showTree()首先并断言了canvas的可用性。然后，删除了canvas内已有的全部内容。接下后，通过for x in tree.bfs()遍历列举tree的全部节点x，逐一调用__renderNode(x)在画布上“画”出来。 ​ __renderNode(x)所谓的“画”其实只是在canvas的内部数据表达中增加相关元素（比如线、椭圆或其它图形），真正要把画布的内容展示在计算机屏幕上，还需要执行canvas.update()函数。 12345678910111213141516171819class RenderHelper: ... def __renderNode(node): \"Render a TreeNode.\" colorFill = \"#&#123;0:0&gt;2x&#125;&#123;0:0&gt;2x&#125;&#123;0:0&gt;2x&#125;\".\\ format(int(0x60 * node.depth / node.maxDepth)) RenderHelper.__drawLine(node.bottom,node.drawingTop, colorFill=colorFill,width=1.5 ** (node.maxDepth - node.depth)) if not node.children: #draw leaf if it is a leaf red = 0xff * node.drawingTop.y / RenderHelper.tree.drawingTop.y red = int(red * (0.8 + random.random() * 0.4)) red = red if red &lt;= 0xff else 0xff colorFill = \"#&#123;0:0&gt;2x&#125;9000\".format(red) RenderHelper.canvas.create_oval( node.drawingTop.x - 3,node.drawingTop.y - 3, node.drawingTop.x + 3,node.drawingTop.y + 3, fill=colorFill) RenderHelper.canvas.update() #This sentence for contruction show ​ __renderNode(node)函数负责在画布中“画”一个节点。首先，是画这个节点所代表的树支。 12colorFill = \"#&#123;0:0&gt;2x&#125;&#123;0:0&gt;2x&#125;&#123;0:0&gt;2x&#125;\".\\ format(int(0x60 * node.depth / node.maxDepth)) ​ colorFill为形如”#101010”的RGB模型颜色字符串，在这里，R，G，B三个值相等，且跟当前节节的深度有关，深度越浅，说明节点离树根越近，colorFill为取值接近”#000000”，黑色越深。当深度较大时，说明节点离叶子较近，colorFill取值接近”#606060”，黑色较浅，为灰色。 ​ __drawLine()函数从节点的bottom至drawingTop画一条线表示树支，颜色即上述colorFill，而线宽则同样与节点深度有关。深度越浅，树支越接近树根，线宽越宽。 ​ 当节点的儿子列表为空时，说明节点是叶子节点，此时需要画一个实心圆点表示树叶。树叶本来是绿色(取值0x90)的，但作者刚才正好从美丽的重庆大学虎溪校区泛黄的银杏树下走过，决定给树叶加点“红”色。红色成分的多少取决于树叶的描绘高度，越靠近树顶，红色越少，树叶越绿；越靠近地面，红色越多，树叶越黄。上述的colorFill字符串格式化的结果为”#309000”这样的字符串，绿为0x90，红为0x30或者其它值，蓝始终为0x00。注意，红色成分的多少也加入了一些随机因素。 ​ canvas.create_oval()函数在画布上创建一个实心圆树叶，该实心圆以drawingTop为圆心，colorFill为填充色。这个函数本来是画椭圆的，但由于正圆是椭圆的特例，所以也可以用来画正圆。 ​ __renderNode()函数的最后一行为RenderHelper.canvas.update()。update()会在显示器上实际渲染画布的内容，所以该函数执行至少要”花费”一个显示帧的时间。考虑到显示器的刷新频率一般是60Hz，这意味道着，程序每秒钟只能“画”出大约60个节点。所以，如果该行代码存在，你可以在计算机上看到树被一点点的画出来，并且还可以根据树支、叶片在界面上出现的先后顺序来理解树的“深度优先遍历”算法。读者可以删除该行代码，再运行试一试。 12345678910111213141516171819202122232425class RenderHelper: ... def __drawLine(pt0, pt1, width, colorFill, minDist=10): dots = RenderHelper.__generateDotsSequence(pt0,pt1,minDist) RenderHelper.canvas.create_line(dots,fill=colorFill,width=width, smooth=True) def __generateDotsSequence(pt0,pt1,minDist): dots = [] dx, dy = pt1.x - pt0.x, pt1.y - pt0.y c = math.sqrt(dx ** 2 + dy ** 2) n = int(c / minDist) + 1 xPrev,yPrev = pt0.x,pt0.y for i in range(n): xOffset = dx * i / n yOffset = dy * i / n if i &gt; 0: xOffset += minDist * (0.5 - random.random()) * 0.25 yOffset += minDist * (0.5 - random.random()) * 0.25 x,y = pt0.x + xOffset,pt0.y + yOffset dots.extend([xPrev,yPrev,x,y]) xPrev,yPrev = x,y dots.extend([xPrev,yPrev,pt1.x,pt1.y]) return dots ​ __drawLine()函数负责从pt0 - bottom到pt1 - drawingTop画一条宽度为width，颜色为colorFill的实心线来表示一条树支。 ​ 但现实中的树，树支不可以是完全直的。所以，借助__generateDotsSequence()函数，作者以minDist=10为间距，将树支分成多个小段，并加入一些随机因素。最后，再用canvas.create_line()将多点线画出来，尽可能模仿现实世界中树支的模样。 6 Tkinter循环123456789101112131415tk = tkinter.Tk()tk.title(\"Build Tree\")canvas = tkinter.Canvas(tk,width=1024,height=768,bg=\"#ffffff\")canvas.pack()RenderHelper.canvas = canvasTreeBuilder.setPara(bottom=Point(1024/2,768-20), top=Point(1024/2,768*0.1))TreeBuilder.buildTree()tk.bind(\"n\", lambda evt: TreeBuilder.buildTree())tk.bind(\"=\", lambda evt: TreeBuilder.buildTree(depthOffset=1))tk.bind(\"+\", lambda evt: TreeBuilder.buildTree(depthOffset=1))tk.bind(\"-\", lambda evt: TreeBuilder.buildTree(depthOffset=-1))tk.mainloop() ​ 主程序中，我们创建了一个tkinter对象，并生成了长1024，宽768，背景色为白色的画布 - canvas。然后，建造并显示了一棵树。 ​ 接下来，我们对程序创建了几个快捷键，程序运行中，当你按下n时，TreeBuilder.buildTree()会被执行，这将建造并显示一棵新树。按下+或者=时，TreeBuilder.buildTree(depthOffset=1)会被执行，系统会尝试将树的深度加1并建造和显示一棵新树。按下-时，TreeBuilder.buildTree(depthOffset=-1)，系统会尝试将树的深度减1并建并建造和显示一棵新树。 ​ 此处的lambda表示匿名函数，它将带有实参的TreeBuilder.buildTree(depthOffset=1)封装成一个没有名字的函数。 ​ tk.mainloop()将执行所谓的消息循环，在里面，Tkinter将不断地循环等待来自用户的命令并执行，直到用户关闭Tkinter窗口。 7 小结​ 本实践的主要用意在于帮助读者掌握和运用面向对象的程序设计方法，以及递归的算法、树的数据结构表示方法等。Tkinter库的使用不是重点。作为Python自带的标准GUI工具包，Tkinter库在小型应用中仍有一席之地，但当应用的规模略大时，作者认为不太方便。在本书中，作者将着重介绍另一种更强大的GUI工具包，那就是PyQt。 本文内容节选自作者编著的《Python编程基础及应用》（高等教育出版社）一书。 免费随书B站MOOC:","categories":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/categories/Python/"},{"name":"数学之美","slug":"Python/数学之美","permalink":"http://codelearn.club/categories/Python/%E6%95%B0%E5%AD%A6%E4%B9%8B%E7%BE%8E/"},{"name":"分形","slug":"Python/分形","permalink":"http://codelearn.club/categories/Python/%E5%88%86%E5%BD%A2/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/tags/Python/"},{"name":"分形数学","slug":"分形数学","permalink":"http://codelearn.club/tags/%E5%88%86%E5%BD%A2%E6%95%B0%E5%AD%A6/"},{"name":"递归","slug":"递归","permalink":"http://codelearn.club/tags/%E9%80%92%E5%BD%92/"},{"name":"树","slug":"树","permalink":"http://codelearn.club/tags/%E6%A0%91/"},{"name":"Tkinter","slug":"Tkinter","permalink":"http://codelearn.club/tags/Tkinter/"}]}]}