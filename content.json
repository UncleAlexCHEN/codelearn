{"meta":{"title":"Python,C/C++ Club","subtitle":"重庆大学在线公开课程","description":"分享有关Python, C/C++程序设计课程的技术文章","author":"Alex CHEN","url":"http://codelearn.club","root":"/"},"pages":[{"title":"关于我们","date":"2020-03-03T03:43:07.872Z","updated":"2020-03-03T03:43:07.872Z","comments":true,"path":"about/index.html","permalink":"http://codelearn.club/about/index.html","excerpt":"","text":"本网站出于公益及非商业目的构建。 如果侵权行为，均非故意，请联络删除。 海洋饼干叔叔@重庆大学 CSDN博客： https://blog.csdn.net/SeaBiscuitUncle 知乎专栏： https://zhuanlan.zhihu.com/codelearn B站： https://space.bilibili.com/384177380"},{"title":"下载","date":"2020-05-04T10:57:27.275Z","updated":"2020-05-04T10:57:27.275Z","comments":true,"path":"download/index.html","permalink":"http://codelearn.club/download/index.html","excerpt":"","text":"《Python编程及应用》随书源代码： https://codelearn.club/download/pylearn.zip (国外源，下载较慢) http://www.ircchina.com/filedownload/199810 （国内源，下载较快） 海洋饼干叔叔@重庆大学 CSDN博客： https://blog.csdn.net/SeaBiscuitUncle 知乎专栏： https://zhuanlan.zhihu.com/codelearn B站： https://space.bilibili.com/384177380"},{"title":"纸质图书","date":"2020-03-03T03:46:41.426Z","updated":"2020-03-03T03:46:41.426Z","comments":true,"path":"book/index.html","permalink":"http://codelearn.club/book/index.html","excerpt":"","text":"《Python编程及应用》一书由高等高教出版社出版，将于近期面市。 海洋饼干叔叔@重庆大学 CSDN博客： https://blog.csdn.net/SeaBiscuitUncle 知乎专栏： https://zhuanlan.zhihu.com/codelearn B站： https://space.bilibili.com/384177380"},{"title":"在线MOOC","date":"2020-03-03T03:49:53.558Z","updated":"2020-03-03T03:49:53.558Z","comments":true,"path":"mooc/index.html","permalink":"http://codelearn.club/mooc/index.html","excerpt":"","text":"Python编程及应用 @BILIBILI https://www.bilibili.com/video/av34409478/ 从C到C++ @BILIBILI https://www.bilibili.com/video/av34586138/ 海洋饼干叔叔@重庆大学 CSDN博客： https://blog.csdn.net/SeaBiscuitUncle 知乎专栏： https://zhuanlan.zhihu.com/codelearn B站： https://space.bilibili.com/384177380"},{"title":"致谢","date":"2020-03-03T03:56:46.971Z","updated":"2020-03-03T03:56:46.971Z","comments":true,"path":"thanks/index.html","permalink":"http://codelearn.club/thanks/index.html","excerpt":"","text":"致谢 http://hexo.io 创造了这么伟大的博客网站框架。 致谢 https://volantis.js.org/ 构建了volantis的hexo主题。 受益于无私的开源程序员们的贡献，本网站的作者仅花了几个小时就完成了网站的搭建。 海洋饼干叔叔@重庆大学 CSDN博客： https://blog.csdn.net/SeaBiscuitUncle 知乎专栏： https://zhuanlan.zhihu.com/codelearn B站： https://space.bilibili.com/384177380"}],"posts":[{"title":"那门用Python讲授的程序设计课程能带给学生什么？","slug":"pylesson","date":"2020-09-07T09:48:14.000Z","updated":"2020-09-07T14:16:30.848Z","comments":true,"path":"2020/09/pylesson/","link":"","permalink":"http://codelearn.club/2020/09/pylesson/","excerpt":"那门用Python讲授的程序设计课程能带给学生什么？","text":"那门用Python讲授的程序设计课程能带给学生什么？ 那门用Python讲授的程序设计课程能带给学生什么？海洋饼干叔叔 @ 重庆大学 最近这几年，Python火上天了。历史上，即便是Python它菩提老祖C语言（Python解释器是用C语言写的），也从未那么火过，毕竟在C语言刚出来那个年代，计算机只有很有钱的人家（比尔盖茨他妈是IBM董事，社会活动家）才有，编程还是少数技术人员拥有的特殊技能。 Python火起来的最大原因是所谓人生苦短，我用Python。易学易用的特点使得编程不再是需要专业训练的特殊技能，下至高校教师，家里的小祖宗，上至家里管钱管厨房的领导，进行引力波探测的顶尖科学家，都可以使用Python来编程。什么？不信？我们选择一个特别的角度证明给你看：下面是各种牛掰语言的爹地合集， 包括C++他爸Bjarne Stroustrup, Java之父James Gosling，PHP他爹Rasmus Lerdorf, Go语言之父Rob Pike， 以及造就Python的伟大“河（去声）南“ 雷峰 - Guido van Rossum。猜猜这几张照片哪位是Python之父Guido van Rossum ? 答案就是： 头发最茂盛那位！ 工业界为之疯狂，阿里https://edu.aliyun.com/course/505微软https://www.bilibili.com/video/av69042526/谷歌https://developers.google.com/edu/python/ 都推出了自己的专属Python课程，急吼吼地想培训和吸引P8以上的有福报能加班的年轻人。好像不免费提供一点像样的Python课程，都不好意思说自己是负责任的国际大公司。 中国的教育界也疯了，先是浙江传出消息，管教育那帮人终于睡醒了，从高中课标里删除了老掉牙，没人用的Visual Basic, 用Python替代，顺带着把Excel, Access也踢出了课标，因为Excel, Access能干的活好像Python也能干。 然后，山东，上海，北京，重庆相继表示，我们也不能落后，除了往中学课标里加入Python内容外，还顺带把”先进的科学”直接送到“我们的祖国是花园”，小学六年级的《信息技术-Python入门》给大家感受一下。 看这架势，Python进入高考已是板上钉钉，以后的泱泱中华，要想再找出一个没学过编程的小朋友，真如大海捞针一般困难。 中小学都上了， 大学自然也要上。无论是中国还是美国，Python正取代C/C++语言，成为大学最受欢迎的编程入门课程。大学里讲编程基础课的老师好像也松了一口气， 终于不会因为C语言劝退诸多懵懵懂懂的小朋友了。要知道，C语言以”从入门到放弃“而闻名而世，特别当你选用早期的C语言书作为教材的时候。在那个年代，学习编程的大多是一些智商超群的人，所以彼时的作者高估了读者的智商，专门挑一些没什么大用处，然后又特别烧脑的断头路（比如i = i++ + ++i，i之前等于0，问之后等于几？），死路，带着萌新们一条道走到黑，，，成功降低了程序员市场的竞争烈度。这么说其实对当时的作者也不太公平，老先生的书，在当年已经算是很浅显的了，在向社会普及计算机及编程知识方面，功勋卓著。 所谓内行看门道，给大一，大二的小鲜肉们上菜，不能太马虎。上一门借Python之名的程序设计课程，显然不能只讲语法，那是舍本逐末之举。作者在某985大学教了15年编程（从C, C++一直教到Python），又同时在工业界当了15年程序员，还跨圈画了数年的电路图，还曾经对着三视图跟模具工程师、结构工程师讨论过公差配合，运动噪声消除，材料耐用性之类的“高深”问题，，，，， 大着胆子，分享一下一家之言： Python程序设计课应该带给学生什么？ 1. 算法 - 用计算机解决问题的思维习惯乔帮主（布斯）留下话：学习编程教你如何思考。孔夫子也说过，学而不思则罔。所以不管学生的层次（985，211，三本，专科， 高职）如何，一定要在课程里带点算法以及使用算法解决问题的例子给他。包括但不限于下述示例，它们都是用Python写的，大部分都是带图，带动画的。（如果一直print, 老师学生都会疲倦） 发现圆周率 - 使用投点方法，借助于均匀分布的随机数函数，重新估算圆周率 一对兔兔与函数的增长 - 讲述著名的斐波那契数列， 以及函数的递归调用， 嗯，再帮助学生回顾一下《高等数学》中无穷大的阶的不同在计算机里如何体现，我们把斐波那契数列与n2, n3函数进行了作图比较，观察函数的增长速度 汉诺塔 - 递归求解的经典案例，古老的印度智慧 文本进度条 - 旧科技时代的回望 2. 语言 - 简单实用的语法变量与数据类型、缩进、输入输出、条件分支、列表、名字绑定、循环、字典、函数抽象、文件的读写、高级的字符串处理这些都是必不可少的语言知识。但笔者认为，面向对象也是一种思维方式和设计哲学，不可或缺。所以，在程序设计课程里应该有面向对象的一席之地。 除此之外，异常处理、单元测试、类序列化、迭代器与生成器等则属于非必要的语法知识，其讲授可根据学生的层次，以及学习目标而定。 对于C/C++这类复杂的语言，即便是一个熟练的程序员，也大概只会使用到其中20%的特性，另外80%则几乎不用。对Python而言，情况好一些，在选择课程内容时，应该挑出那些实用的，常用的语法特性加以认真发挥，而对于那些生僻的，生僻且晦涩难懂的，不讨论为妙。 但是，对于那些重要的特性，比如range(), 比如切片语法，则一定要讨论清楚。作者相信：图比文字清楚，所以画很多的流程图来帮助解释数值列表与切片及其他关键的语法： 总之， 语法的介绍要从实用出发， 而不是“考试”出发，象 i++++ 这种类型的“劝退”语法，坚决不涉及。 3. 代码 - 优美的编程习惯示范好的代码应该读起来跟散文一样优美。所以教材中给学生的示例代码大部分长这样：有行号，字体优美，匈牙利命名法则，连字体也精心选择的。 我们相信，学生会模仿老师的代码。老师的代码如果质量高，学生会潜移默化地学到优美，良好的编码风格和习惯。在书里面，我们还经常提及断言、单一职责原则、单元测试等简单的软件工程原则，希望在教授表面语法同时，顺便传递一点“内功”。 4. 实践 - 与专业相结合 我一个学新闻的，为什么要学编程？ 我们法学院，开个毛线编程课！ 我只想静静地做个医生，不行么？ 隔壁数理学院，开编程课，为什么我们学土木的也要开？ 这是非计算机专业的学生在学习编程时的常见抱怨。 原因有二： a. 课程内容与实践脱节，为教而教，为考试而学，学完就忘； b. 课程里的案例与学生的专业没有关系，学生没有获得用编程方法解决本专业问题的体验。 为了解决这个问题，我们设计了很多示例，涉及数学、美术、文学、历史、信号处理、医学、经济学、游戏、科学计算、人工智能等众多学科门类和领域。众多不同专业的学习者，都可以在本书中找到与本专业相关的应用实例。放几个大家感受一下。这些示例，有难有易。事实上，考虑到部分示例的复杂性，我们并不指望大一年级的新生能够完全读懂，我们只是希望让明白，学好编程，对他的专业发展颇有助益。 一棵树的建造 - 树形数据结构、递归、分形、树的宽度优先遍历算法 汉诺塔 - 定时器、pygame框架、汉诺塔算法、计算复杂性分析、复杂程序的结构、生成器 GDP前15工业图家的冒泡排序演示 - 多线程、GUI程序设计、PyQt、分时图形界面程序框架 图像风格迁移 - 深度学习、神经网络 缙湖下雨啦 - matplotlib动画、numpy多维数组 Mandelbrot集合 - 分形数学的开山之作 对ECG信号进行数字滤波 唐全诗数据分析 - 关系数据库、字典、数据分析 5. 手把手的私教学习体验新形态＂电纸＂书，凡是涉及实践操作的每一步，都有视频／图文步骤指导，扫扫二维码，轻松可得。 全书提供数百个二维码，提供在线课堂、先睹为快、操作指导、扩展阅读等各种在线协助。为读者的编程学习提供手把手＂私教＂。 6. 配套火爆B站的在线MOOC，学习轻松不怕难 写到了这一步，我的小心机藏不住了，对，我就是向读者推荐优质Python入门教材的，它长这样，某东、某宝、某当有售。 《Python编程基础及应用》","categories":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/tags/Python/"}]},{"title":"如何下载《Python编程基础及应用》课程的源代码(pylearn)","slug":"getpycode","date":"2020-05-04T09:21:04.000Z","updated":"2020-09-06T06:11:49.775Z","comments":true,"path":"2020/05/getpycode/","link":"","permalink":"http://codelearn.club/2020/05/getpycode/","excerpt":"各位后浪/幼浪，为了让更多人能够看到这门课程，UP主需要各位的转发支持。 获得《Python编程基础及应用》课程的源代码（pylearn, 30多MB)的方法如下。","text":"各位后浪/幼浪，为了让更多人能够看到这门课程，UP主需要各位的转发支持。 获得《Python编程基础及应用》课程的源代码（pylearn, 30多MB)的方法如下。 第1步 打开下述链接，分享至下述渠道之一。 https://codelearn.club/2020/05/pyad/ 微信朋友圈，集赞20个； QQ空间，集赞20个； 成员至少100位的同学群、年级群、同事群【 分享3分钟后再截图，截图中可以看到截图时间与分享时间相差3分钟以上， 作者也不想这样，但很多缺乏责任感的读者发完就截图，截图完就立即撤回， 让人很沮丧 】。 分享时请加上下述文字： 我正在B站上学习Python，重庆大学海洋饼干叔叔讲得还行，奶妈级贴心，又没有废话，特别适合零基础小白，推荐给大家一起看… 课程是免费的，但需要转发才能获得作者的源代码，抱歉打扰到大家。 第2步​ 加入下述读者交流互助QQ群之一，把截图发群里，并@群主或者群管理员。 群主或管理员会发下载链接给你。 （部分群可能已满员）。 群号：162436874 群号：593202212 群号：1080059098","categories":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/tags/Python/"}]},{"title":"B站Python课程 - 重庆大学海洋饼干叔叔","slug":"pyad","date":"2020-05-04T09:06:04.000Z","updated":"2020-05-04T09:16:28.209Z","comments":true,"path":"2020/05/pyad/","link":"","permalink":"http://codelearn.club/2020/05/pyad/","excerpt":"我正在B站上学习Python，重庆大学海洋饼干叔叔讲得还行，奶妈级贴心，又没有废话，特别适合零基础小白，推荐给大家一起看…","text":"我正在B站上学习Python，重庆大学海洋饼干叔叔讲得还行，奶妈级贴心，又没有废话，特别适合零基础小白，推荐给大家一起看… 课程访问地址： https://www.bilibili.com/video/BV1kt411R7uW/","categories":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/tags/Python/"}]},{"title":"delete[ ]如何确定动态数组的元素个数？","slug":"delete","date":"2020-03-31T15:46:04.000Z","updated":"2020-03-31T15:53:17.898Z","comments":true,"path":"2020/03/delete/","link":"","permalink":"http://codelearn.club/2020/03/delete/","excerpt":"本文研究并解释delete [ ]操作符如何确定动态数组的元素个数。 本文转载自重庆大学2019级风流倜傥的于卓浩同学的文章：https://puluter.cn/20200331/delete/ [上述形容词是海洋饼干叔叔加的，与事实相符] 稍有修改。","text":"本文研究并解释delete [ ]操作符如何确定动态数组的元素个数。 本文转载自重庆大学2019级风流倜傥的于卓浩同学的文章：https://puluter.cn/20200331/delete/ [上述形容词是海洋饼干叔叔加的，与事实相符] 稍有修改。 1. 简介在面向对象编程中，我们经常会用到这样的动态分配数组： 1Person* a = new Person[100]; 在上述申请数组的过程中，我们使用到了new []这个表达式来完成，它会调用类的构造函数初始化这个数组的所有对象，有多少对象，就会执行多少次构造函数。如果我们用完了这个数组，想要释放空间，就需要调用： 1delete[] a; 在这个过程中，我们使用了delete[]操作符来完成对象释放。但是两个问题出现了： 如何知道a数组的内存空间大小？ 如何知道要调用几次析构函数（a数组的元素个数）？ 显然，想要知道数组有多长，我们必然要存下这个数组的长度。C++中也正是这么做的。本文讨论具体工作原理。 2. 结合代码的分析 注：本文适用于64位mingw。在32位mingw下后文内8字节应为4字节，long long应为int。 我们先定义一个自定义的类。 12345678class Yu &#123;public: int iNumber;//Yu类内将只有这一个int变量 //即 一个Yu对象的大小=一个int的大小=4字节 Yu()&#123;iNumber = 1;&#125; ~Yu()&#123;&#125; ...&#125;; 同时，在main中声明一个长度为len(20194134)的Yu类型的数组，再获取该数组开头的地址并打印。 12345678const long long len = 20194134;int main()&#123; ... Yu* testArr = new Yu[len]; char* p1 = (char*) testArr; cout &lt;&lt; \"Address for the Array: \"&lt;&lt; testArr &lt;&lt;endl; ...&#125; 输出为：Address for the Array: 0x2670048 理论上，20194134个Yu对象，总共需要 20194134 x sizeof(Yu) = 80776536字节的空间。实际申请的堆（自由内存区）空间稍有出入，我们可以通过重载new [ ]操作符来研究。 我们重载new[]了操作符： 12345void* operator new[](size_t sz)&#123; printf(\"|Length: %lld\\n|Real Size: %lld\\n|Raw Size(int(4)*length): %lld\\n|Gap: %lld\\n\",len,sz,len*4,(long long)sz-len*4); void* o = malloc(sz); return o;&#125; 在这个过程中，我们打印四个关键数值： 数组的长度(len) new[]过程中实际申请的内存空间大小(sz) 数组理论上需要的内存空间 （数组长度 x sizeof(Yu) = len x 4 ) 实际空间与理论空间的差 ( sz - len x 4) 上述程序的执行结果为： 1234|Length: 20194134|Real Size: 80776544|Raw Size(int(4)*length): 80776536|Gap: 8 这里会发现，编译器传递给new [ ]操作符的空间大小比实际需要多8个字节。而8个字节，恰好是一个long long变量的大小，实践中，这8个字节用于存储动态数组的元素个数。 为了弄清楚这8个字节的具体位置，我们重载了delete [ ]函数： 1234void operator delete[](void *o)&#123; cout&lt;&lt;\"Destruct from: \"&lt;&lt;o&lt;&lt;endl; free(o);&#125; 12345678int main()&#123; ... char* p1 = (char*) testArr; cout &lt;&lt; \"Address for the Array: \"&lt;&lt; testArr &lt;&lt;endl; ... delete[] testArr; return 0;&#125; 最后几行的输出为： 123Address for the Array: 0x2670048...Destruct from: 0x2670040 成了！我们发现，解构时得到的地址（0x2670040）恰好是数组的地址（0x2670048）减8。即：0x2670048 = 0x2670040 + 8接下来，我们更进一步，取出数组地址-8对应地址的一个long long变量，看一下它的值会是什么. 接下来获取该数组前的8字节，识别为long long并打印。 12345678int main()&#123; ... char* p1 = (char*) testArr; cout &lt;&lt; \"Address for the Array: \"&lt;&lt; testArr &lt;&lt;endl; cout&lt;&lt; \"The long long before the Array: \" &lt;&lt; *(long long*)(p1-len_ll)&lt;&lt;endl; delete[] testArr; ...&#125; 输出为： 123Address for the Array: 0x2670048The long long before the Array: 20194134 【这个值就是数组长度】Destuct from: 0x2670040 代码给出的结果证明了前述的猜想：自定义类数组前的8个字节，是一个long long类型的变量，储存了该数组的长度。 3. 结论 我们以Yu* a = new Yu[2]为例进行说明。表面上，我们需要sizeof(Yu) x 2共8个字节的空间，但事实上，new [ ]操作符会从堆里申请8 + 8 = 16个字节的空间。其中，前8个字节用于存储数组的元素个数，后续空间用于存放数组元素。具体到本例，变量a得到的是数组首元素的地址，它事实上等于真实的堆空间地址 + 8！ 当delete [ ]a被执行时： delete [ ]操作符会把a值 - 8，获得真实的堆空间首地址； 从堆空间首地址获得数组的元素个数（本例为2）； 依据元素个数及a值逐个执行全部数组元素的析构函数； 最后，以堆空间首地址为依据，通过free( )函数向操作系统归还堆空间。 本例中，如果执行delete a而不是delete [ ]a，可能导致两个后果： 仅有数组的首元素被正确析构； 释放堆空间时向操作系统提供的地址是不正确的，后果未知。 正是基于上述理由，书里反复强调，new/delete, new [ ] /delete [ ]要配对使用。 4. 完整实验代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;const long long len = 20194134;class Yu &#123;public: int iNumber; Yu()&#123;iNumber = 1;&#125; ~Yu()&#123;&#125; //重载 new[]操作符 void* operator new[](size_t sz)&#123; /*打印四个关键数据： ①数组的长度 ②new[]过程中申请的内存空间大小 ③数组实际需要的内存空间 ④ ②、③的差值 */ printf(\"|Length: %lld\\n|Real Size: %lld\\n|Raw Size(int(4)*length): %lld\\n|Gap: %lld\\n\",len,sz,len*4,(long long)sz-len*4); //完成内存分配 void* o = malloc(sz); return o; &#125; //重载delete[]操作符 void operator delete[](void *o)&#123; //打印析构的开端地址 cout&lt;&lt;\"Destruct from: \"&lt;&lt;o&lt;&lt;endl; //完成内存释放 free(o); &#125;&#125;;int main()&#123; // 打印long long的大小 int len_ll = sizeof(long long); cout&lt;&lt;\"Size of long long: \"&lt;&lt;len_ll&lt;&lt;endl; //生成一个长度为len(20194134)的Yu类型的数组 Yu* testArr = new Yu[len]; //获取该数组开头的地址并打印 char* p1 = (char*) testArr; cout &lt;&lt; \"Address for the Array: \"&lt;&lt; testArr &lt;&lt;endl; //获取该数组前的8字节，识别为long long 并打印 cout&lt;&lt; \"The long long before the Array: \" &lt;&lt; *(long long*)(p1-len_ll)&lt;&lt;endl; //释放数组空间 delete[] testArr; return 0;&#125; 完整输出： 12345678Size of long long: 8|Length: 20194134|Real Size: 80776544|Raw Size(int(4)*length): 80776536|Gap: 8Address for the Array: 0x2670048The long long before the Array: 20194134Destuct from: 0x2670040","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://codelearn.club/categories/C-C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://codelearn.club/tags/C/"}]},{"title":"C/C++程序的断点调试","slug":"qtdebug","date":"2020-02-20T07:16:04.000Z","updated":"2020-03-03T04:54:12.766Z","comments":true,"path":"2020/02/qtdebug/","link":"","permalink":"http://codelearn.club/2020/02/qtdebug/","excerpt":"本文以Qt Creator为例，简述C/C++程序断点调试的基本方法和过程。其它的IDE环境，大同小异。","text":"本文以Qt Creator为例，简述C/C++程序断点调试的基本方法和过程。其它的IDE环境，大同小异。 1. 简介在程序有BUG/缺陷，需要修复时，断点调试是发现缺陷的重要方法。对于初学者而言，断点调试还有另外一个用途：帮助理解程序背后的逻辑。 本文以Qt Creator为例，简述C/C++程序断点调试的基本方法和过程。其它的IDE环境，大同小异。 版权声明 本文可以在互联网上自由转载，但必须：注明出处(作者：海洋饼干叔叔)并包含指向本页面的链接。 本文不可以以纸质出版为目的进行改编、摘抄。 2. 程序代码在Qt Creator中创建一个Non Qt - Plain C Application （纯C控制台应用程序），然后录入如下代码： 12345678910111213141516171819202122232425262728293031//Project - DebugExample#include &lt;stdio.h&gt;#include &lt;stdbool.h&gt;bool isPrime(int n) &#123; //函数的定义 if (n&lt;=1) return false; for (int i=2;i&lt;n;i++) if (n % i == 0) return false; return true;&#125;int main()&#123; printf(\"Try to find all prime number(&lt;=10):\\n\"); int iFound = 0; //发现的质数个数 for (int i=2; i&lt;=10; i++) &#123; if (!isPrime(i)) continue; iFound++; printf(\"%d, \",i); &#125; printf(\"\\n%d prime numbers been found.\",iFound); return 0;&#125; 上述程序的用途在于找出2 ~ 10之间的全部质数并打印出来。请读者注意第19 ~ 21行，for循环的初始化语句，测试表达式，更新表达式故意分作了三行，以便于观察。 3. 断点 在第18行代码的行号左边（图中红框A处）单击鼠标，便会出现如图所示的断点（break point），在相同位置再次单击，断点便会消失。可以给同一段程序添加多个断点。 单击图中红框B内的按钮，断点调试开始。 4. 调试 与正常的程序运行不同，黑色的控制台界面一闪而过，程序将暂停在第18行的断点处。读者仔细观察，应可见第18行行左会出现一个黄色的箭头（图中标A处），该黄色箭头表明当前程序执行点，准确地说，箭头所指向的行是接下来准备执行的代码行。 在界面标B处，有一个列表，这个列表列出了程序当前执行阶段的局部变量的名称及当前值。可以看到，此时，有iFound变量存在，其值为0，类型为int。 展开调试菜单，可以看到很多与调试相关的菜单项。本文主要使用到两个，分别是单步跳过（F10）以及单步进入（F11)。在调试过程中，使用该菜单与直接按下F10、F11作用相同。本文主要使用快捷键来完成。读者需要注意，如果你使用的是笔记本电脑，笔记本电脑的F10、F11等键通常是复用的，你可能需要结合其它按键来触发F10、F11按键。如果实在弄不明白，也可以使用调试菜单。 按一下F10(单步跳过)，可以看到第18行被执行，黄色箭头指向第19行。此时，for循环内的局部变量i出现在右方的列表中，其值为16，这说明for循环局部变量i的空间已被分配，但for循环的初始化语句尚未执行，i还没有获得初始值0。 注意：在变量没有被初始化前，其值是不确定的，所以读者真实调试时，得到的值很可能不是16。 再次按下F10(单步跳过)，可以看到黄色箭头指向第23行。因为for循环初始化语句的执行，右方列表中i的当前值变成了2。 第23行涉及一次函数调用，如果操作者希望观察isPrime( )函数内部的执行过程，应按F11(单步进入)。如果操作者不关心isPrime( )内部的执行过程，只关心23行的总体执行结果，则按F10(单步跳过)。本次，我们按F11。 按下F11后，我们进入到了isPrime( )函数内部，黄色箭头指向第6行。对于isPrime( )函数而言，当前其局部变量仅有1个，即函数的形式参数n。该参数的值应由调用者传递进来。在右方的列表中，我们看到该值为2。 一直按F10，直到isPrime( )函数返回，由于2是质数，所以第23行的不是质数的条件不成立，第24行不会被执行，黄色箭头略过了第24行，指向了第25行。 按F10执行第25行后，黄色箭头指向第26行，iFound值由0变为1。 一直按F10进行循环，直到i = 4且黄色箭头指向第23行。 本次我们选择不进入isPrime( )函数，再次按下F10（单步跳过）。 由于i = 4不是质数，因此第23行的条件成立，黄色箭头跳转到第24行的continue语句。 根据continue的语义，其将略过本轮循环的剩余语句（第25 ~ 26行），直接尝试下一轮循环。 再次按下F10，可以看到，continue直接略过了第25 ~ 26行的剩余循环代码，直接跳到了for循环的更新表达式，如图中红色箭头所示。 再次按下F10, 可以看到更新表达式被执行，i值由4变成了5，黄色箭头指向了第19行，该行将进行循环测试(i &lt;= 10)，如果测试通过，则将执行循环体，否则循环结束。 说明：读者可能会疑惑，测试表达式在第20行，为何跳转到第19行？ 作者的回答：此处确实是在执行第20行的循环测试，调试器标指向第19行并不十分恰当。 5. 观察输出在Windows环境下，读者此时可以按Alt + Tab组合键切换到控制台窗口去观察到当前执行阶段为止的输出情况。 可以看到，2,3两个质数已被找出，4是合数被略过，正准备考察整数5。 说明：也可以在Windows任务栏中点击对应按钮切换到控制台输出窗口，见下图中红色方框所示。 6. 去除断点如果调试的目的已达成，准备放弃调试，可以再次单击红色断点将其取消，如下图： 此时，可以选择Continue （继续执行，F5），在没有断点的情况下将程序执行完；也可以选停止调试，强行中止程序的执行。 7. 继续执行取消断点后，我们选择了继续执行。程序执行完成后，Qt Creator与调试相关的箭头，右方的局部变量列表等均消失不见，恢复至常规编辑界面。 在控制台输出窗口中，可以看到程序执行的全部结果。","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://codelearn.club/categories/C-C/"}],"tags":[{"name":"Qt Creator","slug":"Qt-Creator","permalink":"http://codelearn.club/tags/Qt-Creator/"}]},{"title":"Visual Studio Code无法启动Jupyter的解决办法（v1.38-1.42)","slug":"vscjupyter","date":"2020-02-17T11:36:04.000Z","updated":"2020-03-03T05:02:50.660Z","comments":true,"path":"2020/02/vscjupyter/","link":"","permalink":"http://codelearn.club/2020/02/vscjupyter/","excerpt":"[该解决方案由重庆大学2018级数统学院罗少航同学提供] 故障现象： 在下述版本的Visual Studio Code上， v1.38 - 1.42， .ipynb(Jupyter Notebook)文件打开时会提示无法启动/连接Jupyter Server.","text":"[该解决方案由重庆大学2018级数统学院罗少航同学提供] 故障现象： 在下述版本的Visual Studio Code上， v1.38 - 1.42， .ipynb(Jupyter Notebook)文件打开时会提示无法启动/连接Jupyter Server. 解决方案： 进入Windows设置。 搜索并进入“编辑系统环境变量”； 点”环境变量“； 在上方的”Alex”的用户变量里，选Path, 点“编辑”。 （Alex是你的Windows登录用户名） 新建如下述高亮行所示的路径，请将其移动至顶端；注意如果你的解释器版本不是Python3.8下述目录中的Python38要作调整。 %AppData%\\Python\\Python38\\Scripts 然后一路确定，重启Visual Studio Code后尝试编辑和运行1.ipynb文件。（最好连计算机也重启一下）。","categories":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/tags/Python/"}]},{"title":"Windows环境下Qt Creator控制台输出中文乱码解决方法","slug":"qtconsolechinese","date":"2020-02-16T08:37:04.000Z","updated":"2020-03-03T05:16:23.735Z","comments":true,"path":"2020/02/qtconsolechinese/","link":"","permalink":"http://codelearn.club/2020/02/qtconsolechinese/","excerpt":"中文讨论Windows环境下Qt Creator控制台输出中文乱码的解决办法。","text":"中文讨论Windows环境下Qt Creator控制台输出中文乱码的解决办法。 1. 开发环境中文Windows 10 64bit, Qt Creator 4.11.0, mingw 7.3.0 64 bit 版权声明 本文可以在互联网上自由转载，但必须：注明出处(作者：海洋饼干叔叔)并包含指向本页面的链接。 本文不可以以纸质出版为目的进行改编、摘抄。 2. 故障现象​ Plain C/C++ Application在控制台输出中文时出现乱码。 程序如下： 12345678910111213141516171819202122232425//Project - EarthTime#include &lt;stdio.h&gt;#include &lt;time.h&gt;int main() &#123; time_t t; time(&amp;t); //获取当前时间,从1970年1月1日零时起经过的秒数 long long totalSeconds = (long long)t; //总秒数转换为long long类型 long long curSecond = totalSeconds % 60; //当前秒数 = 总秒数对60取余 long long totalMinutes = totalSeconds / 60; //总分钟 = 总秒数除60 long long curMinute = totalMinutes % 60; //当前分钟 = 总分钟对60取余 long long totalHours = totalMinutes / 60; //总小时 = 总分钟除60 long long curHour = totalHours % 24; //当前小时 = 总小时对24取余 printf(\"格林尼治时间 %lld 时 %lld 分 %lld 秒,1970年1月1日零时到现在经过了 %lld 秒.\", curHour,curMinute,curSecond,totalSeconds); /* printf的英文版本 printf(\"%lld:%lld:%lld, %lld seconds after 1970/1/1 00:00::00\", curHour,curMinute,curSecond,totalSeconds); */ return 0;&#125; 其执行结果包含乱码： 3. 解决方案images选择工具-&gt;选项菜单 在文本编辑器-显示中勾选 Display file encoding 右上角填UTF-8，弹出的对话框中选择System，选“按编码保存”。 保存之后，右上角显示的当前编码变为System. 再次编译执行，问题解决。 4. 后记问题事实上没有完全解决，下次再打开项目时，Qt Creator会以UTF-8读入事实上由System编码的文件，连源代码都会出现乱码。此时，可以通过按System编码读入来解决。 请读者不必纠正，大多数的应用开发，都是图形界面，控制台应用极少，控制台里还要使用中文的应用就更少了。 通过当整体开发环境的文件编码设置为System，或可解决问题。但作者不推荐这么做， 因为事实上，UTF-8是更通用的编码，它允许在同一个应用程序里同时显示多国文字。","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://codelearn.club/categories/C-C/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://codelearn.club/tags/C-C/"},{"name":"Qt","slug":"Qt","permalink":"http://codelearn.club/tags/Qt/"}]},{"title":"Qt Creator的简单使用方法","slug":"simpleqtuse","date":"2020-02-01T09:11:04.000Z","updated":"2020-03-03T05:17:27.608Z","comments":true,"path":"2020/02/simpleqtuse/","link":"","permalink":"http://codelearn.club/2020/02/simpleqtuse/","excerpt":"本文介绍使用Qt Creator进行C/C++编程的基本方法。","text":"本文介绍使用Qt Creator进行C/C++编程的基本方法。 版权声明 本文可以在互联网上自由转载，但必须：注明出处(作者：海洋饼干叔叔)并包含指向本页面的链接。 本文不可以以纸质出版为目的进行改编、摘抄。 1. Qt Creator启动安装完Qt后，在Windows开始菜单中可以找到Qt 5.14.1子目录（版本号不同，子目录名不同）。 单击Qt Creator 4.11.0(Community)即可启动Qt Creator。 考虑到后续使用方便，可以在桌面上创建一个快捷方式：用鼠标左键单击Qt Creator 4.11.0(Community)并按住不放，然后拖至桌面并释放鼠标左键。 点击右上角的最大化按钮将窗口最大化， Qt Creator启动完成，可以使用了。 2. 创建Non-Qt Project / Plain C Application选择菜单文件(File)-&gt;新建文件或项目（New File or Project ): 点选Non-Qt Project下的Plain C Application, 然后单击”Choose”, 将项目名称设为demo1; 可以看到，默认的项目路径是Windows当前登录用户的文档路径，对部分读者而言，该路径可能包括中文（目录和文件名最好不要包含非英文字符！，解释见后），稳妥起见，点”浏览”按钮， 在弹出的对话框里选择C盘，在对话框的空白处，右键单击鼠标，选择弹出菜单中的新建-&gt;文件夹， 新建一个名为C2Cpp的目录。 创建C:\\C2Cpp目录并“选择文件夹”后，勾选“设为默认项目路径”， 然后单击“下一步”， 直接点“下一步”， 直接点”下一步“， 如果读者计算机上出现了其它选项，说明读者可能安装了Qt的其它版本（比如MSVC 2017）， 建议完全卸载QT后严格按照作者的操作文档重新安装。 单击”完成“， 可以看到，demo1项目已经成功创建并打开，其项目文件为demo1.pro, 主程序为main.c。 在窗口的左下角，有一个绿色的三角形按钮（运行），点击此按钮将构建并运行当前项目。 点击运行按钮后，系统会进行构建/编译，然后一个黑色底的对话框内显示了执行结果: Hello World! 黑色对话框（Windows命令行）右上角的X按钮表示关闭窗口，点击此按钮，将关闭黑色对话框。 如果上述过程正确无误，恭喜你，你的Qt开发环境的安装和配置多半是成功的。 3. Qt Creator的基本操作3.1 关闭项目Qt Creator允许同时打开多个项目。为避免不必要的麻烦，我们建议初学者最好只同时打开一个项目。 当需要关闭某个项目时，选单击选中项目（如下图中的demo1), 然后选择文件菜单 –&gt; Close Project “demo1”, 该项目关闭后，可以看到项目列表为空。 3.2 打开已有的项目 方法1： 选择文件菜单-&gt; 打开文件或者项目， 定位到C:\\C2Cpp\\demo1目录，选中demo1.pro, 然后单击”打开“， 可见，demo1项目被成功打开： 方法2 在Windows的资源管理中，直接定位到项目文件demo1.pro, 然后双击，也可以打开该项目（Qt的安装程序将.pro文件与Qt Creator作了关联）。 3.3 项目栏的收起与展开在Qt Creator的左下角，有一个按钮（如下图），单击这个按钮可以帮助收起/展开项目栏。 当你书写代码时，可能希望整个屏幕都用于显示代码，此时，收取项目栏可以更好地利用屏幕空间。 3.4 文件的打开和关闭展开项目文件树后，双击main.c, 可见该文件被打开。 如果需要关闭该文件，请点击main.c后方的x按钮， 如下图所示。 3.5 代码字号调整在代码文件打开的情况下，先在代码编辑框中单击一下，确保当前编辑焦点在代码编辑框中。然后，按住Ctrl键不放，并滚动鼠标的滚轮（建议读者外接一个鼠标以便操作），可以看到代码的字号变化。 4. 创建Non-Qt Project / Plain C++ ApplicationC语言大约是C++语言的子集，当需要练习C++编程时，需要创建一个C++应用程序。 创建过程与创建C应用程序类似，唯一区别是新建项目时，应选择Non-Qt Project / Plain C++ Application，如下图所示： 在这里，我们创建一个名为demo2的C++应用程序。 请读者注意，为了避免初学者可能遇到的困难，本书中我们总是使用C:\\C2Cpp目录作为项目存储路径。 下图中，Qt Creator同时打开了两个项目：demo1和demo2， 其中, demo2为当前项目（字体更粗）。 main.cpp是demo2的主程序文件。此时，如果点击运行按钮，被编译和运行的将会是demo2项目。 在本书的前半部分，我们只需要创建和使用这种”原始“的C和C++项目。在本书的后半部分，我们还需要创建图形应用程序，具体方法到时再介绍。 5. 对初学者的忠告 对于键盘不熟悉的初学者，建议暂时关闭掉笔记本上的触摸板，仅使用外置鼠标（避免敲键盘时意外碰到触摸板误操作）。 仅使用英文字符来命名文件夹及程序文件。现代的编程语言，计算机，操作系统都起源于国外，对中文的支持不太好。记住：避免掉下悬崖摔死的最好办法不是练习高超的平衡术，而是远离悬崖！ 编程需要做大量的输入，输入的速度至关重要。没有掌握标准指法的初学者请逐步练习和使用标准指法，初期可能会浪费一点时间，后期会赚回来。一指禅威力过大，不宜日常使用。","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://codelearn.club/categories/C-C/"}],"tags":[{"name":"IDE","slug":"IDE","permalink":"http://codelearn.club/tags/IDE/"}]},{"title":"Windows环境下Qt C++开发环境的下载与安装","slug":"qt-install-win","date":"2020-01-31T09:33:04.000Z","updated":"2020-03-03T05:02:01.387Z","comments":true,"path":"2020/01/qt-install-win/","link":"","permalink":"http://codelearn.club/2020/01/qt-install-win/","excerpt":"Windows环境下Qt C++开发环境的下载与安装","text":"Windows环境下Qt C++开发环境的下载与安装 版权声明 本文可以在互联网上自由转载，但必须：注明出处(作者：海洋饼干叔叔)并包含指向本页面的链接。 本文不可以以纸质出版为目的进行改编、摘抄。 1. Qt的下载Qt有在线安装和离线安装两种模式，受限于国内有限的出口带宽，在线安装很困难，所以我们选择离线安装。 在浏览器中访问下述地址（直接单击下述链接也可以）： http://download.qt.io/official_releases/qt/ 页面装载后如下图： 可以看到该目录下有不同的Qt版本，一般选择最新的一个，此处，单击5.14，打开后可见下述两个子目录： 单击5.14.1子目录，打开后如下图： 如果准备在Windows系统下使用，单击qt-opensource-windows-x86-5.14.1.exe下载该离线安装包。如果你的网速不太好，也可以考虑右键单击qt-opensource-windows-x86-5.14.1.exe，然后在弹出菜单中选择复制链接地址，然后在诸如“迅雷”之类的下载工具中进行下载，如下图： 说明：Qt不断有新版本发布，读者看到的目录及文件名称可能与上述图片有差异。 2. Qt的安装找到之前下载的Qt离线安装包，大约2.4G, 在作者的电脑上，该文件如下图： 双击运行该文件，可见安装程序开始执行： 单击“Next”进入下一步，此页中要求使用Qt账号登录，如果没有，则注册(Sign-up)一个。输入正确的账号密码后，单击”Next”进行下一步。 勾选”I have read ….”, 然后单击下一步， 再次点击下一步， 一般使用默认安装路径，勾选下方的”Associate common file …”，然后单击”下一步”， 接下来选择准备安装的组件，千万不要选择”全选“， 这样安装的软件过于宠大，费时也太长。建议严格按照下图进行选择。然后选”下一步“。 下表对主要的组件进行了说明： 组件名称 说明（英文） 说明（中文） Qt 5.14.1 / MinGW 7.3.0 64-bit Qt 5.14.1 Prebuild Components for MinGW 7.3.0 64-bit 适用于MinGW 7.3.0 64-bit编译器的Qt 5.14.1预编译组件 Developer and Designer Tools / Qt Creator 4.11.0 IDE for Qt application development Qt应用程序的集成开发环境 Developer and Designer Tools / MinGW 7.3.0 64-bit MinGW-builds 7.3.0 64-bit toolchain MinGW 7.3.0 64-bit C/C++编译器(MinGW是Linux下gcc编译器的Windows版本) 说明：作为选项，在Windows环境下，用户也可以选择使用MSVC 2017 64-bit的编译器，但需要额外安装Visual Studio 2017中的C++编译器。对于初学者而言，过于麻烦，建议简单使用MinGW 7.3.0 64-bit编译器。 在下述对话框中勾选”I have read and agree to…”, 然后单击”下一步“， 这个对话框用于设置开始菜单中的目录名称，直接选”下一步“， 选择”安装“， 安装过程将持续很大一会儿， 勾选Launch Qt Creator后，单击完成将直接打开Qt Creator集成开发环境，这里，我们先把勾去掉，再单击”完成“。 至此，Windows环境下的Qt C++开发环境下载安装完成。","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://codelearn.club/categories/C-C/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://codelearn.club/tags/C-C/"},{"name":"Qt","slug":"Qt","permalink":"http://codelearn.club/tags/Qt/"}]},{"title":"Cython编译环境准备","slug":"cythonenv","date":"2020-01-19T12:50:04.000Z","updated":"2020-03-03T05:08:58.044Z","comments":true,"path":"2020/01/cythonenv/","link":"","permalink":"http://codelearn.club/2020/01/cythonenv/","excerpt":"本文讨论Windows环境下Cython编译环境的准备。","text":"本文讨论Windows环境下Cython编译环境的准备。 版权声明 本文可以在互联网上自由转载，但必须：注明出处(作者：海洋饼干叔叔)并包含指向本页面的链接。 本文不可以以纸质出版为目的进行改编、摘抄。 世界发展得太快，当读者阅读本书时，下述信息或许已经过时。 作者使用的是Windows 10环境下的64位的Python3.7解释器，所以作者安装了微软的Visual Studio社区版的”使用C++的桌面开发”部分，其中包括了VC 2017 version 15.9 v14.16以及相关的Windows SDK。该软件可以从 https://visualstudio.microsoft.com 获得。请注意，Visual Studio是一个非常宠大的IDE软件，除上述必要部分之外的请不要选择，否则非常耗时而且占据硬盘空间。 如果读者使用的是Linux, 则系统自带的gcc编译器通常足够使用。Linux下Cython代码的编译过程与下述过程相当，但细节或有区别。 读者还需要安装Cython模块，在Windows命令行或者Linux终端中运行pip install cython即可。","categories":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/tags/Python/"}]},{"title":"“实践 - 搬金盘的婆罗门”项目中的图片及音乐资源","slug":"hanoirsc","date":"2020-01-10T13:25:04.000Z","updated":"2020-03-03T04:59:01.913Z","comments":true,"path":"2020/01/hanoirsc/","link":"","permalink":"http://codelearn.club/2020/01/hanoirsc/","excerpt":"本书配套代码中HanoiTower项目目录下有resource子目录，其中存放了本游戏中使用的全部图片及音乐资源。","text":"本书配套代码中HanoiTower项目目录下有resource子目录，其中存放了本游戏中使用的全部图片及音乐资源。 版权声明 本文可以在互联网上自由转载，但必须：注明出处(作者：海洋饼干叔叔)并包含指向本页面的链接。 本文不可以以纸质出版为目的进行改编、摘抄。 资源名称 用途 background.png 游戏的背景图片 Serenity.mp3 游戏的背景音乐 blue … gray.png 盘图片，游戏中用于模拟柱上的金盘 runNormal, runFocused, runPushed, runDisabled.png… 按钮图标文件，每个按钮4个，依次为按钮“正常”，“高亮”，“按下”，“禁用”时的对应图片 读者如果希望设计一些游戏，可以试着从www.pixabay.com或者www.audionautix.com下载图片或音乐资源。这些网站提供的部分资源允许不经授权而免费使用，即便是出于商业目的。","categories":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/tags/Python/"}]},{"title":"人工智能的味道 - 图像风格迁移","slug":"imgstyle","date":"2019-11-07T14:36:04.000Z","updated":"2020-03-03T05:10:40.540Z","comments":true,"path":"2019/11/imgstyle/","link":"","permalink":"http://codelearn.club/2019/11/imgstyle/","excerpt":"Python是人工智能编程的首选语言，至少当作者在键盘上敲下这行话时，这是事实。作为一本Python基础入门性质的教科书，本书无法就Python在人工智能与深度学习中的应用展开深入讨论。要理解深度学习的内部细节，需要复杂的数学知识。不过作为应用层面的开发者，读者或者不需要理解深度学习复杂的数学细节，简单借助于开源的工具包和模型，也可以享受到人工智能的益处。本章通过图像风格迁移这个示例，让读者尝尝人工智能的味道。","text":"Python是人工智能编程的首选语言，至少当作者在键盘上敲下这行话时，这是事实。作为一本Python基础入门性质的教科书，本书无法就Python在人工智能与深度学习中的应用展开深入讨论。要理解深度学习的内部细节，需要复杂的数学知识。不过作为应用层面的开发者，读者或者不需要理解深度学习复杂的数学细节，简单借助于开源的工具包和模型，也可以享受到人工智能的益处。本章通过图像风格迁移这个示例，让读者尝尝人工智能的味道。 版权声明 本文可以在互联网上自由转载，但必须：注明出处(作者：海洋饼干叔叔)并包含指向本页面的链接。 本文不可以以纸质出版为目的进行改编、摘抄。 22. 人工智能的味道 - 图像风格迁移22.1 图像风格迁移 将上图中左上角图像的“风格”提取出来，应用到左下角的“原图”上，生成右方的图像，就是图像风格迁移的研究内容。 艺术风格是什么，即便在艺术家的视角看，也是见人见智的。显然不太可能从数学上准确地定义并求出图像的风格。到底怎么把一个缺乏明确数学定义的概念变成可以执行的程序，是困扰图像风格迁移的研究者的主要问题。 在将人工神经网络和深度学习应用于图像风格迁移之前，人们的主要思路就是分析某一种风格的图像，比如把毕加索画的全部画作进行统计分析，如小波分析，通过建立统计模型，然后迭代改变要做迁移的图像，让它更好地符合统计模型。这种方法有一个很大的缺点：一个程序只能做某一种风格或场景的图像风格迁移。 2015年，Gatsys等人在论文A Neural Algorithm for Artistic Style中首次将人工神经网络用于图像风格迁移，斯坦福大学的李飞飞和她的学生Justin Johnson等人于2016年进一步改进了算法，提高了图像风格迁移的速度。本章示例程序中图像风格迁移就是以Justin Johnson等人训练的深度神经网络模型为基础的。 22.2 深度神经网络人工智能是一个研究了很多年的课题。它有众多的学派，其中符号学派将机器学习看作逆向演绎，联结学派对大脑进行逆向分析和模拟，进化学派在计算机上模拟生物进化，贝叶斯学派认为学习是一种概率推理形式，理论根基在于统计学。其中，联结学派的主要工具就是人工神经网络，人工神经网络模拟了大脑神经元和神经元间突触连接的结构和工作方式。而深度神经网络又是人工神经网络的一种。 上图展示了一个深度神经网络(Deep Neural Network) - DNN的示意图。图中的节点称之为神经元，神经元之间的连线模拟了人类大脑中脑细胞之间的突触连接。可以简单地认为，每个神经元具备计算或者是信号处理的功能，它通过突触从别的神经元获取输入，经过计算/处理后再通过突触向其它神经元输出信号。我们已知，大脑细胞之间的每个突触连接，其离子通道的导电能力是有差异的。与之对应，神经网络神经元之间的连接权重参数用来表征该连接的重要程度。 神经元的层次，数量，神经元之间的连接关系可以称为神经网络的结构。突触连接的权重、偏倚等信息则称为神经网络的参数。为满足特定任务的需要，比如在各种图片或者视频中识别出猫，工程师会设计特定的神经网络结构，并将大量经过标注的资料图片（图片中有猫的位置被人工标记）输入神经网络的输入层，通过神经网络的计算，从输出层获得识别结果，然后根据识别错误反向修改神经网络内部的参数，经过多次迭代后，神经网络的内部参数被修正到即便对于标注资料外的图片，神经网络也能识别出猫的程度。这一过程称为神经网络的训练。训练的结果称为模型，它包括了神经网络的结构以及内部参数。 猫长什么模样，在数学上很难精确定义。我们可以认为，上述神经网络的训练过程有点类似于人类学习的过程，经过训练的神经网络模型包括了“何种模式的图像是猫”的知识。这种知识虽然说不清道不明，但在实践中却非常有效。 同理，将梵高的星空等相似风格的画作作为数据集，也可以对深度神经网络进行训练，训练所得的模型包含了这类画作的”风格是什么“以及”如何把另一幅图片变成这种风格”的知识。本章的示例程序就是借助于Justin Johnson等人训练好的图像风格迁移网络模型，对图片进行风格应用的。在调入模型，创建好深度神经网络后，将图片”输入“给图像风格迁移网络，该网络会进行一系列的迭代计算，其输出就是应用了对应风格的被修改过的图片。 22.3 程序解读本章的示例程序包含在目录C22_StyleTransfer当中，主程序为StyleTransfer.py。子目录images用于存储风格迁移的输入图片，models子目录用于存储风格图片及对应的图像风格迁移网络模型文件。其中，模型文件需要读者自行下载，详情请见Readme.txt。 该程序需要用到opencv-python以及matplotlib库。opencv是著名的C++语言编写的计算机视觉及图像处理工具包，本程序中，主要用它来读取、转换图片以及进行图像风格迁移网络的计算。matplotlib在本程序中用于交互和图片显示。 22.3.1 程序的使用先下载并将模型文件(扩展名为.t7)存入models子目录。在Visual Source Code中打开StyleTransfer目录，打开StyleTransfer.py并运行即可。按上下方向键可以切换图片，按左右方向键则可以切换风格模型。如本章开始的样图所示，左上角是风格图片，左下角是原图，右边则是风格迁移的结果图片。由于风格迁移网络的计算量很大，所以切换图片或者风格时反应较慢。 22.3.2 数据结构123456789101112class App: def __init__(self): self.idxImage = 0 #当前被风格迁移的图片在images列表中的下标 self.idxModel = 0 #当前使用的模型文件在models列表中的下标 self.images = glob.glob(\"images/*.jpg\") self.paintings,self.models = [],[] t = glob.glob(\"models/*.jpg\") for x in t: m = x[:-3] + \"t7\" #模型文件的扩展名为.t7, 基本名与对应的风格图片相同 if os.path.exists(m): #仅在风格图片及模型文件同时存在时，将二者加入列表 self.paintings.append(x) self.models.append(m) 为了避免过多的全部变量污染名字空间，作者把相关信息组织在App类型中。 数据成员 - images: 包含images子目录内全部jpg图片文件路径的列表，形如[‘images\\1.jpg’, ‘images\\2.jpg’, ‘images\\3.jpg’]。- paintings: 包含models子目录风格图片路径的列表，形如[‘models\\candy.jpg’, ‘models\\composition_vii.jpg’,…]。- models: 包含models子目录内模型文件路径的列表，形如[‘models\\candy.t7’, ‘models\\composition_vii.t7’,…]。 paintings与models列表内的风格图片与模型是一一对应的，且文件基本名相同，仅扩展名不同。- idxImage: 当前被风络迁移的内容图片在images列表中的下标。- idxModel: 当前使用的模型文件在models列表中的下标。 glob.glob(“images/*.jpg”) 遍历images子目录，找出其中的全部jpg文件，生成一个包含全部jpg文件路径字符串的列表。上述图像风格迁移网络的模型文件的扩展名为.t7，这是PyTorch的数据保存格式。而PyTorch是Facebook的深度学习开源工具包，具体一点可以把PyTorch看做加入了GPU 支持的numpy，同时也可以看成一个拥有自动求导功能的强大的深度神经网络。 22.3.3 风格迁移123456789101112131415161718import cv2 as cv #导入opencv库class App: ... def styleTransfer(self): net = cv.dnn.readNetFromTorch(self.models[self.idxModel]) #cv2.dnn_Net net.setPreferableBackend(cv.dnn.DNN_BACKEND_OPENCV) #设置计算后台类型 inImg = cv.imread(self.images[self.idxImage]) #读取输入的内容图片 inp = cv.dnn.blobFromImage(inImg, 1.0, (inImg.shape[1],inImg.shape[0]), (103.939, 116.779, 123.68), swapRB=False, crop=False) net.setInput(inp) outImg = net.forward() outImg = outImg.reshape(3, outImg.shape[2], outImg.shape[3]) outImg[0] += 103.939 outImg[1] += 116.779 outImg[2] += 123.68 outImg /= 255 outImg = outImg.transpose(1, 2, 0) return inImg, outImg 类App的styleTransfer()函数应用当前的图像风格迁移网络模型将当前内容图片风格迁移成输出图片。函数返回的inImg即为输入的内容图片，outImg则为输出图片，两者都是numpy三维数组。 读者可能会感到诧异，如此复杂的功能居然只有这么少的代码。是的，当你站在前人的肩膀上，只是调库（调用别人开发好的库）时，就是这么简单。 代码说明 - net = cv.dnn.readNetFromTorch() - 加载Torch格式的配置网络及其参数。执行后，net的类型为cv2.dnn_net，是一个深度神经网络。- cv.imread()函数用于读取图像文件，其返回一个numpy的三维数组，其维度依次为图像的像素高，图像的像素宽，像素颜色通道数（通常为3）。 - 接下来，blobFromImage将inImg进行转换，变成深度神经网络所接受的数据格式；net.setupInput(inp)则把转换后的数据设定为神经网络的输入; net.forward()则应用神经网络进行计算，并在其输出层得到输出图像outImg；outImg也是一个numpy多维数组，其维度与数据格式与常规的图像有所不同；所以后续代码对其进行了一些格式变换。- 最后，函数返回inImg-输入图像, outImg-输出图像两个用于表示图像的多维数组。 22.3.4 图像显示与刷新12345678910111213class App: ... def refresh(self,fig,axStyle,axIn,axOut): print(\"Style tranfering...\") self.idxImage = self.idxImage % len(self.images) self.idxModel = self.idxModel % len(self.models) inImg, outImg = self.styleTransfer() print(\"Rendering...\") styleImg = cv.imread(self.paintings[self.idxModel]) axStyle.imshow(cv.cvtColor(styleImg,cv.COLOR_BGR2RGB)) axIn.imshow(cv.cvtColor(inImg, cv.COLOR_BGR2RGB)) axOut.imshow(cv.cvtColor(outImg, cv.COLOR_BGR2RGB)) fig.canvas.draw() 函数refresh()负责对当前内容图像进行风格迁移运算，并将风格风像，内容图像，迁移后的输出图像显示在对应的子图(Axes)中。其中，axStyle用于显示风格图像，axIn显示内容图像，axOut用于显示输出图像。 self.idxImage和self.idxModel分别对len(self.images)和len(self.models)进行求模，目的是防止列表的越界访问（后续代码中，切换图片和风格时没有进行越界限制）。 axStyle/axIn/axOut.imshow()负责将图像显示在子图中。请注意，在显示之前，还应用cv.cvtColor()函数进行了一次图像格式转换，这是因为OpenCV中的图像其颜色通道顺序为BGR，即三维数组第三维中下标0对应蓝色，下标1对应绿色,下标2对应红色；而Matplotlib中，图像的颜色通道顺序为RGB，为了能正确显示，交换一下颜色通道顺序。 1234567891011...fig = plt.figure(figsize=(12,6))axStyle = plt.subplot(231) axIn = plt.subplot(234)axOut = plt.subplot2grid((2,3),(0,1),rowspan=2,colspan=2)plt.subplots_adjust(0,0,1,1,0,0) #设置子图间的间距为0for ax in (axStyle,axIn,axOut): ax.set_axis_off() #子图不显示坐标轴app.refresh(fig,axStyle,axIn,axOut) #刷新显示 fig.canvas.mpl_connect('key_release_event',on_key_release) #连接键盘事件响应函数plt.show() 我们在matplotlib中创建1个图和3个子图。plt.subplot(231)将图的可视区域等分成2行3列，然后在第1个区域创建一个子图。同理，plt.subplot(234)将图的可视区域等分成2行3列，然后在第4个区域（即第2行的第1个区域)创建子图。上述第1个区域，第4个区域是从1开始计数的。 plt.subplot2grid()也是将图的可视区域分成2行3列，然后在第0行的第1列开始创建子图，子图横向占2列，纵向占两行。这里的第0行，第1列从0开始计数，显然，这里的计数方式跟subplot()函数不同。读者不必为此感到困惑，这没有为什么。作者将此差异视作matplotlib设计者犯下的一个小错误，如果全部保持相同的计数规则，对于使用者而言，可能可容易理解一些。 fig.canvas.connect()函数连接键盘松开事件至on_key_release()函数， 当读者松开(release)键盘按键时，on_key_release()函数将被调用执行。 22.3.5 交互响应123456789101112def on_key_release(event): if event.key == 'up': app.idxImage-=1 elif event.key == 'down': app.idxImage+=1 elif event.key == 'left': app.idxModel-=1 elif event.key == 'right': app.idxModel+=1 else: return app.refresh(fig,axStyle,axIn,axOut) on_key_release()函数响应按键松开事件。如果是上-up, 下-down键，修改idxImage切换内容图片；如果是左(left)，右(right)键，修改idxModel切换图像风格迁移网络模型。最后，调用app.refresh()函数进行风格迁移和界面刷新。 22.4 小结下图是重庆大学虎溪校区图书馆及其在云湖上的倒影经过风格迁移后的效果。 现实中很多类似的计算问题，人类无法对相关概念进行准确的数学定义。比如：什么是图像的风格？ 何种形式的图像模式是一只猫？ 在乳腺X片里，什么样的图像可能是恶性的结节？ 在这种情况下，使用经过标注的数据集来训练神经网络，经过训练的神经网络从数据集中学习了相关的知识。这些知识包含在神经网络的内部参数中。即便这种知识的表达和真正的数学含义有些说不清，道不明，但我们仍然可以应用这些经过训练的神经网络来解决各种现实问题。","categories":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/categories/Python/"},{"name":"人工智能","slug":"Python/人工智能","permalink":"http://codelearn.club/categories/Python/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/tags/Python/"},{"name":"图像风格迁移","slug":"图像风格迁移","permalink":"http://codelearn.club/tags/%E5%9B%BE%E5%83%8F%E9%A3%8E%E6%A0%BC%E8%BF%81%E7%A7%BB/"},{"name":"深度学习","slug":"深度学习","permalink":"http://codelearn.club/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"DNN","slug":"DNN","permalink":"http://codelearn.club/tags/DNN/"}]},{"title":"浅尝则止 - SciPy科学计算","slug":"scipy","date":"2019-11-07T14:32:04.000Z","updated":"2020-03-03T05:17:14.813Z","comments":true,"path":"2019/11/scipy/","link":"","permalink":"http://codelearn.club/2019/11/scipy/","excerpt":"SciPy以NumPy为基础，提供了众多数学、科学、工程计算用的模块，包括但不限于：线性代数、常微分方程求解、信号处理、图像处理、稀疏矩阵处理。 本章适合那些有较好高等数学、线性代数、概率论基础的工科学生或从业者阅读。其他读者可以跳过，不影响后续章节。为减轻“数学恐惧症”患者的恐惧，作者尽量选择相对容易的“数学”案例来进行解读。","text":"SciPy以NumPy为基础，提供了众多数学、科学、工程计算用的模块，包括但不限于：线性代数、常微分方程求解、信号处理、图像处理、稀疏矩阵处理。 本章适合那些有较好高等数学、线性代数、概率论基础的工科学生或从业者阅读。其他读者可以跳过，不影响后续章节。为减轻“数学恐惧症”患者的恐惧，作者尽量选择相对容易的“数学”案例来进行解读。 版权声明 本文可以在互联网上自由转载，但必须：注明出处(作者：海洋饼干叔叔)并包含指向本页面的链接。 本文不可以以纸质出版为目的进行改编、摘抄。 21. 浅尝则止 - SciPy科学计算21.1 常数scipy.constants包含了众多的物理常数。 1234#Constants.pyfrom scipy import constants as Cprint(\"c =\",C.c) #光在真空中的传播速度print(\"g =\",C.g) #重力常数 执行结果 12c&#x3D; 299792458.0g&#x3D; 9.80665 其中，physical_constants是一个字典，它以物理常量名为键，对应值为一个三元素元组，分别是常数值、单位以及误差。下述程序可以打印其中的全部物理常数。下述程序执行结果中的electron volt常数表明了电子伏特与焦耳的换算关系。 1234#EnumConstants.pyfrom scipy import constants as Cfor k,v in C.physical_constants.items(): print(k,v) 执行结果 123...electron volt (1.6021766208e-19, &#39;J&#39;, 9.8e-28)... constants模块还可以帮助进行单位转换，其中的单位转换常量可将英制单位以及公制非标准单位全部转换成公制标准单位： 123456#Unit.pyfrom scipy import constants as Cprint(\"C.mile =\",C.mile) #一英里等于多少米print(\"C.gram =\",C.gram) #一克等于多少千克print(\"C.pound =\",C.pound) #一磅等于多少千克print(\"C.gallon =\",C.gallon) #一加仑等于多少立方米 执行结果 1234C.mile &#x3D; 1609.3439999999998C.gram &#x3D; 0.001C.pound &#x3D; 0.45359236999999997C.gallon &#x3D; 0.0037854117839999997 21.2 特殊函数special模块包括了数量众多的基本及特殊数学函数。下述程序可以打印这些函数的列表： 1234#Special.pyfrom scipy import special as Simport pprintpprint.pprint([x for x in dir(S) if not x.startswith(\"_\")]) 我们简要地介绍两个函数。Gamma函数Γ在统计学中有重要应用，其定义为：$$Γ(z)=\\int_0^{\\infty}{t^{z-1}e^{-t}dt}$$special模块的gamma()函数可计算上述函数的值。 1234#Gamma.pyimport scipy.special as Sprint(\"gamma(5)=\",S.gamma(5))print(\"gamma(1+1.2j)=\",S.gamma(1+2.1j)) #复数参数 执行结果 12gamma(5)&#x3D; 24.0gamma(1+1.2j)&#x3D; (0.13138722151786375+0.02710705024601709j) 受限于计算机内部浮点数的表达形式，计算机无法表达非常接近于1的实数，但可以表达非常接近于0的实数。比如，下述的v1的期望值是1.0 + 1e-25，但实际打印出来，其值为1.0。使用math.log(v1)求对数，就是对1.0求对数，结果为0.0。 123456789#Log1p.pyimport mathimport scipy.special as Sv1 = 1.0 + 1e-25print(\"v1=\",v1, \" #1.0 + 1e-25\")print(\"math.log(v1)=\",math.log(v1))v2 = 1e-25print(\"v2=\",v2)print(\"S.log1p(v2)=\",S.log1p(v2)) 执行结果 1234v1&#x3D; 1.0 #1.0 + 1e-25math.log(v1)&#x3D; 0.0v2&#x3D; 1e-25S.log1p(v2)&#x3D; 1e-25 special模块中的log1p()函数解决了这个问题，log1p(x)形式上等价于log(1+x)，但其内部小心地避免了用浮点数来表达1 + x。从上述程序的执行结果看，log1p(v2)非常好地计算了1+v2，也就是1+1e-25的对数值。 21.3 优化-optimizeoptimize模块提供了许多数值优化算法，提供非线性方程组求解、最小二乘法拟合、计算函数局域或者全域最小值等功能。在这里，我们介绍一下最小二乘拟合算法。 假设已知变量y和变量x之间存在函数关系y = f(x)。通过实验，我们观察到一些离散的实验数据(xi, yi)，然后，通过这些实验数据，来确定上述函数关系中的参数。比如，如果y与x之间满足形如y = kx+b的函数形式，那么，最小二乘法拟合就是要找到最佳的参数集p = {k,b}，使得下述函数S的值为最小：$$S(p)=\\sum_{i=1}^{m}[y_i-f(x_i,p)]^2$$粗浅地说，就是要找到最佳的k和b，使得通过函数关系计算出来的y值与实验数据尽可能一致。 微实践 - 最小二乘估计客观视力眼科医学实践中，有时会有患者出于特殊目的不愿意配合普通的视力表检查，试图假装“眼盲”来获取不恰当的经济利益，这在工作伤害和人身伤害纠纷中很常见。一种称为视觉诱发电位的检查技术可以鉴别受检者的诈盲。当向受检者呈现特定空间频率的刺激图形时，受检者的视觉皮层会因为分辨出刺激图形而产生脑电信号，这种脑电信号的产生不以受检者的主观意志为转移。通过安置于头部特殊位置的皮肤电极，可以采集受检者接受不同空间频率刺激时的脑电信号，用来以帮助评价受检者真实的客观视力。眼科学大夫们相信，受检者的视觉诱发电位信号的振幅与其可鉴别的刺激图形空间频率间存在着函数关系。本例中，我们假设该函数形为 y = kx + b。 现在有一位受检者，我们测得了下述实验数据，其中，cpd为空间频率，这个值越高，说明刺激图形越精细（对应标准对数视力表更下方的E形符号）。 空间频率/cpd 信号振幅/μV 空间频率/cpd 信号振幅/μV 4.02 8.11 6.04 10.43 8.05 6.72 10.06 6.09 12.07 4.3 13.48 5.04 15.09 3.23 17.3 1.66 20.12 1.03 24.14 1.58 接下来，我们应用这些数据来进行最小二乘拟合。 1234567891011121314151617181920#Leastsq.pyimport numpy as npfrom scipy import optimizefrom matplotlib import pyplot as pltx = np.array([4.02,6.04,8.05,10.06,12.07,13.48,15.09,17.3,20.12,24.14])y = np.array([8.11,10.43,6.72,6.09,4.3,5.04,3.23,1.66,1.03,1.58])def residuals(p): \"计算以p=(k,b)为参数的直线与实验数据之间的误差\" k,b = p print(\"try k=\",k,\"b=\",b) return y - (k*x+b)#leastsq()使得residuals()函数的输出数组的平方和为最小,[1,0]为初值r = optimize.leastsq(residuals,[1,0])k,b = r[0]print(\"k=\",k,\"b=\",b)#计算y=0时的x值print(\"x value when y=0:\",-b/k) 执行结果 1234567891011try k&#x3D; 1 b&#x3D; 0try k&#x3D; 1.0 b&#x3D; 0.0try k&#x3D; 1.0 b&#x3D; 0.0try k&#x3D; 1.0000000149011612 b&#x3D; 0.0try k&#x3D; 1.0 b&#x3D; 1.4901161193880158e-08try k&#x3D; -0.44638664967780084 b&#x3D; 10.63854270941558try k&#x3D; -0.4463866430261214 b&#x3D; 10.63854270941558try k&#x3D; -0.44638664967780084 b&#x3D; 10.638542867942219try k&#x3D; -0.446386640389808 b&#x3D; 10.638542630761927k&#x3D; -0.446386640389808 b&#x3D; 10.638542630761927x value when y&#x3D;0: 23.832573979973503 上述代码中，residuals(p)中的参数p为当前k值和b值构成的元组(k,b)。该函数根据x数组以及k,b参数计算理论y数组 - k*x+b， 然后用实验y数组减去理论y数组，得到误差数组。显然，返回的误差数组是一个长度为10的一维数组（x,y的长度均为10)。 leastsq(residuals,[1,0])以k=1, b=0为初始值，然后按照一定的数学规则去尝试不同的k,b值，直到residuals()返回的误差数组的平方和为最小。上述程序的输出结果中，我们可以看到leastsq()函数尝试过的不同的k,b值。 计算出k,b值后，y与x的函数关系也就确定：y = -0.45x + 10.64。在本例中，正常的人视力极限就是那个导致视觉诱发电位的振幅信号消失(=0)的最大空间频率。现在令y=0，则x = -b/k = 23.83。也就是说，当刺激图形的频率增加到23.83cpd时，受检者的视觉皮层不能产生有效的视觉诱发电位信号，这个空间频率就是受检者的视力极限。根据换算，该受检者的视力为20/25（Snellen视力表示法），换算成国内常用的对数视力就是0.8。请读者忽略眼视光学中空间频率至视力的换算关系。 我们使用下述代码绘制了实验数据的散点图以及拟合后的曲线： 12345678910#Leastsq.py...plt.scatter(x,y,label=\"Test Points\") #画散点图X = np.linspace(0,30,100) #画直线图Y = k*X + bsLabel = \"$y=&#123;:.2f&#125;x+&#123;:.2f&#125;$\".format(k,b)plt.plot(X,Y,label=sLabel)plt.legend() #显示图示plt.show() 执行结果 plt.scatter()用于绘制散点图， 共有10个点，每个点的横坐标来自实验x数组，纵坐标则来自实验y数组。label参数用于指定图示。接下来，我们生成了值域为0-30共100个数的等差数列X，再使用k,b参数计算出拟合直线的Y数组，最后用plt.plot(X,Y,label=sLabel)绘制拟合直线的折线图。注意，此处的sLabel以”$”符号开头和结束，这是LaTeX语法，专门用于生成数学公式。plt.legend()负责将右上角的图示显示出来。 21.4 线性代数-linalgnumpy和scipy都有线性代数模块linalg，scipy的linalg更全面。借助于linalg模块，可以轻松解决解线性方程组、求最小二乘解、求特征值和特征向量、奇异值分解等线性代数问题。这里，我们讨论最简单的解线性方程组。 常规意义上的线性方程组表现为Ax = b的形式，其中A为n行n列的方阵，b为长为n的向量。 解线程方程组，就是要计算x = A-1b。x也应为一个长为n的向量。当然，x,b也可视为n行1列的矩阵。 ​ 方法1：我们先求A的逆，再乘以矩阵b。 12345678910111213141516#Linalg1.pyimport numpy as npfrom scipy import linalgimport timeitn = 10A = np.random.rand(n,n) #随机数矩阵A(10,10)b = np.random.rand(n) #随机数矩阵b,(10,)print(\"shape of A:\",A.shape)print(\"shape of b:\",b.shape)x = np.dot(linalg.inv(A),b) #A求逆，再乘以bprint(\"x=\",x)print(\"shape of x:\",x.shape) #结果矩阵x,(10,)print(\"Time cost of 100 runs:\",end=\"\\t\")print(timeit.timeit(\"np.dot(linalg.inv(A),b)\", number=100, globals=globals())) 执行结果 123456shape of A: (10, 10)shape of b: (10,)x&#x3D; [-0.28212025 -1.33259652 0.84617787 -0.2331461 1.00000274 1.08582473 -0.83282803 -0.65152769 -0.34456785 1.3682035 ]shape of x: (10,)Time cost of 100 runs: 0.01988152700000001 这里的linalg.inv(A)对矩阵A求逆，np.dot()负责计算两个矩阵的乘积。timeit.timeit()函数将上述核心求解过程执行100次，统计总执行时间，单位为秒。其中，numer参数指定重复计算的次数，globals=globals()把当前作用域字典传递给timeit()函数，以便其内部重复执行np.dot(linalg.inv(A),b)时使用。可以看到，计算100次，总耗时0.0199秒，即19.9毫秒。 ​ 方法2: 12345678910#Linalg2.py...n = 10A = np.random.rand(n,n)b = np.random.rand(n)...x = linalg.solve(A,b) #唯一区别：使用linalg.solve()进行计算...print(\"Time cost of 100 runs:\",end=\"\\t\")print(timeit.timeit(\"linalg.solve(A,b)\", number=100, globals=globals())) 执行结果 123456shape of A: (10, 10)shape of b: (10,)x&#x3D; [ 2.38796492 2.47056651 -2.20444094 2.52781153 -0.63039871 -2.97342647 0.93749006 1.43893311 -1.51257363 0.02269402]shape of x: (10,)Time cost of 100 runs: 0.006561185000000025 方法2当中，我们没有借助于显式的矩阵求逆和矩阵乘法，而是借助于linalg.solve()方法。从timeit()的计时看，同样的数据规模，同样执次100次，费时为6.6毫秒，比方法1要快。作者这里需要说明，把n的值变大一些，比如100，再把执行次数改为10000，才能更好地排除偶然因素对执行时间的影响。 更一般地，任何C=A-1B形式的矩阵运算，都可以用linalg.solve()求解，其形式为C = linalg.solve(A,B)。 21.5 数值积分-integrateintegrate模块提供了好几种数值积分的方法，包括常微分方程组(ODE)的数值积分。相关函数列表如下： 函数名 作用 函数名 作用 quad() 一元定积分 dblquad() 二元定积分 triquad() 三元定积分 odeint() 计算常微分方程组的数值解 微实践 - 定积分求解​ 本小节求解下述定积分：$$\\int_{0.7}^4(cos(2\\pi x)e^{-x}+1.2)\\mathrm{d}x$$为了方便说明，我们先使用下述代码画出示意图： 123456789101112131415#Integrate1.pyimport numpy as npfrom matplotlib import pyplot as pltx = np.linspace(0,6,1000)y = np.cos(2*np.pi*x)*np.exp(-x)+1.2plt.axis([np.min(x),np.max(x),0,np.max(y)]) #坐标范围plt.plot(x,y,label=\"$cos(2\\pi x)e^&#123;-x&#125;+1.2$\") #画曲线，带图示plt.fill_between(x,y1=y,y2=0,where=(x&gt;=0.7)&amp;(x&lt;=4), #填充积分区域 facecolor='blue',alpha=0.2)plt.text(0.5*(0.7+4),0.4,r\"$\\int_&#123;0.7&#125;^4(cos(2\\pi x)e^&#123;-x&#125;+1.2)\\mathrm&#123;d&#125;x$\", horizontalalignment='center',fontsize=14) #增加说明文本plt.legend() #显示图示plt.show() 执行结果 plt.axis()函数设定了图的坐标范围。fill_between(x,y1=y,y2=0,where=(x&gt;=0.7)&amp;(x&lt;=4)…)则用于填充积分区域，其中，x和y1构成曲线1; x和y2=0构成曲线2(也就是横坐标线)；该函数填充两条曲线之间x值域为[0.7,4]的部分，where参数指明了这个值域。facecolor指定填充颜色，alpha参数指定透明度。 plt.text()则在图上添加文本，前两个参数指定了文本的坐标位置，horizontalalignment=’center’要求文本在指定的位置水平居中摆放(指定位置位于文本的水平中心)。r”$…$“为文本内容：字符串前加r表示放弃对字符串内的内容进行\\转义；两个$包含起来说明其中的内容为LaTeX格式的公式。 显然，上述定积分就是图中阴影部分的面积。 ​ 方法1：分成小矩形，计算面积和 12345678#Area.pyimport numpy as npx = np.linspace(0.7,4.0,1000)y = np.cos(2*np.pi*x)*np.exp(-x)+1.2dx = x[1] - x[0] #每个矩形的宽度fArea = np.sum(y*dx) #矩形宽*高，再求和print(\"Integral area:\",fArea) 执行结果 1Integral area: 4.032803310221616 上述代码中，把曲线的阴影部分分成1000个矩形，每个矩形的宽都是dx，第i个矩形的高则是yi。每个矩形的长乘宽，再求和，得积分面积。注意，上述x,y均是形状为(1000,)的数组。 ​ 方法2：使用quad()函数进行积分 12345678910#Quad.pyimport mathfrom scipy import integratedef func(x): print(\"x=\",x) #用于展示quad()函数对func的多次调用 return math.cos(2*math.pi*x)*math.exp(-x)+1.2fArea,err = integrate.quad(func,0.7,4)print(\"Integral area:\",fArea) 执行结果 1234567x&#x3D; 2.35x&#x3D; 0.7430542279466668x&#x3D; 3.9569457720533334x&#x3D; 2.4613227224815875...x&#x3D; 3.4178741117287044Integral area: 4.029065401143393 首先，我们定义了一个函数func()，它根据x计算y值。当对单个数值进行计算时，numpy的ufunc并不具备速度优势，所以我们使用了math模块。 integrate.quad()专门用于计算一元定积分，fArea,err = integrate.quad(func,0.7,4)取x值域[0.7,4]进行数值积分，在积分过程中，会反复调用func()函数计算y值。其返回一个元组，包括积分结果及误差。 integrate.quad()计算的积分会比方法1的矩形面积求和方法更加精确。 微实践 - Lorenz吸引子常微分方程组求解在“数学之美”那一章里，为方便读者理解，Lorenz吸引子轨迹的计算采用了比较“原始”的方法。采用integrate模块中的odeint()函数可以更加方便地完成计算。Lorenz吸引子由下述三个微分方程定义：$$\\frac{dx}{dt}=\\sigma(y-x), \\quad \\frac{dy}{dt}=x(\\rho-z)-y,\\quad \\frac{dz}{dt}=xy-\\beta z$$其中，σ, ρ, β为参数。这些方程定义了三维空间中的一个无质量点(x,y,z)的各轴坐标相对于时间的速度矢量。我们这里需要计算随着时间t的变化，无质量点(x,y,z)的运动轨迹，也就是一组时间点上的系统状态。 ​ 源代码如下： 12345678910111213141516171819202122#Lorenz.pyimport numpy as npfrom scipy import integrateimport matplotlib.pyplot as pltfrom mpl_toolkits.mplot3d import Axes3Ddef lorenz(p,t,s,r,b): x,y,z = p.tolist() #无质量点的当前位置(x,y,z) print(\"x,y,z,t:\",x,y,z,t) #帮助理解odeint的执行过程 return s*(y-x),x*(r-z)-y,x*y-b*z #返回dx/dt,dy/dt,dz/dtt = np.arange(0,30,0.01)track1 = integrate.odeint(lorenz,(0.0,1.00,0.0),t,args=(10.0,28.0,2.6))track2 = integrate.odeint(lorenz,(0.0,1.01,0.0),t,args=(10.0,28.0,2.6))print(\"type(track1):\",type(track1),\"track1.shape:\",track1.shape)fig = plt.figure(figsize=(12,6))ax = fig.gca(projection='3d') #获取当前子图，指定三维模式ax.plot(track1[:,0],track1[:,1],track1[:,2],lw=1.0,color='r') #画轨迹1 ax.plot(track2[:,0],track2[:,1],track2[:,2],lw=1.0,color='g') #画轨迹2 ...plt.show() 控制台输出： 123456...x,y,z,t: -5.64346434502397 -6.711791064199058 21.875348370569984 12.728116763457338x,y,z,t: -5.6434643216721705 -6.7117909582448 21.875348207825766 12.728116763457338x,y,z,t: -5.776218568580239 -7.038353710472807 21.677470196579595 12.739506857199522...type(track1): &lt;class &#39;numpy.ndarray&#39;&gt; track1.shape: (3000, 3) 首先，定义了函数lorenz()，它的任务是计算无质量点坐标各方向相对于时间t的微分值。参数s,r,b分别对应方程组中的σ, ρ, β，t为时间（在函数里没有用到），p是一个ndarray，p.tolist()将其转换成一个列表，其中包括当前无质量点的坐标。 t = np.arange(0,30,0.01)以0.01为间隔，生成从0至30(不含)的等差数列，它代表了一组离散的时间点。 integrate.odeint()则进行微分方程求解，参数lorenz指明了微分计算函数，(0.0,1.00,0.0)则为无质量点的位置初始值；t为离散时间点；args指定了要传递给lorenz函数的额外参数，对应s,r,b，为固定值。odeint()会迭代调用lorenz()函数，用于生成无质量点的运动轨迹。上述控制台输出的结果可以帮助读者理解x,y,z坐标及t的变化过程。 t是一个长度为3000的一维数组，odeint()返回结果为一个形状为(3000,3)的二维数组，用3000个离散的三维空间点来表示无质量点的运动轨迹。据信，odeint()会将lorenz()函数返回的微分值再乘以dt以获得dx,dy和dz，这个过程其实跟我们在“数学之美”那一章的模拟计算过程类似，但更高效，更精确。 track1[:,0]对track1二维数组进行下标切片，得到3000个元素的一维数组，表示3000个空间点的x坐标，y和z坐标以类似方式获得。 我们可以看到，track1-红和track2-绿仅在系统初始值上有细微差异，但随着时间的推进，其运动轨迹差异越来越大，表现出“混沌”性：南美洲一只蝴蝶扇动翅膀，会引起对面半球一场飓风。 21.6 信号处理-signalSciPy中的signal模块支持信号处理，提供了：卷积运算、B样条、滤波等各种功能。 微实践 - ECG信号的谱分析及滤波本节的阅读需要傅里叶级数及傅里叶变换的相关数学知识。 示范代码目录下有一个ecgsignal.dat文件，这里存储了作者采集的一段人体心电信号-ECG。这个文件以4字节浮点数存储样本，单位为μV，采样总数 = 文件大小 / 4，采样频率 = 2000样本/秒。需要说明的是，这个心电信号不是标准的医用心电信号，作者在一台其它用途的医用电生理设备上，用左手拿着正电极，右手拿着负电极，简单记录了上述信号。而且，作者故意没有涂用于皮肤电极的导电膏，以便引入“工频干扰”。 分析信号的频谱 - spectrum 心电信号可以视为定义在时间t上的函数，把这个函数进行傅里叶级数展开，可以将其表达成不同频率/周期的正弦函数的和。而这些正弦项的系数，则表明了该种频率的正弦项在信号构成中的重要程度。所谓的频谱分析，就是把时间t上的函数，转换成频率f上的函数，即把信号从时域转换到频域。这种转换，可以通过傅里叶变换实现。在离散的计算机世界里，对应的算法工具称为快速傅里叶变换 - Fast Fourier Transform，简称FFT。 1234567891011121314151617181920212223#Spectrum.pyimport numpy as npfrom matplotlib import pyplot as pltiSampleRate = 2000 #采样频率,每秒2000个样本x = np.fromfile(\"ecgsignal.dat\",dtype=np.float32)iSampleCount = x.shape[0] #采样数t = np.linspace(0,iSampleCount/iSampleRate,iSampleCount)xFFT = np.abs(np.fft.rfft(x)/iSampleCount) #快速傅里叶变换xFreqs = np.linspace(0, iSampleRate/2, int(iSampleCount/2)+1)plt.figure(figsize=(10,6))ax0 = plt.subplot(211) #画时域信号ax0.set_xlabel(\"Time(s)\")ax0.set_ylabel(\"Amp(μV)\")ax0.plot(t,x)ax1 = plt.subplot(212) #画频域信号-频谱ax1.set_xlabel(\"Freq(Hz)\")ax1.set_ylabel(\"Power\")ax1.plot(xFreqs, xFFT)plt.show() 执行结果 先点下方工具栏中的放大镜，然后按住鼠标左键框选放大，可以帮助我们帮察信号及频谱的细节： np.fromfile(“ecgsignal.dat”,dtype=np.float32)从文件读取信号数据，numpy会以二进制格式打开文件，读取数据，并以4个字节为单位，逐一转换成np.float32类型，然后返回一个一维数组。该数组包含全部采样。 np.float32类型表示一个采样浮点数由32个bit，即4个字节构成。 np.linspace(0,iSampleCount/iSampleRate,iSampleCount)则生成了与信号x相同维度的一维数组t，其中的数据对应每个样本的采样时间。其中，iSampleCount为采样总数，iSampleRate为采样频率。如果采样总数=6000，则信号的总时间长度为6000/2000(采样频率)=3秒。后续代码中的ax0.plot(t,x)则以时间t为横轴，信号振幅x为纵轴，在ax0子图上画出时域信号。 np.fft模块支持快速傅里叶变换，其中的rfft()函数对实数信号进行FFT运算。根据计算公式，还需要将返回结果除以iSampleCount以便正确显示波形能量。 rfft()函数的返回值是iSampleCount/2+1个复数，分别表示从0(Hz)到iSampleRate/2(Hz)的频率能量。np.abs()对rfft()返回数组中的复数进行求模(abs)。受限于香农采样定理，采样频率为2000Hz的信号，有效的信号频率最高为1000Hz。 xFreqs = np.linspace(0, iSampleRate/2, int(iSampleCount/2)+1)则负责生成与xFFT中的能量相对应的频率。此时,(xFreqs,xFFT)可视为定义在频率域xFreqs上的“信号”，即原时域信号(t,x)的频谱。后续代码中的ax1.plot(xFreqs, xFFT)则以频率为横轴，能量为纵轴，在ax1子图上画出频谱。 顺便再次指出，plt.subplot(211)将当前图按2行1列划分，在1号位置（即上方位置）创建一张子图ax0，同理，plt.subplot(212)则在2号位置（即下方位置）创建一张子图ax1。 在下方频谱图中，我们看到在50Hz处存在一个巨大的峰，这些能量对应着那些叠加在原始信号上的有规律的周期小波，这就是所谓的工频干扰。读者可以数一数下方上图中从3.0秒至3.2秒的周期小波的周期(峰到峰）个数，应该是10个，0.2秒10个周期对应1秒种50个周期。我国的市电是220V/50Hz交流电，交变的电流流过市电导线，向空间辐射能量，这些辐射能量借助于人体，电极线等与市电导线的耦合电容，进入了信号放大器，形成“干扰”。此外，我们在100Hz处也可以看到频谱能量的峰，100Hz正好是50Hz 的倍频，也是所谓工频干扰的一部分。可以想象，如果同样的干扰发生在美国，其频率应为60Hz，因为当地的市电是110V/60Hz交流电。这里，50Hz的工频干扰我们将使用带阻滤波器，也叫陷波器滤除。 在频谱图中，我们还看到在0Hz附近也有较多能量，这些低频成分对应原始信号里缓慢变化的基线。这些低频成分也不具备诊断意义，需要滤除。我们选择使用一个带通滤波器，滤除3Hz以下的低频信号，同时滤除70Hz以上的高频信号。 滤波器设计 滤波是个宏大的课题，这里我们只能描述一种简便的应用方法，不描述背后的数学原理。 我们需要两个滤波器，其中一个是3-70Hz的带通滤波器，它保留信号中3-70Hz的频率成分，去除低于3Hz的低频部分以及高于70Hz的高频部分。另外一个是48-52Hz的带阻滤波器，别名50Hz陷波器，它去除信号中48-52Hz的成分。 下图展现了我们设计的带通滤波器(左)及带阻滤波器(右)的频率响应。横轴为频率，纵轴为滤波器对该频率信号的增益(gain)，当增益为1.0时，说明该频率信号无障碍通过滤波器，当增益小于1.0时，说明通过滤波器时，该频率信号被衰减。可以看到，当滤波器的阶(order)越高，则滤波器性能越好(频响曲线陡峭)，但计算量也会增加。 相关滤波器设计代码如下: 12345678910111213141516171819202122232425262728293031323334353637#FilterResponse.pydef butterBandPassFilter(lowcut, highcut, samplerate, order): \"生成巴特沃斯带通滤波器\" semiSampleRate = samplerate*0.5 low = lowcut / semiSampleRate high = highcut / semiSampleRate b,a = signal.butter(order,[low,high],btype='bandpass') print(\"bandpass:\",\"b.shape:\",b.shape,\"a.shape:\",a.shape,\"order=\",order) print(\"b=\",b) print(\"a=\",a) return b,adef butterBandStopFilter(lowcut, highcut, samplerate, order): \"生成巴特沃斯带阻滤波器\" semiSampleRate = samplerate*0.5 low = lowcut / semiSampleRate high = highcut / semiSampleRate b,a = signal.butter(order,[low,high],btype='bandstop') print(\"bandstop:\",\"b.shape:\",b.shape,\"a.shape:\",a.shape,\"order=\",order) print(\"b=\",b) print(\"a=\",a) return b,aiSampleRate = 2000 #采样频率plt.figure(figsize=(12,5))ax0 = plt.subplot(121)for k in [2, 3, 4]: b, a = butterBandPassFilter(3,70,samplerate=iSampleRate,order=k) w, h = signal.freqz(b, a, worN=2000) ax0.plot((iSampleRate*0.5/np.pi)*w,np.abs(h),label=\"order = %d\" % k)ax1 = plt.subplot(122)for k in [2, 3, 4]: b, a = butterBandStopFilter(48, 52, samplerate=iSampleRate, order=k) w, h = signal.freqz(b, a, worN=2000) ax1.plot((iSampleRate*0.5/np.pi)*w,np.abs(h),label=\"order = %d\" % k) 控制台输出： 1234567bandpass: b.shape: (5,) a.shape: (5,) order&#x3D; 2b&#x3D; [ 0.00961483 0. -0.01922967 0. 0.00961483]a&#x3D; [ 1. -3.70024346 5.14358108 -3.18588885 0.74255496]bandpass: b.shape: (7,) a.shape: (7,) order&#x3D; 3...bandpass: b.shape: (9,) a.shape: (9,) order&#x3D; 4... 下述讨论中，f0等于采样频率的一半，即代码中的iSampleRate*0.5，或者samplerate*0.5。 从控制台输出可以看到，signal.butter()函数生成滤波器的结果为两个一维数组b和a。数组里存储一些实数，滤波器的阶(order)越大，b,a包含的实数个数越多。b,a是IIR滤波器的系数。btype参数指明了滤波器的类型，bandpass意为带通，bandstop意为带阻。[low,high]则指明了滤波器的截止频率。上述代码说明，这里的low和high应等于截止频率/f0。当采样频率为2000时，f0=2000*0.5=1000，则3Hz的截止频率对应low = 3/1000 = 0.003，70Hz的截止频率对应high = 70 / 1000 = 0.07。 freqz()函数用于计算滤波器的频率响应，返回w,h两个数组。其中，w是圆频率数组，通过w*f0/π可以计算出与其对应的频率，h是w对应频率点的响应，它是一组复数，其幅值表示滤波器的增益特性，相角表示滤波器的相位特性。参数worN表明了要计算的频率的项数，该值越大，计算越精细。 上述代码中，我们生成了阶为2,3,4的3-70Hz带通滤波器共3个，阶为2,3,4的48-52Hz带阻滤波器共3个，然后分别生成并显示了其频率响应曲线，以供读者观察。上述代码中，np.abs()函数用于求复数数组的模。 上图中，我们还画了一条sqrt(0.5)的虚线，这里对应着所谓的-3dB增益。此处，对应频率的信号的功率缩减为最高功率的一半。 滤波 我们应用上述滤波器对信号进行了滤波，结果如下图（局部放大）： 可以看到，在3-70Hz带通滤波器的作用下，0Hz附近的极低频成分消失了，70Hz以后的高频成分也得到有效抑制。同时，我们注意到100Hz的干扰成分仍有残留。 在48-52Hz带阻滤波器的作用下，50Hz附近工频干扰几乎完全消失。上图中，我们看到了基线不飘移，50Hz工频周期波完全去除后的“干净”的ECG信号。这个信号来自于心脏，常在医用心电监护仪上看到。每个“尖波”对应着一次心跳，读者可以计算一下作者记录这段信号时的心率。 相关滤波的代码如下： 12345678910111213#Filter.pyiSampleRate = 2000 #采样频率,每秒2000个样本x = np.fromfile(\"ecgsignal.dat\",dtype=np.float32)#进行带通滤波b,a = butterBandPassFilter(3,70,iSampleRate,order=4)x = signal.lfilter(b,a,x)#进行带阻滤波b,a = butterBandStopFilter(48,52,iSampleRate,order=2)x = signal.lfilter(b,a,x)... #谱分析及画图部分代码略 滤波的代码十分简单。signal.lfilter()将滤波器返回的b,a数组应用于信号x上，滤波后返回一个新数组。读者一定有点好奇，lfilter()内部到底做了些什么。对于FIR-有限脉冲响应滤波器，a组系数不适用，对于输出信号数组y的任意点y[i]，其值为：$$y_i=b_0x_i+b_1x_{i-1}+…+b_px_{i-p}$$​ 这就是个简单的乘积和。对于IIR-无限脉冲响应滤波器，对于输出信号数组y的任意点y[i]，其值为：$$y_i=\\frac{b_0x_i+b_1x_{i-1}+…+b_px_{i-p}-a_1y_{i-1}-a_2y_{i-2}-…-a_qy_{i-q}}{a_0}$$​ 上述两个公式中，p+1为b数组的元素个数；q+1为a数组的元素个数。 巴特沃斯滤波器只是IIR滤波器的一种。 使用firwin()、remez()等函数可以设计FIR滤波器。iirdesign()函数则可以帮助设计IIR滤波器。要想彻底弄明白滤波器背后的数学原理，不是一件容易的事情。 21.7 插值-interpolate插值和拟合（如最小二乘拟合）都试图通过已知的实验离散数据求未知数据。与拟合不同，插值要求曲线通过所有已知数据点。interpolate模块用于此目的。 21.7.1 一维interp1d我们从最简单的一维插值说起。为了让读者明白什么是插值，我们生成了[0,10]上共10个元素的等差数列及其正弦值，模拟所谓的10个实验数据点。这10个实验数据点的散点图如下图中的points子图。 123456789101112#Interpolate.pyfrom scipy import interpolateimport numpy as npfrom matplotlib import pyplot as pltx10 = np.linspace(0,10,10)y10 = np.sin(x10)plt.figure(figsize=(12,6))ax = plt.subplot(231) #2行3列，在位置1创建子图ax.scatter(x10,y10,c='black') #画散点图ax.set_title(\"points\") 执行结果 假设在某项科学试验中，我们测试并记录了上述10个试验点。现在要从这10个试验推测y和x之间的函数关系，并以此为依据，计算其它x所对应的 y值。这个过程就是所谓的“插值”。一眼望去，这些点是散乱没有规律的，难以推断背后的函数关系。在一元函数关系中，该插值可以通过interp1d类型来完成。注意interp1d是一个类型，不是函数。interp1d()是这个类的构造函数的调用形式。 123456789101112131415#Interpolate.pyx100 = np.linspace(0,10,100) #[0,10]的包含100个元素的等差数列colors = ['red','green','blue','purple']for i,kind in enumerate(['nearest','zero','slinear','quadratic']): f = interpolate.interp1d(x10,y10,kind=kind) #从10个实验数据点插值 print(\"type of f:\",type(f)) y100 = f(x100) #应用插值结果计算100个数的“函数”值 ax = plt.subplot(232+i) #2行3列，2+i位置建子图 ax.scatter(x10,y10) ax.plot(x100,y100,c=colors[i]) #画100点的折线图以反应“函数”关系 ax.set_title(kind)plt.subplots_adjust(left=0.05,right=0.95,bottom=0.05,top=0.95, wspace=0.2,hspace=0.2) #调整子图间距等plt.show() 控制台输出： 123type of f: &lt;class &#39;scipy.interpolate.interpolate.interp1d&#39;&gt;...type of f: &lt;class &#39;scipy.interpolate.interpolate.interp1d&#39;&gt; 上述代码的绘图结果见上图中的nearest, zero, slinear, quadratic子图。 interpolate.interp1d类型的构造函数接受(x,y,kind)等参数。其中，x,y提供了实验数据点，kind则指明了插值类型。该构造函数返回一个对象f，这个对象f内部包括了插值后的“函数关系”。f对象是callable-可调用的，也就是说它也是一个函数。f(x100)将[0,10]的包含100个数的等差数列交给f“函数”进行计算，得y100，y100中的数值就是插值推测的结果。如果读者对f到底是对象还是函数感到疑惑，请回顾“面向对象”一章的观点：万物皆对象。 我们逐一使用四种kind进行插值计算，并把相关结果绘制出来供读者观察。可以看到，quadratic插值结果几乎跟原始sin()函数一模一样。plt.subplot(232+i)意味着将图(figure)分成2行3列，在第2+i个位置上创建一个子图 - axes。 kind参数有如下可选值： 插值类型 说明 zero,nearest 阶梯插值，相当于0阶B样条曲线； slinear, linear 线性插值，相当于1阶B样条曲线，简单地说，就是实验数据点的折线连接； quadratic 二阶插值，即2阶B样条曲线； cubic 三阶插值，3阶B样条曲线；事实上，kind参数可以为int，直接指定阶数。 需要注意的是，interp1d对象取得后，也只能计算由实验数据所框定的数值范围的函数。上例中，f([1,9])是合法的，而f([12,19])则会产生异常，因为12,19都超出了由实验数据点所框定的值域。 21.7.2 拟合与外推UnivariateSplineinterp1d的插值曲线要求经过所有实验数据点，并且，不能进行外推：即计算实验数据点范围之外的函数值。UnivariateSpline类的插值比interp1d更高级，允许外推和拟合（曲线不经过实验数据点）。 为解释UnivariateSpline类型，我们先在没有噪声的标准正弦数据点上进行插值和外推。 123456789101112131415#UnivariateSpline.pyimport numpy as npfrom scipy import interpolatefrom matplotlib import pyplot as pltplt.figure(figsize=(12,4))x = np.linspace(0,10,20) #[0,10]含20个值的等差数列y = np.sin(x) #y = x的正弦plt.scatter(x,y,s=20,label=\"points\") #画散点图xs = np.linspace(0,12,100) #[0,12]含100个值的等差数列，12&gt;10,外推ys = interpolate.UnivariateSpline(x,y,s=0)(xs) #由(x,y)插值，函数应用于xsplt.plot(xs,ys,lw=2,label=\"spline,s=0\") #画(xs,ys)，ys由插值函数计算而来plt.plot(xs,np.sin(xs),lw=2,label=\"sin(x)\") #画标准正弦函数(xs,np.sin(xs))plt.legend() #显示图示plt.show() 执行结果 这行代码需要进行解释：ys = interpolate.UnivariateSpline(x,y,s=0)(xs)。类似于interp1d，UnivariateSpline也是一个类型，其构造函数接受(x,y)作为实验数据点，返回一个插值对象。这个对象类型为UnivariateSpline，同时也是一个可调用对象-函数。为帮助读者理解，这行代码可以拆成两行： 12f = interpolate.UnivariateSpline(x,y,s=0)ys = f(xs) 我们使用这个插值对象/函数来计算xs，返回包含部分外推的函数结果ys。请注意，试验数据点中x的值域为[0,10]，而xs的值域为[0,12]，超出了原有范围。 为了反应插值函数的准确性，我们还画了一条标准的正弦曲线sin(x)。可以看到，在值域[0,10]范围内，插值曲线与标准正弦几乎完全重合，但在外推的部分，即[10,12]这个区间，效果并不理想。 上述插值类构造函数的完整调用形式为： ​ UnivariateSpline(x, y, w=None, bbox=[None, None], k=3, s=None, ext=0, check_finite=False) 其中，w可以为每个数据指定权重；k默认为3，指定样条曲线的阶；s则是平滑系数，它使得最终生成的样条曲线满足下述条件：$$sum((w[i] * (y[i]-spl(x[i])))**2, axis=0) &lt;= s$$可以看出，当s&gt;0时，样条曲线-spl不一定通过实验数据点，可视为曲线拟合。当s=0，样条曲线必须通过实验数据点。在本例中，s=0，我们看到所有的实验数据点都在样条曲线”spline,s=0”上。 在实践当中，误差永远存在，可以认为实验数据点永远都包括噪声。接下来，我们给实验数据点加入一些噪声，再试图进行插值拟合。 123456789101112131415#UnivariateSpline2.pyimport numpy as npfrom scipy import interpolatefrom matplotlib import pyplot as pltplt.figure(figsize=(12,4))x = np.linspace(0,20,200) #[0,20]等差数列，200个值y = np.sin(x) + np.random.standard_normal(len(x))*0.16 #带噪声正弦plt.scatter(x,y,s=3,label=\"noisy points\") #散点图：噪声实验数据点xs = np.linspace(0,23,2000) #[0,23]等差数列，2000个值ys = interpolate.UnivariateSpline(x,y,s=8)(xs) #由(x,y)插值，函数应用于xsplt.plot(xs,ys,lw=2,label=\"spline,s=8\") #画(xs,ys)，ys由插值函数计算而来plt.plot(xs,np.sin(xs),lw=2,label=\"sin(x)\") #画标准正弦函数(xs,np.sin(xs))plt.legend()plt.show() 执行结果 np.random.standard_normal()函数生成len(x)个标准正态分布的随机数，这些随机数的取值范围为0-1，乘以0.16以控制其范围。 本次插值过程中，我们指定平滑参数s=8，这将允许样条曲线不经过实验数据点。我们看到，由于噪声的存在，即便在试验数据点的值域[0,20]范围内，插值函数未能与标准正弦曲线完全重合。在外推的值域部分，即[20,23]，则差得更多。 21.7.3 二维插值二元函数形如z = f(x,y)，对其进行插值则需要使用interp2d类型。 123456789101112131415161718192021222324252627282930#interp2d.pyimport numpy as npfrom matplotlib import pyplot as pltfrom matplotlib import cmfrom scipy import interpolateplt.figure(figsize=(12,4))y,x = np.ogrid[-2:2:20j,-2:2:20j]z = (x+y)*np.exp(-x**2-y**2) #20x20的实验数据点extent = [np.min(x),np.max(x),np.min(y),np.max(y)]ax = plt.subplot(131)ax.imshow(z,extent=extent,cmap=cm.rainbow)ax.set_title(\"20x20\")func = interpolate.interp2d(x,y,z,kind='cubic') #二维插值x1 = np.linspace(-2,2,300)y1 = np.linspace(-2,2,300)z1 = func(x1,y1) #根据插值函数计算函数值，要求参数为一维数组ax = plt.subplot(132)ax.imshow(z1,extent=extent,cmap=cm.rainbow)ax.set_title(\"interp2d_300x300\")y2,x2 = np.ogrid[-2:2:300j,-2:2:300j]z2 = (x2+y2)*np.exp(-x2**2-y2**2) #计算标准函数并显示以便对照ax = plt.subplot(133)ax.imshow(z2,extent=extent,cmap=cm.rainbow)ax.set_title(\"original_300x300\")plt.show() 执行结果 上述代码的第一部分生成了函数：$$z(x,y)=(x+y)e^{-x^2-y^2}$$的20x20个实验数据点，作为插值用。这20x20个数据点作为图像描绘了出来，可以看到，图像很粗糙（图左）。 上述代码的第二部分则对实验数据点使用类型interp2d(x,y,z…)进行了插值，得到可执行对象func。然后使用可执行对象func对300x300个(x,y)点计算z值，并描绘成图像（图中）。需要注意的是，二维插值对象要求参数必须是一维数组，其内部计算时，会对输入参数进行类似“广播”的处理。 上述代码的第三部分则计算并描绘了标准的函数图像（图右）。可以看到，插值生成的函数图像与标准的函数图像高度相似。 此外，通过splev, splprep等类型能进行参数曲线的插值。这些参数曲线可以是二维甚至高维空间的曲线。通过pchip类型则可以进行所谓单调插值。 21.8 稀疏矩阵、图像处理、统计及其它本小节简介一下其它无法详细介绍的重要模块。 数学中的矩阵通常用计算机里的多维数组来表示。但如果矩阵很稀疏：即矩形的大多数元素都是0，用ndarray进行存储就非常地浪费。scipy.sparse模块提供了多种表示稀疏矩阵的格式；scipy.sparse.linalg则提供了对稀疏矩阵进行线性代数运算的专用函数；scipy.sparse.csgraph则可以对稀疏矩阵所代表的“图”进行搜索，比如应用著名的Dijkstra算法进行单源最短路径求解。 scipy.ndimage提供了基础的图像处理功能， 包括： 模块 用途 模块 用途 filters 图像滤波 fourier 傅里叶变换 interpolation 图像插值、旋转、仿射变换 measurements 图像测量 morphology 形状学处理 事实上，有比scipy更加强大的图像处理库，比如opencv-python， pillow， scikit-image等。 stats模块提供数理统计计算支持。包括连续、离散概率分布、卡方分布及其检验、t分布及其检验、二项和泊松分布等功能。 spatial模块则提供众多的空间算法，包括凸包、K-d树、沃德罗伊图、德劳内三角化等。 21.9 小结我们真的浅尝则止了，scipy库十分强大。提醒读者，任何时候，当你试图进行一些跟”科学”有关的计算，别忘记先查询一下scipy是否提供相应支持，以避免重新发明轮子。与SciPy不同，Python社区里还有一个叫做SymPy的符号运算库，用它可以进行数学表达式的符号推导和演算。","categories":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/categories/Python/"},{"name":"科学计算","slug":"Python/科学计算","permalink":"http://codelearn.club/categories/Python/%E7%A7%91%E5%AD%A6%E8%AE%A1%E7%AE%97/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/tags/Python/"}]},{"title":"加速扩展库下载 - 修改pip的安装源","slug":"pipsource","date":"2019-10-14T23:35:04.000Z","updated":"2020-03-03T05:12:04.369Z","comments":true,"path":"2019/10/pipsource/","link":"","permalink":"http://codelearn.club/2019/10/pipsource/","excerpt":"因为伟大的墙的原因，pip通过位于国外的源服务器下载扩展安装包的速度特别慢，对初学者不太友好。 上述问题可以通过修改pip的安装源至国内的镜像服务器来解决。","text":"因为伟大的墙的原因，pip通过位于国外的源服务器下载扩展安装包的速度特别慢，对初学者不太友好。 上述问题可以通过修改pip的安装源至国内的镜像服务器来解决。 [本篇文章的内容由重庆大学2018级罗少航同学书写] 1. 先定位并找到你的Python解释器安装路径 2. 新建名为pip的文件夹并打开，此时效果应类似下图 3. 确保如下图所示的复选框被选中。 4. 右键新建，选择文本文档，打开键入图中的内容并保存 该文本的内容如下[方便读者复制粘贴]： 1234[global]timeout = 6000index-url = http://pypi.douban.com/simpletrusted-host = pypi.douban.com 5. 重命名该文件为pip.ini，此时会弹出如图提示框，选择是 6. 最终效果如图 然后， 再使用pip安装扩展或者使用Visual Studio Code下载插件，速度会快很多。 除了douban的源之外，清华的源也不错，其地址为： 1https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple 此外，在使用pip安装库时，也可以通过-i参数临时指定安装源： 1pip install django -i https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple","categories":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/tags/Python/"}]},{"title":"Windows下的截图方法","slug":"snap","date":"2019-10-08T14:14:04.000Z","updated":"2020-03-03T05:02:25.525Z","comments":true,"path":"2019/10/snap/","link":"","permalink":"http://codelearn.club/2019/10/snap/","excerpt":"本文讨论Windows操作系统环境下截图的方法","text":"本文讨论Windows操作系统环境下截图的方法 版权声明 本文可以在互联网上自由转载，但必须：注明出处(作者：海洋饼干叔叔)并包含指向本页面的链接。 本文不可以以纸质出版为目的进行改编、摘抄。 学习过程中撰写实验报告，向老师，学长请教问题，通常需要截图。 方法1：使用QQ的Ctrl+Alt+A快捷键, 框定对应区域后，双击被框定的区域，然后在QQ中按Ctrl-V, 即可。 方法2：仅适用于Windows 10 Win + Shift + S , 然后在QQ中Ctrl-V贴图。 凡是本班同学，请教问题时，请务必在电脑上登录QQ, 截图。不要拍照。","categories":[{"name":"导论","slug":"导论","permalink":"http://codelearn.club/categories/%E5%AF%BC%E8%AE%BA/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/tags/Python/"}]},{"title":"Python下如何创建一个文本格式的进度条","slug":"progressbar","date":"2019-07-30T16:20:04.000Z","updated":"2020-03-03T04:59:58.444Z","comments":true,"path":"2019/07/progressbar/","link":"","permalink":"http://codelearn.club/2019/07/progressbar/","excerpt":"本文讨论Python下如何创建一个文本格式的进度条，就像pip下载时的进度条一样。","text":"本文讨论Python下如何创建一个文本格式的进度条，就像pip下载时的进度条一样。 版权声明 本文可以在互联网上自由转载，但必须：注明出处(作者：海洋饼干叔叔)并包含指向本页面的链接。 本文不可以以纸质出版为目的进行改编、摘抄。 微实践 - 文本进度条 当计算机执行一个耗时较长的任务时，通常需要显示一个进度条给操作者，便于操作者评估执行进展并缓解其焦虑。本小节讨论如何在文本控制台上通过print()函数显示进度条。 当使用print()函数向系统标准输出输出文本时，总是逐行递增的。如果不特定说明，每个print()函数总是会在输出的末尾补充输出一个换行符”\\n”。通过指定print的end参数为换行符之外的其它值，可以避免print()函数的自动换行。 12345#printend.pyprint(\"我还记得几位唐朝诗人：\",\"李白\",end=\",\")print(\"杜甫\",end=\",\")print(\"白居易\",end=\",\")print(\"孟浩然\",end=\",\") 执行结果： 1我还记得几位唐朝诗人： 李白,杜甫,白居易,孟浩然, 要保持文本进度条在多次刷新时不换行， 我们还得借用另外一个转义符：”\\r”。这个转义符将使得控制台输出指针回到当前行的行首。 1print(\"abcdefghijklmn\\r123\") 执行结果： 1123defghijklmn 上述执行结果证明，在输出了”abcdefghijklmn”之后，”\\r”的输出导致控制台输出指针回到了行首，”123”的输出覆盖了abc。 借助于转义符”\\r”，我们设计了下述文本进度条显示函数。 1234567891011121314151617#ProgressBar.pyprogressBefore = 0def printProgressBar(percent, prefix = ''): global progressBefore if percent - progressBefore &lt; 0.001: #只有当进度达到千分之一才刷新，避免频繁刷新进度条 return progressBefore = percent percentStr = (\"&#123;0:.1f&#125;\").format(percent*100) #格式化字符串，参见字符串进阶一章相关内容 filledLength = int(30 * percent) bar = '█' * filledLength + '-' * (30 - filledLength) print('\\r%s |%s| %s%% ' % (prefix, bar, percentStr),end='')if __name__ == \"__main__\": #参见模块与扩展库 - 模块测试相关章节 import time for i in range(1000): printProgressBar((i+1)/1000,prefix=\"Progress:\") time.sleep(0.01) #当前进程暂停10ms 代码说明 - percent参数取值范围0-1，表示百分比进度；prefix表示进度条前方的前缀文本。 - 只有当percent - progressBefore大于等于千分之一时才会刷新进度条，这样做可以避免进度条不必要的频繁刷新。- 进度条的黑色部分是由多个字符█串起来形成的，而█与 - 的个数则根据percent计算而得，两者的个数之和为30。- print()一开始就输出了一个”\\r”，让输出光标回到行首，end=’’则指定print的结尾为空，不要输出默认的’\\n’。 由于”\\r”转义符的应用，每次进度条刷新，输出都会从行首开始，而且输出完成后，end=’’参数避免了自动换行。所以，虽然我们多次通过print()函数输出进度，但总是显示在同一行。 读者可能会对代码if __name__ == “__main__“的作用感到疑惑，这行代码用于包裹模块内的测试用代码，具体细节在第14章讨论。","categories":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/tags/Python/"}]},{"title":"Python下的数值列表 - range(x,y,z)函数","slug":"range","date":"2019-07-30T16:14:04.000Z","updated":"2020-03-03T05:02:07.197Z","comments":true,"path":"2019/07/range/","link":"","permalink":"http://codelearn.club/2019/07/range/","excerpt":"本文讨论Python下的数值列表 - range(x,y,z)函数的应用，并分析其计数过程。","text":"本文讨论Python下的数值列表 - range(x,y,z)函数的应用，并分析其计数过程。 版权声明 本文可以在互联网上自由转载，但必须：注明出处(作者：海洋饼干叔叔)并包含指向本页面的链接。 本文不可以以纸质出版为目的进行改编、摘抄。 1. range(x)、range(x,y)1234567print(\"output of range(5):\")for i in range(5): print(i)print(\"output of range(2,5):\")for x in range(2,5): print(x) 执行结果： 12345678910output of range(5):01234output of range(2,5):234 range(x,y) - range(x,y)函数从x开始计数，到y-1停止，不含y，产生一个整数集合； - 可以看到，range(2,5)产生了数值列表[2,3,4]（4即5-1)； - range(x)是range(0,x)的简写形式，range(5)等效于range(0,5)。 range(x,y)在解释器内部并不是一个严格意义上的列表，而是一个称为range的不常用的数据类型。如下述代码所示： 12345#rangelist2.pyx = range(5)print(x[2])print(x)print(type(x)) 执行结果： 1232range(0, 5)&lt;class &#39;range&#39;&gt; 如果真的需要把range转换成列表，可以通过类型转换实现： 1234#range2list.pyx = range(5)x = list(x)print(type(x),x) 执行结果： 1&lt;class &#39;list&#39;&gt; [0, 1, 2, 3, 4] 2. range(x,y,z)更复杂的range形式： 123#fours.pyfours = list(range(0,17,4))print(fours) 执行结果： 1[0, 4, 8, 12, 16] range(x,y,z) - 可以看出，range(0,17,4)从0开始计数，每计数1次，计数值加4，直到计数值&gt;=17为止。但需要注意，仅那些小于17的计数值会被输出； - range(x,y)等价于range(x,y,1); - range(x)等价于range(0,x,1)。 3 理解range计数过程读者或许对range(x,y,z)的输出结果感到疑惑，看看下面这个流程图。 现以range(0,17,4)为例，依上述流程图说明输出集合为什么是[0,4,8,12,16]。首先，计数取值x=0，然后开始循环： 1234567891011- 0 &lt; 17,输出0；- 计数 &#x3D; 0 + 4 &#x3D; 4；- 4 &lt; 17,输出4; - 计数 &#x3D; 4 + 4 &#x3D; 8; - 8 &lt; 17, 输出8;- 计数 &#x3D; 8 + 4 &#x3D; 12; - 12 &lt; 17, 输出12; - 计数 &#x3D; 12 + 4 &#x3D; 16;- 16 &lt; 17, 输出16;- 16 + 4 &#x3D; 20; - 20 &lt; 17不满足，循环结束。 如果你有C/C++经验，下述代码更容易描述range(x,y,z)的计数过程，事实上，Python的解释器就是用C/C++编写的。 123for (int i=x;i&lt;y;i+=z)&#123; output(i);&#125; 上述range(x,y,z)，如果z&lt;0，相应流程图如下： 作者试了试如下代码： 12numbers = list(range(9,2,-2))print(numbers) 执行结果: 1[9, 7, 5, 3] 该你了，请依上述流程图，人肉执行range(9,2,-2)的计数过程，验证上述输出。 如果你有C/C++经验，下面的代码能更容易地解释z小于0时range(9,2,-2)的计数过程： 123for (int i=x;i&gt;y;i+=z)&#123; output(i);&#125;","categories":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/tags/Python/"}]},{"title":"Python下的异常处理及错误日志记录","slug":"exception","date":"2019-07-18T03:36:04.000Z","updated":"2020-03-03T04:57:55.570Z","comments":true,"path":"2019/07/exception/","link":"","permalink":"http://codelearn.club/2019/07/exception/","excerpt":"Python使用被称为异常的特殊对象来表达执行期间发现的错误。当这些异常没有被捕获并处理时，程序将停止，并向控制台打印错误信息。这个错误信息通常是一个traceback，包含了异常的类型，以及诱发这个异常的代码位置及调用栈细节。","text":"Python使用被称为异常的特殊对象来表达执行期间发现的错误。当这些异常没有被捕获并处理时，程序将停止，并向控制台打印错误信息。这个错误信息通常是一个traceback，包含了异常的类型，以及诱发这个异常的代码位置及调用栈细节。 版权声明 本文可以在互联网上自由转载，但必须：注明出处(作者：海洋饼干叔叔)并包含指向本页面的链接。 本文不可以以纸质出版为目的进行改编、摘抄。 1. 曾经的异常在本书的前半部分，我们已经遇到过很多异常： 异常类 说明 ValueError 值与期望的不符 IndentationError 代码缩进错误 IndexError 序列索引不存在 AssertionError 断言失败 NameError 名字不存在 KeyError 映射（比如字典）中的键不存在 AttributeError 属性错误（对象无指定名字的属性) TypeError 类型出错 SyntaxError 代码语法错误 OSError 操作系统未能执行指定任务 ZeroDivisionError 除0错误 这些异常类，都继承自Exception类型。在本书的前半部分，我们对于这些异常采取了放任的态度: 程序直接报错停止。但一个严谨的程序，应该捕获并处理这些异常。 异常发生后 - 捕获并处理异常，尝试将程序从异常中拯救出来，继续正常运行。 - 捕获并处理异常，至少做一些必要的紧急操作，避免严重后果的发生。比如，汽车的车载控制系统发现发动机的“异常高温”（可能意味着起火）异常，应尝试切断油路，迫使汽车减速停车；一个股票交易系统发现无法恢复的异常，应尝试关闭数据库连接，并将没有保存的文件全部存盘。 - 捕获并处理异常，最低限度，作者认为应该将异常信息保存在错误日志中，以便程序员查找错误发生的原因。 2. try except else finally下述代码展示了一个完整的异常处理程序： 1234567891011121314151617181920212223242526#try.pydef divide(a, b): return a/bwhile True: sFirst = input(\"First number:\") sSecond = input(\"Second number:\") if sFirst == \"q\" or sSecond == \"q\": break try: iFirst = int(sFirst) iSecond = int(sSecond) fResult = divide(iFirst,iSecond) except (ZeroDivisionError) as e: print(\"You can not divide by 0:\",e) except (ValueError,TypeError) as e: print(\"Illegal value been inputted:\",e) print(type(e)) except (Exception) as e: print(\"An exception found, I do not know how to process it.\") raise else: print( sFirst, \"/\", sSecond, \"=\", fResult) finally: print(\"'Finally' will be executed what ever happens.\") 上述程序试图让用户输入两个整数，然后相除并将相除的结果打印出来。当除数为0或者操作者输入的字符串不是一个整数时，均会发生异常。上述try … except … else … finally语句将会捕获并恰当地处理这些异常。这个try…finally语句的工作过程可以概述如下： 首先，解释器将会执行try子句内的代码。在上例中，作者故意把try子句写得比较复杂，还加入了一个本不必要的函数，目的是想告诉读者：try子句内的代码以及间接被try子句内代码调用执行的代码，都受try子句的管辖。 如果try子句的执行没有发生异常，在try子句执行完毕后将执行else子句，然后再执行finally语句。下述输入及其执行结果证明了这一点。作者输入了15和3，字符串到整数的转换没有任何问题，else子句打印了除法运算的结果，finally子句接下来“强行”补充：”不管发生什么，我都来刷存在感”。 1234First number:15Second number:315 &#x2F; 3 &#x3D; 5.0&#39;Finally&#39; will be executed what ever happens. 如果try子句的执行发生了异常，则Python解释器会放弃try子句内后续代码的执行，并根据异常的类型创建一个异常对象。然后，解释器将从前往后逐一检查except子句括号里所包括的异常类型，当实际发生的异常属于该except子句括号内的异常类型时，该except子句将会被执行。最后，finally子句也会被执行。 下例中，我们输入了15和0x38。由于0x38不是一个十进制整数，所以iSecond = int(sSecond)这行代码诱发了一个 ValueError异常。解释器放弃了后续try子句的执行，并执行了第二个except子句以及finally子句。 12345First number:15Second number:0x38Illegal value been inputted: invalid literal for int() with base 10: &#39;0x38&#39;&lt;class &#39;ValueError&#39;&gt;&#39;Finally&#39; will be executed what ever happens. 下例中，我们输入了15和0。此时，divide函数内的a/b产生了ZeroDivisionError异常。解释器放弃了try子句后续代码的执行，并执行了第一个except子句以及finally子句。 当异常发生后，如果异常类型既不属于第一条except语句指定的类型，也不属于第二条except语句指定的类型，此时，第三条except语句多半可以捕获并处理异常。因为，绝大多数异常都是Exception类的子类型。注意，作者说的是绝大多数，也有一些异常，比如SystemExit，KeyboardInterrupt，不是Exception的子类。如果希望捕获并处理这些异常，可以直接使用下述型式的except子句: 12except: print(\"I found an exception that is not sub-class of Exception.\") 如果捕获的异常在当前情境下处理不了，也可以接着向外抛：上述代码中第三条except子句中的raise即为该用途。如果直接raise，抛出的是原有异常。当然，也可以欺骗或者加工一下异常：raise ValueError(“值错了!”) 。 连续输入两个”q”， 上述程序将会正常结束。 所谓的向外抛出异常，有必要解释一下。程序中的try…except…else…finally语句很可能处于另外一个try…finally语句的try子句中。所谓，抛出，就是本try…finally语句不处理该异常，扔给外面那个try…finally来处理。参见下述伪代码，我们看到，dummy函数内的try…except间接处于外部的try…except的try子句管辖内。 123456789101112def dummy(): try: doing something here except: raisetry: doing something before dummy() doing something moreexcept: print(\"Exception catched...\") try…finally语句总结 - 当try子句的执行没有发生异常时，else子句将被执行。 - 当try子句的执行发生异常时，解释器会放弃执行try子句后续代码，并根据异常的类型选择执行except子句，顺序为从上到下。 - except子句捕获异常后，可以尝试将程序从异常中恢复，或者做一些最低限度的后处理，以避免“灾难”性结果。如果处理不了，也可以通过raise语句将异常外抛。 - 不管有没有异常发生，finally子句总会在最后阶段被执行。这使得finally子句特别适合于处理一些善后工作，比如关闭因为异常未及关闭的文件，断开网络连接，关闭数据库连接等。 - 语法上，else子句以及finally子句是可选的，而except子句可以有无限多条。 - Python允许程序员定义自己的异常类型，比如车载电脑的控制程序可能需要一个“发动机转速过高”的异常。这很简单：定义一个Exception的子类就好了。 3. 警告如果有些情况的发生还不是那么严重，可以尝试发出警告。 1234567891011#warn.pyfrom warnings import warndef divide(a,b): fResult = a / b if fResult &lt; 0.0000001: warn(\"The result is very close to Zero!\") return fResultprint(divide(0.1, 10000000000))print(\"Something else.\") 执行结果： 1234d:\\pylearn\\C12_UnitTestException\\warn.py:6: UserWarning: The result is very close to Zero! warn(&quot;The result is very close to Zero!&quot;)1.0000000000000001e-11Something else. 从执行结果可以看出，warn()函数发出了警告，该警告会被打印至屏幕，但程序的执行不会因为该警告而停止：print(“Something else.”)在警告之后继续执行了。 如果你使用别人的模块，还可以通过filterwarnings()函数来过滤该模块产生的警告信息。你可以选择忽略-“ignore”，也可以上纲上线地把该模块的警告转化成异常-“error”。具体请查询Python文档。 4. 出错日志异常发生后，如果异常是预料中的类型，程序员直接处理这些异常并挽救程序即可。而程序发生非意料的异常几乎是历史的必然：程序员是人不是神！ 没有bug的应用程序不存在。这些意料之外的异常发生后，把相关情况记入出错日志（通常是一个文本文件），对于解决问题，十分重要。下述代码中的UserExceptHook函数来自于作者编写的一个实际的应用软件。 123456789101112131415161718192021222324252627282930#excepthook.pyimport sys,tracebackfrom datetime import datetimefError = open(\"except_error.log\", 'a')def UserExceptHook(tp, val, tb): traceList = traceback.format_tb(tb) html = repr(tp) + \"\\n\" html += (repr(val) + \"\\n\") for line in traceList: html += (line + \"\\n\") print(html, file=sys.stderr) print(datetime.now(), file=fError) print(html, file=fError) fError.close()def main(): sFirst = input(\"First number:\") sSecond = input(\"Second number:\") try: fResult = int(sFirst) / int(sSecond) except Exception: print(\"发现异常，但我不处理，抛出去.\") raise else: print( sFirst, \"/\", sSecond, \"=\", fResult)sys.excepthook = UserExceptHookmain()fError.close() sys模块下的excepthook是一个勾子-hook函数。当有程序没有捕获的异常，或者捕获后又抛出来的异常时，解释器就会执行这个勾子函数，然后停止运行。 上述代码自行定义了一个勾子函数，并将其赋值给sys.excepthook。这个函数有三个参数：tp-异常类型、val-异常值、tb-异常跟踪栈。异常跟踪栈可以通过traceback模块的format_tb()函数转换成一个字符串列表，这些字符串表明了异常发生时的程序调用关系。 可以看到，UserExceptHook()函数把异常转换成一个多行字符串，其中，repr()函数将一个对象转换成一个可以打印的表示字符串。然后这个多行字符串被打印至sys.stderr标准错误输出，然后再被打印至fError文件。请注意，fError文件在程序开始执行时即被以”a”-附加模式打开，附加模式保证了后续发生的错误信息不会覆盖原有文件内容。此外，在UserExceptHook()函数的最后一行，fError文件被关闭。因为，该勾子函数执行完成后，程序将会终止，这里是唯一关闭文件确保文件内容被正确写入外存的最后机会。 datetime.now()返回当前系统日期和时间。 作者多次运行上述程序，故意输入一些不恰当的值来诱发异常，最后得到下述错误日志-except_error.log： 1234567891011121314151617182018-11-03 18:05:58.305337&lt;class &#39;ZeroDivisionError&#39;&gt;ZeroDivisionError(&#39;division by zero&#39;) File &quot;D:&#x2F;pylearn&#x2F;C12_UnitTestException&#x2F;excepthook.py&quot;, line 28, in &lt;module&gt; main() File &quot;D:&#x2F;pylearn&#x2F;C12_UnitTestException&#x2F;excepthook.py&quot;, line 20, in main fResult &#x3D; int(sFirst) &#x2F; int(sSecond)2018-11-03 18:06:04.097457&lt;class &#39;ValueError&#39;&gt;ValueError(&quot;invalid literal for int() with base 10: &#39;3.2&#39;&quot;) File &quot;D:&#x2F;pylearn&#x2F;C12_UnitTestException&#x2F;excepthook.py&quot;, line 28, in &lt;module&gt; main() File &quot;D:&#x2F;pylearn&#x2F;C12_UnitTestException&#x2F;excepthook.py&quot;, line 20, in main fResult &#x3D; int(sFirst) &#x2F; int(sSecond) 终于，当使用你编写的软件的客户通过电话向你抱怨程序有时会运行出错时，你可以要求客户把错误日志文件发送给你。通过错误日志，你可以了解软件出错的相关细节，而不必通过客户那些“不准确”甚至“夸大其词”的描述去推断错误发生的原因。","categories":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/tags/Python/"}]},{"title":"numpy,matplotlib - Python绘制二元函数曲面","slug":"func3d","date":"2019-07-18T03:36:04.000Z","updated":"2020-03-03T04:58:41.534Z","comments":true,"path":"2019/07/func3d/","link":"","permalink":"http://codelearn.club/2019/07/func3d/","excerpt":"我们将演示如何借助于ufunc的广播运算计算下述二元函数的在一个xy平面上的值并将其绘制成3D曲面。其中，x和y的取值范围均为[-2,+2]。$$z = xe^{-x^{2}-y^{2}}$$","text":"我们将演示如何借助于ufunc的广播运算计算下述二元函数的在一个xy平面上的值并将其绘制成3D曲面。其中，x和y的取值范围均为[-2,+2]。$$z = xe^{-x^{2}-y^{2}}$$ 为了达到目的，我们需要一个二维的结果数组z，其元素的下标对应参数x,y的取值，其元素的值则为上述函数的函数值。这可以通过广播计算来得到。 版权声明 本文可以在互联网上自由转载，但必须：注明出处(作者：海洋饼干叔叔)并包含指向本页面的链接。 本文不可以以纸质出版为目的进行改编、摘抄。 np.ogrid是个特殊对象，通过切片下标来生成用于广播运算的数组。先看下述程序： 123456#ogrid.pyx,y = np.ogrid[0:3:4j,0:4:5j]print(\"x=\\n\",x)print(\"y=\\n\",y)print(\"x.shape=\",x.shape)print(\"y.shape=\",y.shape) 执行结果： 123456789x&#x3D; [[0.] [1.] [2.] [3.]]y&#x3D; [[0. 1. 2. 3. 4.]]x.shape&#x3D; (4, 1)y.shape&#x3D; (1, 5) 0:3:4j这种切片语法类似于np.linspace(0,3,4)，它表示生成从0到3的包含4个元素的等差数列。这里的j并不表示复数的虚部，它只是一种语法格式。由于广播的需要，x的形状被设置为(4,1)。同理，由于广播需要，y的形状被设置成了(1,5)。这样，通过ogrid生成的x和y数组符合广播运算的规则，可以进行广播运算。 下述代码将x = [-2,+2]，y = [-2, +2]的函数值矩阵以平面图形式绘制。 123456789101112#func2d.pyimport numpy as npfrom matplotlib import pyplot as pltfrom matplotlib import cmy,x = np.ogrid[-2:2:200j,-2:2:200j]z = x * np.exp(-x**2-y**2)extent = [np.min(x),np.max(x),np.min(y),np.max(y)]plt.imshow(z,extent=extent,cmap=cm.gray)plt.colorbar()plt.show() 根据ogrid的输出，y,x分别是形状为(200,1)和(1,200)的数组。z = x * np.exp(-x**2-y**2)的执行过程中将发生广播，结果数组z将会是一个形状为(200,200)的二维数组，元素值为对应x,y的函数值。如果将z视为一个图像，那么其横向x取值范围对应[-2,+2]，纵向y取值范围取应[-2,+2]。 extent = [np.min(x),np.max(x),np.min(y),np.max(y)]将x及y的取值范围放入一个列表。plt.imshow()函数将二维数组z作为图像显示，extent参数指明了横纵坐标的范围，cmap则指定了颜色映射对象，该颜色映射对象负责把z中的元素值转换成像素点的颜色。plt.colorbar()则“聪明”通过颜色条显示z中的函数值与颜色之间的对应关系。plt.show()真正地把图表显示出来。执行结果如下： 下述代码将x = [-2,+2]，y = [-2, +2]的函数值矩阵以3D图形式绘制。 12345678910111213#func3d.pyimport numpy as npimport mpl_toolkits.mplot3dfrom matplotlib import pyplot as pltfrom matplotlib import cmx,y = np.mgrid[-2:2:20j,-2:2:20j]z = x * np.exp(- x**2 - y**2)fig = plt.figure(figsize=(8,6))ax = fig.gca(projection='3d')ax.plot_surface(x,y,z,cmap=cm.ocean)plt.show() ax是表示一个子图，由于ax.plot_surface()函数要求x,y,z三个数组都必须是相同形状的二维数组，所以上述代码中没有使用ogrid来生成广播数组，而是使用了mgrid。mgrid的功能与ogrid相近，区别在于其返回的是已经进行了形状扩充的数组。也就是说，上述通过mgrid生成出来的x,y数组的形状已经是(20,20)。读者可以自行打印x,y的值出来观察mgrid对象的用法。读者如果对matplotlib相关代码感到疑惑，请先略过，本书后续部分将解读matplotlib包的使用。上述程序执行结果如下：","categories":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/categories/Python/"},{"name":"数学之美","slug":"Python/数学之美","permalink":"http://codelearn.club/categories/Python/%E6%95%B0%E5%AD%A6%E4%B9%8B%E7%BE%8E/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/tags/Python/"}]},{"title":"Python实现 - 斐波那契数列与函数的增长","slug":"fib","date":"2019-07-18T03:35:04.000Z","updated":"2020-03-03T05:09:48.822Z","comments":true,"path":"2019/07/fib/","link":"","permalink":"http://codelearn.club/2019/07/fib/","excerpt":"数学家列昂纳多·斐波那契研究了野外兔子的繁殖问题：一般而言，兔子出生两个月后，就有繁殖能力。假设一对兔子每个月能生出一对小兔子而且所有兔子都不死。如果现在往一片没有兔子的新大陆上放生一对新生的兔子，那么一年以后那个大陆上有多少只兔子？两年以后呢？","text":"数学家列昂纳多·斐波那契研究了野外兔子的繁殖问题：一般而言，兔子出生两个月后，就有繁殖能力。假设一对兔子每个月能生出一对小兔子而且所有兔子都不死。如果现在往一片没有兔子的新大陆上放生一对新生的兔子，那么一年以后那个大陆上有多少只兔子？两年以后呢？ 版权声明 本文可以在互联网上自由转载，但必须：注明出处(作者：海洋饼干叔叔)并包含指向本页面的链接。 本文不可以以纸质出版为目的进行改编、摘抄。 第1个月，那对兔子还没有繁殖能力，仍为幼兔。故幼免数量为1对，成兔数量为0对，总对数为1； 第2个月，那对兔子性成熟，变成成兔。故幼兔数量为0对，成兔数量为1对，总对数为1； 第3个月，2月时的成兔1对，生了1对小兔子，故幼兔1对，成兔1对，总对数为2； 第4个月，3月时的成兔1对生了1对小兔子，且3月时的幼兔1对变成了成兔，故幼兔数量为1对，成兔变成了2对，总对数为3… 经过月数 1 2 3 4 5 6 7 8 9 10 11 12 幼仔对数 1 0 1 1 2 3 5 8 13 21 34 55 成兔对数 0 1 1 2 3 5 8 13 21 34 55 89 总对数 1 1 2 3 5 8 13 21 34 55 89 144 简单归纳，容易导出下述结论： 幼免对数 = 前月成兔对数 （每对成兔每月生一对小兔子） 成兔对数 = 前月成兔对数 （成兔不死） + 前月幼兔对数（前月的幼兔长大变成成兔） 总对数 = 幼兔对数 + 成兔对数 观察上述表格，可以发现，上述三行数据，在1,1后的每一个数字，都正好等于前两个数字之和。2 = 1 + 1, 3 = 1+2, 5 = 2 + 3… 89 = 34 + 55… 斐波那契对上述规律进行总结和形式化，得到关于n个月后兔子数量的通项公式如下，这是一个分段函数。 读者希望知道10年，也就是120个月之后的兔子数量吗？ 我们来计算一下。 123456789101112[fib1.py]def fibonacci(n): if n &lt;= 2: return 1 a,b = 1,1 #最近两项的值，a为前前项，b为前项 for x in range(3,n+1): v = a + b #新值 = 前两项之和 a,b = b,v #a = b, b = v return vfor n in range(1,121): #121确保数值列表包括120 print(\"month:\",n,\"rabbits:\",fibonacci(n)) 执行结果： 123456789101112131415month: 1 rabbits: 1month: 2 rabbits: 1month: 3 rabbits: 2...month: 8 rabbits: 21...month: 23 rabbits: 28657...month: 38 rabbits: 39088169...month: 54 rabbits: 86267571272...month: 75 rabbits: 2111485077978050...month: 120 rabbits: 5358359254990966640871840 函数fibonacci(n)计算并返回第n个月后的免子对数。计算结果几乎是反直觉的。如果这块新大陆无限大，食物无限丰富，而且没有灰太狼，那么120个月以后，兔子的总对数为：5358359254990966640871840。恭喜成都的朋友们，他们拥有了”永远”也啃不完的麻辣兔头。 上述fibonacci函数值随参数的增长速度极其惊人。在计算复杂性问题上，研究函数的值随参数的增长速度，是有一件有趣的事情。接下来，我们比较一下下述函数以及斐波那契函数随参数的增长速度：$$y = n^2\\y = n^3$$ 123456789101112131415161718192021222324252627#grow.pydef fibonacci(n): if n &lt;= 2: return 1 a,b = 1,1 #最近两项的值，a为前前项，b为前项 for x in range(3,n+1): v = a + b #新值 = 前两项之和 a,b = b,v #a = b, b = v return vx = list(range(1,11)) #1..10的数值列表n2,n3,fn = [],[],[] #依次为n的平方，n的立方，n值斐波那契for v in x: #依次计算机各函数值 n2.append(v*v) n3.append(v*v*v) fn.append(fibonacci(v))print(\"n^2=\",n2)print(\"n^3=\",n3)print(\"fib(n)=\",fn)from matplotlib import pyplot as plt #绘图部分plt.plot(x,n2,color='black',label=\"$y=n^2$\")plt.plot(x,n3,linestyle=\"-.\",color='black',label=\"$y=n^3$\")plt.plot(x,fn,linestyle=\"--\",color='black',label=\"$y=fibonacci(n)$\")plt.legend()plt.show() 执行结果： 123n^2&#x3D; [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]n^3&#x3D; [1, 8, 27, 64, 125, 216, 343, 512, 729, 1000]fib(n)&#x3D; [1, 1, 2, 3, 5, 8, 13, 21, 34, 55] 上述代码首先生成了一个x列表，其值为[1,2,3,4,5,6,7,8,9,10]；然后对x列表每一个值，逐一计算其平方，立方及斐波那契函数的值。最后使用matplotlib将四个函数绘制出来。matplotlib是一个绘图用的扩展模块，需要通过在命令行中执行pip install matplotlib进行安装。 下图展示了参数取值1-10时，3个函数的增长曲线图： 看起来，n3增长较快，n2和fibonacci(n)增长较慢。这不是事实！ 我们把参数取值范围扩大到1-30，重新绘图，结果如下： 可以看到，斐波那契函数的增长曲线昂首挺胸，而n2以及n3在该尺度下，几乎趴在了地上。读者可以自行试验一下x取值1-100的情况。 相对于斐波那契函数，n3的增长速度实在是太慢了。从数学上讲，斐波那契函数与n3都是n趋近于无穷大时的无穷大，但显而易见，斐波那契函数拥有更高的阶。","categories":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/tags/Python/"}]},{"title":"见微智著 - 从一个小例子看Python中的单元测试","slug":"pyut","date":"2019-07-18T03:24:04.000Z","updated":"2020-03-03T05:01:34.265Z","comments":true,"path":"2019/07/pyut/","link":"","permalink":"http://codelearn.club/2019/07/pyut/","excerpt":"单元测试 据统计，由于软件缺陷（bug），美国经济每年在浪费生产力、返工和实际毁坏上损失了数十亿美元。近期最严重的案例是波音737 Max飞机的两次重大坠机事故，共造成了346人死亡。经过初步调查，该公司的专用软件难辞其咎。因此，通过软件工程方法以及测试减少软件的缺陷，十分重要。","text":"单元测试 据统计，由于软件缺陷（bug），美国经济每年在浪费生产力、返工和实际毁坏上损失了数十亿美元。近期最严重的案例是波音737 Max飞机的两次重大坠机事故，共造成了346人死亡。经过初步调查，该公司的专用软件难辞其咎。因此，通过软件工程方法以及测试减少软件的缺陷，十分重要。 版权声明 本文可以在互联网上自由转载，但必须：注明出处(作者：海洋饼干叔叔)并包含指向本页面的链接。 本文不可以以纸质出版为目的进行改编、摘抄。 代码错误或者软件bug和程序员如影随形。作为程序员，我们经常在担心：“我编写的代码是否正确？我编写的代码有没有bug？”。测试驱动开发提供的测试集可以减轻你的担心。 1. 测试驱动开发测试驱动开发，英文全称Test-Driven Development，简称TDD，是一种不同于传统软件开发流程的新型的开发方法。它的基本思路就是通过测试来推动整个开发的进行。在明确要开发某个功能后，不是直接实现功能部分，而是先思考如何对这个功能进行测试，先完成测试代码的编写，然后再编写相关的功能代码满足这些测试用例。 测试驱动开发的基本过程如下：a. 先明确要实现的功能并进行分析；b. 为该功能的测试设计用例并编写测试代码，并在测试用例设计过程中检视该功能的接口；c. 编写代码实现功能；d. 使用测试用例进行测试；e. 如果测试没有通过，对代码进行重构，直至测试通过为止；f. 使用相同流程循环完成软件其它功能的开发。 读者也可能听说过一种叫做“极限编程”的轻量级软件工程思想。在“极限编程”里，一个重要的规则就是：先写测试，这跟TDD异曲同工。测试驱动开发的一个重要实施手段就是单元测试。 2. 单元测试单元测试是保证软件模块质量的重要手段之一，通过单元测试来管理设计好的测试用例，不仅可以避免测试过程中的人工输入引起的错误，还可以重复利用设计好的测试用例。Python标准库unittest提供了很多用于单元测试的类和方法，其中最常用的是TestCase类，其常用方法如表所示。 名称 功能 名称 功能 assertEqual(a, b) a == b assertIsNone(x) x is None assertNotEqual(a, b) a != b assertIsNotNone(x) x is not None assertTrue(x) bool(x) is True assertIn(a, b) a in b assertFalse(x) bool(x) is False assertNotIn(a, b) a not in b assertIs(a, b) a is b assertIsInstance(a, b) isinstance(a, b) assertIsNot(a, b) a is not b assertNotIsInstance(a, b) not isinstance(a, b) assertAlmostEqual(a, b) round(a-b, 7) == 0 assertNotAlmostEqual(a, b) round(a-b, 7) != 0 assertGreater(a, b) a &gt; b assertGreaterEqual(a, b) a &gt;= b assertLess(a, b) a &lt; b assertLessEqual(a, b) a &lt;= b assertRegex(s, r) r.search(s) assertNotRegex(s, r) not r.search(s) 基于测试驱动开发的思想，我们编写一个类来测试判断素数的函数。首先，我们定义了该素数判断函数的接口：函数名为isPrime，接受一个整数参数num, 如果num是素数，该函数返回True, 否则返回False。该函数的接口可以使用伪代码表示如下。 1bool isPrime(int num) 根据TDD， 先写测试，测试类如下： 1234567891011121314#testisprime.pyfrom prime import isPrimeimport unittestclass IsPrimeTestCase(unittest.TestCase): def testIsPrime(self): self.assertEqual(isPrime(2),True,'素数判断错误') self.assertEqual(isPrime(7),True,'素数判断错误') self.assertEqual(isPrime(12),False,'12不是素数，判断错误') self.assertEqual(isPrime(0),False,'0不是素数，判断错误') self.assertEqual(isPrime(1),False,'1不是素数，判断错误') self.assertEqual(isPrime(-7),False,'负数不是素数')if __name__ == '__main__': unittest.main() 我们看到，测试类中把2,7,12以及比较特殊的0,1等作为参数，交给isPrime(num)函数进行判断，并把返回值与预期的值进行比较。如果返回值与预期值不一致，则会导致断言失败，这个失败的断言还会附带一个说明字符串帮助测试者确定测试未通过的原因。 接下来，根据需求以及在测试用例设计过程中检视过的功能接口实现isPrime()函数，版本为0.1： 123456#prime.py v0.1def isPrime(num): for i in range(2,num): if num % i == 0: return False return True 接下来，运行testisprime.py进行测试，得到如下错误结果： 123456789101112&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;FAIL: testIsPrime (__main__.IsPrimeTestCase)----------------------------------------------------------------------Traceback (most recent call last): File &quot;d:\\pylearn\\C12_UnitTestException\\testisprime.py&quot;, line 9, in testIsPrime self.assertEqual(isPrime(0),False,&#39;0不是素数，判断错误&#39;)AssertionError: True !&#x3D; False : 0不是素数，判断错误----------------------------------------------------------------------Ran 1 test in 0.001sFAILED (failures&#x3D;1) 该错误结果表明，测试没有通过，这说明0.1版本的功能代码存在缺陷。仔细查看，发现对值0的素数判断结果真，而期望值应为假。重新检视isPrime(num)函数的设计，发现该函数遗漏了对值0和1的处理，进行修改，得到prime.py的0.2版本: 12345678#prime.py v0.2def isPrime(num): if num in (0,1): return False for i in range(2,num): if num % i == 0: return False return True 再次运行testisprime.py进行测试，结果如下： 123456789101112&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;FAIL: testIsPrime (__main__.IsPrimeTestCase)----------------------------------------------------------------------Traceback (most recent call last): File &quot;d:\\pylearn\\C12_UnitTestException\\testisprime.py&quot;, line 11, in testIsPrime self.assertEqual(isPrime(-7),False,&#39;负数不是素数&#39;)AssertionError: True !&#x3D; False : 负数不是素数----------------------------------------------------------------------Ran 1 test in 0.001sFAILED (failures&#x3D;1) 又没有通过测试，这次是因为num为负数的情况没有得到处理。审视并修改prime.py，得到0.3版本： 12345678#prime.py v0.3def isPrime(num): if num &lt; 0 or num in (0,1): return False for i in range(2,num): if num % i == 0: return False return True 再次运行测试，结果如下： 1234----------------------------------------------------------------------Ran 1 test in 0.000sOK 这次通过了，如果我们的测试用例设计得充分而又合理，可以认为isPrime(num)函数“合格”了。prime.py的版本号可以从0.3直升至1.0了。 上面这个极其微小的例子是希望浅显地向读者介绍单元测试的基本过程，真实的情况要复杂得多。几乎很少有程序员可以一次性地写出没有缺陷或者极少缺陷的代码，程序总是在不断修正，重构中提升其质量。除了写代码外，如何设计合理有效的测试用例，也是一项专门的学问，它属于软件工程的范畴。读者大致可以看到，对于isPrime(num)这样一个简单的函数，测试用例测试了边界值(0,1)，正数，负数等各种情况，试图覆盖isPrime(num)函数全部可能的执行路径。","categories":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/tags/Python/"},{"name":"单元测试","slug":"单元测试","permalink":"http://codelearn.club/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"}]},{"title":"SciPy - ECG信号的谱分析及数字滤波","slug":"ecgfilter","date":"2019-07-18T02:58:04.000Z","updated":"2020-03-03T05:09:18.933Z","comments":true,"path":"2019/07/ecgfilter/","link":"","permalink":"http://codelearn.club/2019/07/ecgfilter/","excerpt":"本节的阅读需要傅里叶级数及傅里叶变换的相关数学知识。","text":"本节的阅读需要傅里叶级数及傅里叶变换的相关数学知识。 示范代码目录下有一个ecgsignal.dat文件，这里存储了作者采集的一段人体心电信号-ECG。这个文件以4字节浮点数存储样本，单位为μV，采样总数 = 文件大小 / 4，采样频率 = 2000样本/秒。需要说明的是，这个心电信号不是标准的医用心电信号，作者在一台其它用途的医用电生理设备上，用左手拿着正电极，右手拿着负电极，简单记录了上述信号。而且，作者故意没有涂用于皮肤电极的导电膏，以便引入“工频干扰”。 版权声明 本文可以在互联网上自由转载，但必须：注明出处(作者：海洋饼干叔叔)并包含指向本页面的链接。 本文不可以以纸质出版为目的进行改编、摘抄。 1. 分析信号的频谱 - spectrum心电信号可以视为定义在时间t上的函数，把这个函数进行傅里叶级数展开，可以将其表达成不同频率/周期的正弦函数的和。而这些正弦项的系数，则表明了该种频率的正弦项在信号构成中的重要程度。所谓的频谱分析，就是把时间t上的函数，转换成频率f上的函数，即把信号从时域转换到频域。这种转换，可以通过傅里叶变换实现。在离散的计算机世界里，对应的算法工具称为快速傅里叶变换 - Fast Fourier Transform，简称FFT。 1234567891011121314151617181920212223#Spectrum.pyimport numpy as npfrom matplotlib import pyplot as pltiSampleRate = 2000 #采样频率,每秒2000个样本x = np.fromfile(\"ecgsignal.dat\",dtype=np.float32)iSampleCount = x.shape[0] #采样数t = np.linspace(0,iSampleCount/iSampleRate,iSampleCount)xFFT = np.abs(np.fft.rfft(x)/iSampleCount) #快速傅里叶变换xFreqs = np.linspace(0, iSampleRate/2, int(iSampleCount/2)+1)plt.figure(figsize=(10,6))ax0 = plt.subplot(211) #画时域信号ax0.set_xlabel(\"Time(s)\")ax0.set_ylabel(\"Amp(μV)\")ax0.plot(t,x)ax1 = plt.subplot(212) #画频域信号-频谱ax1.set_xlabel(\"Freq(Hz)\")ax1.set_ylabel(\"Power\")ax1.plot(xFreqs, xFFT)plt.show() 执行结果： 先点下方工具栏中的放大镜，然后按住鼠标左键框选放大，可以帮助我们帮察信号及频谱的细节： np.fromfile(“ecgsignal.dat”,dtype=np.float32)从文件读取信号数据，numpy会以二进制格式打开文件，读取数据，并以4个字节为单位，逐一转换成np.float32类型，然后返回一个一维数组。该数组包含全部采样。 np.float32类型表示一个采样浮点数由32个bit，即4个字节构成。 np.linspace(0,iSampleCount/iSampleRate,iSampleCount)则生成了与信号x相同维度的一维数组t，其中的数据对应每个样本的采样时间。其中，iSampleCount为采样总数，iSampleRate为采样频率。如果采样总数=6000，则信号的总时间长度为6000/2000(采样频率)=3秒。后续代码中的ax0.plot(t,x)则以时间t为横轴，信号振幅x为纵轴，在ax0子图上画出时域信号。 np.fft模块支持快速傅里叶变换，其中的rfft()函数对实数信号进行FFT运算。根据计算公式，还需要将返回结果除以iSampleCount以便正确显示波形能量。 rfft()函数的返回值是iSampleCount/2+1个复数，分别表示从0(Hz)到iSampleRate/2(Hz)的频率能量。np.abs()对rfft()返回数组中的复数进行求模-abs。受限于香农采样定理，采样频率为2000Hz的信号，有效的信号频率最高为1000Hz。 xFreqs = np.linspace(0, iSampleRate/2, int(iSampleCount/2)+1)则负责生成与xFFT中的能量相对应的频率。此时,(xFreqs,xFFT)可视为定义在频率域xFreqs上的“信号”，即原时域信号(t,x)的频谱。后续代码中的ax1.plot(xFreqs, xFFT)则以频率为横轴，能量为纵轴，在ax1子图上画出频谱。 顺便再次指出，plt.subplot(211)将当前图按2行1列划分，在1号位置（即上方位置）创建一张子图ax0，同理，plt.subplot(212)则在2号位置（即下方位置）创建一张子图ax1。 在下方频谱图中，我们看到在50Hz处存在一个巨大的峰，这些能量对应着那些叠加在原始信号上的有规律的周期小波，这就是所谓的工频干扰。读者可以数一数下方上图中从3.0秒至3.2秒的周期小波的周期(峰到峰）个数，应该是10个，0.2秒10个周期对应1秒种50个周期。我国的市电是220V/50Hz交流电，交变的电流流过市电导线，向空间辐射能量，这些辐射能量借助于人体，电极线等与市电导线的耦合电容，进入了信号放大器，形成“干扰”。此外，我们在100Hz处也可以看到频谱能量的峰，100Hz正好是50Hz 的倍频，也是所谓工频干扰的一部分。可以想象，如果同样的干扰发生在美国，其频率应为60Hz，因为当地的市电是110V/60Hz交流电。这里，50Hz的工频干扰我们将使用带阻滤波器，也叫陷波器滤除。 在频谱图中，我们还看到在0Hz附近也有较多能量，这些低频成分对应原始信号里缓慢变化的基线。这些低频成分也不具备诊断意义，需要滤除。我们选择使用一个带通滤波器，滤除3Hz以下的低频信号，同时滤除70Hz以上的高频信号。 2. 滤波器设计滤波是个宏大的课题，这里我们只能描述一种简便的应用方法，不描述背后的数学原理。 我们需要两个滤波器，其中一个是3-70Hz的带通滤波器，它保留信号中3-70Hz的频率成分，去除低于3Hz的低频部分以及高于70Hz的高频部分。另外一个是48-52Hz的带阻滤波器，别名50Hz陷波器，它去除信号中48-52Hz的成分。 下图展现了我们设计的带通滤波器(左)及带阻滤波器(右)的频率响应。横轴为频率，纵轴为滤波器对该频率信号的增益-gain，当增益为1.0时，说明该频率信号无障碍通过滤波器，当增益小于1.0时，说明通过滤波器时，该频率信号被衰减。可以看到，当滤波器的阶-order越高，则滤波器性能越好(频响曲线陡峭)，但计算量也会增加。 相关滤波器设计代码如下: 12345678910111213141516171819202122232425262728293031323334353637#FilterResponse.pydef butterBandPassFilter(lowcut, highcut, samplerate, order): \"生成巴特沃斯带通滤波器\" semiSampleRate = samplerate*0.5 low = lowcut / semiSampleRate high = highcut / semiSampleRate b,a = signal.butter(order,[low,high],btype='bandpass') print(\"bandpass:\",\"b.shape:\",b.shape,\"a.shape:\",a.shape,\"order=\",order) print(\"b=\",b) print(\"a=\",a) return b,adef butterBandStopFilter(lowcut, highcut, samplerate, order): \"生成巴特沃斯带阻滤波器\" semiSampleRate = samplerate*0.5 low = lowcut / semiSampleRate high = highcut / semiSampleRate b,a = signal.butter(order,[low,high],btype='bandstop') print(\"bandstop:\",\"b.shape:\",b.shape,\"a.shape:\",a.shape,\"order=\",order) print(\"b=\",b) print(\"a=\",a) return b,aiSampleRate = 2000 #采样频率plt.figure(figsize=(12,5))ax0 = plt.subplot(121)for k in [2, 3, 4]: b, a = butterBandPassFilter(3,70,samplerate=iSampleRate,order=k) w, h = signal.freqz(b, a, worN=2000) ax0.plot((iSampleRate*0.5/np.pi)*w,np.abs(h),label=\"order = %d\" % k)ax1 = plt.subplot(122)for k in [2, 3, 4]: b, a = butterBandStopFilter(48, 52, samplerate=iSampleRate, order=k) w, h = signal.freqz(b, a, worN=2000) ax1.plot((iSampleRate*0.5/np.pi)*w,np.abs(h),label=\"order = %d\" % k) 控制台输出： 1234567bandpass: b.shape: (5,) a.shape: (5,) order&#x3D; 2b&#x3D; [ 0.00961483 0. -0.01922967 0. 0.00961483]a&#x3D; [ 1. -3.70024346 5.14358108 -3.18588885 0.74255496]bandpass: b.shape: (7,) a.shape: (7,) order&#x3D; 3...bandpass: b.shape: (9,) a.shape: (9,) order&#x3D; 4... 下述讨论中，f0等于采样频率的一半，即代码中的iSampleRate*0.5，或者samplerate*0.5。 从控制台输出可以看到，signal.butter()函数生成滤波器的结果为两个一维数组b和a。数组里存储一些实数，滤波器的阶-order越大，b,a包含的实数个数越多。b,a是IIR滤波器的系数。btype参数指明了滤波器的类型，bandpass意为带通，bandstop意为带阻。[low,high]则指明了滤波器的截止频率。上述代码说明，这里的low和high应等于截止频率/f0。当采样频率为2000时，f0=2000*0.5=1000，则3Hz的截止频率对应low = 3/1000 = 0.003，70Hz的截止频率对应high = 70 / 1000 = 0.07。 freqz()函数用于计算滤波器的频率响应，返回w,h两个数组。其中，w是圆频率数组，通过w*f0/π可以计算出与其对应的频率，h是w对应频率点的响应，它是一组复数，其幅值表示滤波器的增益特性，相角表示滤波器的相位特性。参数worN表明了要计算的频率的项数，该值越大，计算越精细。 上述代码中，我们生成了阶为2,3,4的3-70Hz带通滤波器共3个，阶为2,3,4的48-52Hz带阻滤波器共3个，然后分别生成并显示了其频率响应曲线，以供读者观察。上述代码中，np.abs()函数用于求复数数组的模。 上图中，我们还画了一条sqrt(0.5)的虚线，这里对应着所谓的-3dB增益。此处，对应频率的信号的功率缩减为最高功率的一半。 3. 滤波我们应用上述滤波器对信号进行了滤波，结果如下图（局部放大）： 可以看到，在3-70Hz带通滤波器的作用下，0Hz附近的极低频成分消失了，70Hz以后的高频成分也得到有效抑制。同时，我们注意到100Hz的干扰成分仍有残留。 在48-52Hz带阻滤波器的作用下，50Hz附近工频干扰几乎完全消失。上图中，我们看到了基线不飘移，50Hz工频周期波完全去除后的“干净”的ECG信号。这个信号来自于心脏，常在医用心电监护仪上看到。每个“尖波”对应着一次心跳，读者可以计算一下作者记录这段信号时的心率。 相关滤波的代码如下： 12345678910111213#Filter.pyiSampleRate = 2000 #采样频率,每秒2000个样本x = np.fromfile(\"ecgsignal.dat\",dtype=np.float32)#进行带通滤波b,a = butterBandPassFilter(3,70,iSampleRate,order=4)x = signal.lfilter(b,a,x)#进行带阻滤波b,a = butterBandStopFilter(48,52,iSampleRate,order=2)x = signal.lfilter(b,a,x)... #谱分析及画图部分代码略 滤波的代码十分简单。signal.lfilter()将滤波器返回的b,a数组应用于信号x上，滤波后返回一个新数组。读者一定有点好奇，lfilter()内部到底做了些什么。对于FIR-有限脉冲响应滤波器，a组系数不适用，对于输出信号数组y的任意点y[i]，其值为：$$y_i=b_0x_i+b_1x_{i-1}+…+b_px_{i-p}$$​ 这就是个简单的乘积和。对于IIR-无限脉冲响应滤波器，对于输出信号数组y的任意点y[i]，其值为：$$y_i=\\frac{b_0x_i+b_1x_{i-1}+…+b_px_{i-p}-a_1y_{i-1}-a_2y_{i-2}-…-a_qy_{i-q}}{a_0}$$​ 上述两个公式中，p+1为b数组的元素个数；q+1为a数组的元素个数。 巴特沃斯滤波器只是IIR滤波器的一种。 使用firwin()、remez()等函数可以设计FIR滤波器。iirdesign()函数则可以帮助设计IIR滤波器。要想彻底弄明白滤波器背后的数学原理，不是一件容易的事情。","categories":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/categories/Python/"},{"name":"科学计算","slug":"Python/科学计算","permalink":"http://codelearn.club/categories/Python/%E7%A7%91%E5%AD%A6%E8%AE%A1%E7%AE%97/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/tags/Python/"},{"name":"SciPy","slug":"SciPy","permalink":"http://codelearn.club/tags/SciPy/"}]},{"title":"数学之美 - Python视角下的Peter de Jong吸引子","slug":"pdj","date":"2019-07-16T23:35:04.000Z","updated":"2020-03-03T05:11:41.561Z","comments":true,"path":"2019/07/pdj/","link":"","permalink":"http://codelearn.club/2019/07/pdj/","excerpt":"据说蝴蝶扇动翅膀这样一件小事，可能最终会引起对面半球的一场飓风。 ​ — 混沌理论","text":"据说蝴蝶扇动翅膀这样一件小事，可能最终会引起对面半球的一场飓风。 ​ — 混沌理论 上面这行话来源于2004年的电影《蝴蝶效应》的开篇字幕。更早期，这段话则与气象学家Edward Lorenz有关。他发现简单的热对流现象居然能引起令人无法想象的气象变化，在对相关发现进行数学分析后，Lorenz于1963年提出了混沌理论 - Chaos Theory。混沌理论认为在混沌系统中，初始条件十分微小的变化，经过不断放大，对其未来状态会造成极其巨大的差别。 经过多年的发展，该理论已在气象、经济、化学、信息等诸领域得到广泛应用。但如果以混沌理论为关键词在Google上进行搜索，还会发现一些美轮美奂的艺术作品，这些艺术作品都与混沌理论中的吸引子有关。 版权声明 本文可以在互联网上自由转载，但必须：注明出处(作者：海洋饼干叔叔)并包含指向本页面的链接。 本文不可以以纸质出版为目的进行改编、摘抄。 1. Peter de Jong吸引子所谓吸引子 - Attractor，是动力系统里的一个状态，系统演化会趋向那个方向靠拢。Peter de Jong是一个奇异吸引子。奇异吸引子上的运动对初始值表现出极强的敏感依赖性，在初始值上的微不足道的差异，就会导致运动轨道的截然不同。奇异吸引子往往具有非整数维，如2.06维、1.2365维等。 Peter de Jong吸引子就是一个奇异吸引子，它可以由下述迭代方程描述：$$x_{n+1} = sin(ay_{n})-cos(bx_{n})\\y_{n+1} = sin(cx_{n})-cos(dy_{n})$$这个方程有4个参数，分别为a，b，c，d。随意指定x0和y0的值，比如(0,0)，通过上述公式，可计算得x1和y1。然后以x1和y1为基础，可计算得x2，y2 …… 这样一直迭代-iterate计算，我们就可以获得N个平面上的点(xi,yi)，把这些点在坐标系中画出来，就得到Peter de Jong吸引子的图像。 1234567891011121314151617181920212223#SimplePeterDeJong.pyfrom math import sin,cosfrom matplotlib import pyplot as pltdef iteration(): a,b,c,d = 0.970,-1.899,1.381,-1.506 x,y = 0,0 xdata,ydata = [],[] for i in range(1000000): xNew = sin(a*y) - cos(b*x) yNew = sin(c*x) - cos(d*y) x,y = xNew,yNew xdata.append(x) ydata.append(y) return xdata,ydataxdata,ydata = iteration()plt.figure(figsize=(6,6))plt.title(\"Peter de Jong Attractor\")plt.scatter(xdata,ydata,s=0.005)plt.show() 程序只有寥寥数行。首先我们从math模块导入了正弦-sin和余弦-cos函数；还导入了matplotlib中的pyplot模块并取名为plt。matplotlib是著名的C/C++语言编写的绘图包，可以很简单地生成各种图表。 iteration()函数进行迭代计算，首先初始化x = 0, y = 0，然后迭代计算100万个点，并把相应数据存入xdata,ydata列表并返回。xdata,ydata列表中存储了100万个点，其中第i个点的x轴坐标数据为xdata[i]，y轴坐标数据为ydata[i]。 plt.figure(figsize=(6,6))创建了一个长6英寸，宽6英寸的图-Figure，plt.title()函数设置了图的标题，plt.scatter()函数则在xy平面上绘制散点图，相应点的坐标数据包含在xdata及ydata列表中，s参数指定了点的绘制尺寸。plt.show()则把绘制好的图显示在屏幕上。程序运行结果如下： 在上图中，可以看到，x,y坐标的取值范围都是[-2, +2]。这是因为正弦函数和余弦函数的值域都是[-1, +1]，上述x,y取值为一个sin()减去一个cos()，两者各取极值，可得[-2,+2]的值域。 这个图表示了Peter de Jong吸引子的点的分布。它表现出混沌特性，当a,b,c,d的参数值不同时，图像差异会很大。为了把图变得美观一点，我们引入颜色。 2. 彩色PDJ吸引子1234567891011121314151617181920212223#ColoredPeterDeJong.py...def iteration(): e,f = 0.7,-1.1 a,b,c,d = 0.970,-1.899,1.381,-1.506 x,y,z = 0,0,0 xdata,ydata,zdata = [],[],[] for i in range(1000000): xNew = sin(a*y) - cos(b*x) yNew = sin(c*x) - cos(d*y) zNew = sin(e * x) - cos(f * z) x,y,z = xNew,yNew,zNew xdata.append(x) ydata.append(y) zdata.append(z) return xdata,ydata,zdataxdata,ydata,zdata = iteration()...plt.scatter(xdata,ydata,s=0.005,c=zdata)plt.show() 这段代码同前述代码有以下区别。首先，我们引用了新的参数e,f，并引入了z值。该z值以类似于x,y的方式被迭代计算，并通过zdata列表返回。 在plt.scatter()函数中，c=zdata表示每个散点的颜色从zdata列表中获取，即第i个散点的颜色数据为zdata[i]。至于matplotlib如何把zdata当中的浮点数据转换成实际的颜色，在这里作者没有深入探究。新程序的执行结果如下图。 3. 修改PDJ参数​ 作者尝试了几个不同的a,b,c,d参数，得到下述吸引子图像。 a,b,c,d = -0.709,1.638,0.452,1.740 a,b,c,d = 1.641,1.902,0.316,1.525 a,b,c,d = 1.4,-2.3,2.4,-2.1 a,b,c,d = 2.01,-2.53,1.61,-0.33 严格地说，上述吸引子图像远没有达到“艺术”效果。要想把上述吸引子图像画成“艺术”效果，需要图像渲染算法的知识，在这里没办法展开。其中一种比较有名的算法称之为分形火焰算法 - fractal flame algorithm。","categories":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/categories/Python/"},{"name":"数学之美","slug":"Python/数学之美","permalink":"http://codelearn.club/categories/Python/%E6%95%B0%E5%AD%A6%E4%B9%8B%E7%BE%8E/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/tags/Python/"},{"name":"吸引子","slug":"吸引子","permalink":"http://codelearn.club/tags/%E5%90%B8%E5%BC%95%E5%AD%90/"}]},{"title":"计算机是如何工作的？","slug":"computer","date":"2019-06-19T07:35:04.000Z","updated":"2020-03-03T05:08:43.740Z","comments":true,"path":"2019/06/computer/","link":"","permalink":"http://codelearn.club/2019/06/computer/","excerpt":"本文作为《Python编程基础与实践》一书的附录，向读者介绍计算机基础结构及工作原理。","text":"本文作为《Python编程基础与实践》一书的附录，向读者介绍计算机基础结构及工作原理。 版权声明 本文可以在互联网上自由转载，但必须：注明出处(作者：海洋饼干叔叔)并包含指向本页面的链接。 本文不可以以纸质出版为目的进行改编、摘抄。 占坑","categories":[{"name":"导论","slug":"导论","permalink":"http://codelearn.club/categories/%E5%AF%BC%E8%AE%BA/"}],"tags":[{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"http://codelearn.club/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"name":"体系结构","slug":"体系结构","permalink":"http://codelearn.club/tags/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"}]},{"title":"Visual Studio Code中的断点调试","slug":"vscdebug","date":"2019-06-16T06:50:04.000Z","updated":"2020-03-03T05:17:58.821Z","comments":true,"path":"2019/06/vscdebug/","link":"","permalink":"http://codelearn.club/2019/06/vscdebug/","excerpt":"本文描述Visual Studio Code的断点调试方法，帮助读者理解循环执行过程。","text":"本文描述Visual Studio Code的断点调试方法，帮助读者理解循环执行过程。 版权声明 本文可以在互联网上自由转载，但必须：注明出处(作者：海洋饼干叔叔)并包含指向本页面的链接。 本文不可以以纸质出版为目的进行改编、摘抄。 1. 简介在程序有BUG/缺陷，需要修复时，断点调试是发现缺陷的重要方法。对于初学者而言，断点调试还有另外一个用途：帮助理解程序背后的逻辑。 本文以下述程序为例，讲述在Visual Studio Code中的断点调试方法。 12345678910names = ['Peter Anderson', 'Frank Bush', 'Tom Henry','Jack Lee', 'Dorothy Henry']sName = \"NOTFOUND\"for x in names: if x.endswith(\"Henry\"): sName = x break print(x, \"not ends with 'Henry'.\")print(\"I found a Henry:\", sName) 2. 打断点在Visual Studio Code中打开相关代码文件，用鼠标在行号3的左方空白处单击（下图红点处），便会出现红色的断点-breakpoint。如果在相同位置再次单击，断点便会消失。在同一个程序中，断点可以打很多个。 3. 开始调试选择Debug-&gt;Start Debugging菜单项，或者直接按下F5快捷键（使用笔记本的读者注意：F5键可能同时复用了其它功能，需要配合Fn键使用); 然后在弹出的菜单里选择Python File / Debug the currently active Python file; 调试过程启动，程序开始运行，然后遇到了第3行的断点，停了下来。请读者注意，当前第3行是黄色高亮的，这说明程序执行完了1-2行，第3行处于等待执行状态。 上图的左方，VARIABLES/变量栏则列出了全部的LOCAL/局部变量。可以看到，作为第1行代码的执行结果，名字为names的变量存在，其值为一个列表。因为第3行代码尚未执行， 所以目前sName变量尚不存在。 4. 单步前进 - Step Into在前图的上方，有一个工具栏，其中，第三个按钮（方向向下的键头）的弹出标签为Step Into(F11)。这个按键的作用为单步前行。按一下这个按键，或者直接按F11，会发现程序向前执行了一行，第4行变为高亮待执行。作为第3行代码的执行结果，sName变量出现在左方VARIABLES栏中。如果把鼠标移至代码中的sName上方，Visual Studio Code还会显示sName变量的当前值为NOTFOUND。如下图： 5. 继续单步前进-研究循环再次点击Step Into, 第4行被执行，第5行变为高亮待执行。请读者注意，根据for循环, x变量取值names列表的第1个元素，其值为’Peter Anderson’。 显然，第5行的逻辑判断不成立，第6，7行不会被执行。再次按下Step Into后，第8行高亮待执行： Step Into执行第8行，下方控制台会输出相应的print结果，然后程序执行点回到了第4行，准备开始下一轮循环： 再次Step Into后，第5行高亮待执行。此时，x取值names列表的第2个元素，其值为’Frank Bush’: 同样，Frank Bush也不是Henry，第5行的逻辑判断不成立，6，7不执行，第8行执行 … 按Step Into两次，程序重新回到第4行，准备开始第三轮循环: 再次按下Step Into， 第5行高亮待执行。此时，x取值names列表的第3个元素，其值为’Tom Henry’。请注意，VARIABLES栏中x变量的值。 这一次不一样了，x以”Henry”结尾，所以第5行的逻辑判断成立，再次按下Step Into，程序来到了第6行: Step Into执行完第6行后，sName的值从’NOTFOUND’变成了’Tom Henry’，程序停在了第7行： 按照语义，break语句执行将导致循环直接结束，第8行不会执行，剩下的names列表中的’Jack Lee’, ‘Dorothy Henry’会被忽略，程序直接来到第9行。由于第9行是空行， Visual Studio Code直接来到第10行。请读者注意，根据缩进规则，第10行与第4行的for循环属于同一层级，不属于循环体内部代码。 再次Step Into, 第10行执行结束，下方控制台打印了“I found a Henry: Tom Henry。程序调试自动结束： 6. continue, while希望上述调试过程可以帮助读者理解for循环及break语句。 如果读者对continue, while循环等感到疑惑，也可以对相关代码进行调试研究。 7. Step Out, Step OverVisual Studio Code的调试工具栏内，还有Step Out, Step Over等按钮。不同于Step Into(单步前进)， Step Out, Step Over用于在调试过程中避免过分深入函数或者循环内部。","categories":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/categories/Python/"}],"tags":[{"name":"IDE","slug":"IDE","permalink":"http://codelearn.club/tags/IDE/"}]},{"title":"《Python编程基础及应用》在线MOOC","slug":"pyvideo","date":"2019-06-14T23:35:04.000Z","updated":"2020-03-03T05:55:47.980Z","comments":true,"path":"2019/06/pyvideo/","link":"","permalink":"http://codelearn.club/2019/06/pyvideo/","excerpt":"本文提供《Python编程基础及应用》一书配套的在线MOOC的最新访问地址。","text":"本文提供《Python编程基础及应用》一书配套的在线MOOC的最新访问地址。 BILIBILI https://www.bilibili.com/video/av34409478/ 网易云课堂 https://study.163.com/course/introduction/1006199001.htm 中国大学MOOC 建设中 读者QQ交流群1","categories":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/tags/Python/"}]},{"title":"PyQt扩展在VSC中的配置及基本使用方法","slug":"pyqtconfig","date":"2019-06-13T07:33:14.000Z","updated":"2020-06-21T10:30:27.823Z","comments":true,"path":"2019/06/pyqtconfig/","link":"","permalink":"http://codelearn.club/2019/06/pyqtconfig/","excerpt":"本文介绍在Visual Studio Code中PyQt扩展的配置及基本使用方法。","text":"本文介绍在Visual Studio Code中PyQt扩展的配置及基本使用方法。 版权声明 本文可以在互联网上自由转载，但必须：注明出处(作者：海洋饼干叔叔)并包含指向本页面的链接。 本文不可以以纸质出版为目的进行改编、摘抄。 PyQt工具简介Qt/PyQt中包括一系列的工具，其中： Qt Designer: 用即见即所得的方式设计图形界面，成果表现为扩展名为ui的文件。 可执行文件：pyqt5designer 。 UI Compiler: 将上述ui文件“编译”成Python程序。执行该Python程序便可以得ui文件所描述的图形界面。可执行文件: pyuic5。 Qt Linguist: 语言学家，可以便捷的实现软件的国际化，即生成软件的法语、英语、日语或者其它语种版本。工作模式大致可以描述成：先用pylupdate5扫描源代码中全部可翻译的字符串，然后用linguist翻译相应的字符串至目标语言，接下来用lrelease工具发布。软件运行时，加载法语版本的语言学家文件，软件界面就是法语，加载日语版本的语言学家文件，软件界面就是日语。可执行文件：linguist,pylupdate5,lrelease。 Resource Compiler: 资源编译器。UI文件设计过程中可以需要使用到各种图片，这些图片以资源文件的形式组织，扩展名为qrc；资源编译器负责将 qrc格式的资源文件编译成py文件，其中，图片被转换成bytes字节列。可执行文件： pyrcc5。 ​ PyQt扩展安装为了使用这些Qt工具，我们需要在Visual Studio Code中安装下述扩展或者其它类似功能的扩展并对扩展进行配置。Visual Studio Code上的扩展安装方法请回顾第一章相关内容。 pyqt5, pyqt5-tools作为Python扩展库，其安装路径位于Python安装路径的Lib\\site-packages子目录下。而上述Qt/PyQt工具的可执行文件，则可以在Python安装路径的Scripts路径下找到。在作者计算机上，该目录为： C:\\Users\\Alex\\AppData\\Local\\Programs\\Python\\Python38\\Scripts。 由于作者安装 Python解释器时选择将Python路径加入了系统路径。因此，上述C:\\Users\\Alex\\AppData\\Local\\Programs\\Python\\Python38\\Scripts路径在操作系统环境变量PATH中。引用上述目录中的可执行文件时，路径部分可以省略。 PyQt扩展的配置在Visual Studio Code中的Extensions管理页面，点击Qt for Python扩展的Manage齿轮按钮， 然后，按照提示逐一设置各种可执行文件/模块的路径及运行参数信息。 为方便读者，下表列出相关配置项的值。 配置项 值 备注 Path:Designer pyqt5designer.exe 文件在Python安装路径的Scripts目录下，该目录在系统路径中，故可直接使用 Path:Linguist / 本例中用不上，可不设置 Path:Lrelease / 本例中用不上，可不设置 Path:Pylupdate pylupdate5 -verbose -ts ./“${fileBasenameNoExtension}.ts” Path:Pyrcc pyrcc5 -o ./“${fileBasenameNoExtension}_rc.py” 注意_rc部分 Path:Pyuic pyuic5 -d -o ./“Ui_${fileBasenameNoExtension}.py” 注意Ui_部分 Path:Qmlscene / 本例中用不上，可不设置 创建新的UI文件在Visual Studio Code项目目录的空白位置右击鼠标，选择New Form(Qt Designer UI File) 注意: 由于一个Bug的存在，需要先在点击并打开任意一个ui文件（如下图中的MainWidget.ui)后，再在项目目录的空白处右击并选择New Form，否则会出错。 打开已有的UI文件在Visual Studio Code项目目录中单击打开UI文件（比如下图中的MainWidget.ui)，然后右击鼠标，在弹出菜单中选择Edit Form(Qt Designer UI File)。 资源文件的编译在Visual Studio Code中打开资源文件，如Images.qrc， 然后在编辑框中右击鼠标，并在弹出菜单中选择 Compile Resource File into Qt for Python File。 资源文件编译后，生成Images_rc.py文件。","categories":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/tags/Python/"}]},{"title":"《Python编程基础及应用》随书资料的下载","slug":"pycodedown","date":"2019-06-11T15:35:04.000Z","updated":"2020-05-04T11:02:18.247Z","comments":true,"path":"2019/06/pycodedown/","link":"","permalink":"http://codelearn.club/2019/06/pycodedown/","excerpt":"本页提供《Python编程基础及应用》一书的随书代码及其它资源的下载。 下载 - 随书源代码 https://codelearn.club/download/pylearn.zip (国外源，下载较慢) http://www.ircchina.com/filedownload/199810 （国内源，下载较快）","text":"本页提供《Python编程基础及应用》一书的随书代码及其它资源的下载。 下载 - 随书源代码 https://codelearn.club/download/pylearn.zip (国外源，下载较慢) http://www.ircchina.com/filedownload/199810 （国内源，下载较快） 下载 - 教学PPT 第2章习题及答案 第3章习题及答案 第4章习题及答案 第5章习题及答案 第6章习题及答案 第7章习题及答案 第8章习题及答案 第9章习题及答案 第10章习题及答案 第11章习题及答案 第12章习题及答案 第13章习题及答案 第14章习题及答案 第15章习题及答案 第16章习题及答案 第17章习题及答案 第18章习题及答案 第19章习题及答案 第20章习题及答案 第21章习题及答案 第22章习题及答案 第23章习题及答案","categories":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/categories/Python/"}],"tags":[{"name":"Book","slug":"Book","permalink":"http://codelearn.club/tags/Book/"}]},{"title":"Visual Studio Code里《Python编程实践》随书代码的打开及使用","slug":"pycodeuse","date":"2019-06-11T15:35:04.000Z","updated":"2020-03-03T05:13:10.766Z","comments":true,"path":"2019/06/pycodeuse/","link":"","permalink":"http://codelearn.club/2019/06/pycodeuse/","excerpt":"Visual Studio Code里《Python编程基础及应用》随书代码的打开及使用。","text":"Visual Studio Code里《Python编程基础及应用》随书代码的打开及使用。 版权声明 本文可以在互联网上自由转载，但必须：注明出处(作者：海洋饼干叔叔)并包含指向本页面的链接。 本文不可以以纸质出版为目的进行改编、摘抄。 1. 代码下载https://codelearn.club/2019/06/pycodedown/ 2. 解压缩代码下载后，请将代码解压缩到一个不含中文字符的文件夹内，如下图。可以看到，每一章的代码是一个子目录。 3. 用Visual Studio Code打开章节子目录以第二章为例，鼠标右键单击第二章代码子目录C2_VariableDataTypes，在弹出菜单中选择Open with Code. 接下来即可看到Visual Studio Code运行，并打开了相应的章节项目目录。 4. 运行程序文件在左侧单击datatypes.py，即可看到datatypes.py文件被打开，且处于可编辑状态。 选择Debug -&gt; Start Without Debugging菜单项，即可运行程序： 运行程序的结果被显示在Visual Studio Code的下方： 注意，有时候需要向下拉动右方的滚动条，才能看到输出结果。","categories":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/categories/Python/"}],"tags":[{"name":"Book","slug":"Book","permalink":"http://codelearn.club/tags/Book/"}]},{"title":"使用pip安装Python扩展库的方法","slug":"pipinstall","date":"2019-06-09T00:35:04.000Z","updated":"2020-03-03T04:59:43.952Z","comments":true,"path":"2019/06/pipinstall/","link":"","permalink":"http://codelearn.club/2019/06/pipinstall/","excerpt":"本文讨论Python扩展库的安装方法","text":"本文讨论Python扩展库的安装方法 版权声明 本文可以在互联网上自由转载，但必须：注明出处(作者：海洋饼干叔叔)并包含指向本页面的链接。 本文不可以以纸质出版为目的进行改编、摘抄。 使用pip进行安装对于Windows, 在开始菜单中找到并进入命令提示符，对于Linux或者Mac OS X, 请进入终端-Terminal. 在命令行中输入 pip install 模块名，然后回车-Enter, 即可安装模块。下图中，正在安装django(一种Python Web应用开发库)。 如果安装完成，系统会显示如下的信息： Successfully installed … 如果Windows命令提示符报错 “pip不是内部或者外部的命令”， 则说明在安装Python解释器时没有勾选下述选项，考虑后续使用方便，建议卸载Python解释器后重新安装。 Add Python 3.7 to PATH 在上述安装过程中，pip会从网络下载安装包。因此，安装时请保持网络连接通畅。由于相关服务器大多在国外，因此安装时经常会因为网络连接问题导致失败。此时，重新找一个网络通畅的位置重新安装即可。 如果上述命令报告：Requirement already satisfied, 这说明这个模块之前已经成功安装过。 通常，你还会在pip的输出中看到下述内容： 12You are using pip version 19.0.3, however version 19.2.3 is available.You should consider upgrading via the &#39;python -m pip install --upgrade pip&#39; command. 这不是错误！ 它只是提示你你的pip工具的版本不够新，建议你升级。一般不必升级。 如果终端报告: pip不是内部或者外部命令， 也不是可运行的程序。这说明你在安装Python解释器的过程中Add to Path那个选项没有打勾。最容易的解决方案是卸载掉Python解释器后重新安装。安装时请务必按照随书网文中的步骤谨慎进行。 PIP是Python的包管理工具。 在部分Linux系统下，Python 2 和 Python 3的pip是分开的，为Python 3安装包，需要运行pip3。 如何验证模块是否安装成功? 在命令行中运行Python解释器，import numpy没有报错，说明numpy模块已成功安装；import flask报错，说明flash模块还没有成功安装；exit()命令退出解释器。 注意，部分模块的模块名与import时使用的名称可能不同，比如opencv的模块名为opencv-python，但导入时应使用import cv2。 模块被安装到了哪里？在Python解释器中，import sys, sys.path可以看到Python解释器在系统中的安装路径。比如作者计算机上的图径为C:\\Users\\Alex\\AppData\\Local\\Programs\\Python\\Python37。 在这个路径的Lib\\site-packages路径下，可以看到那些被安装的模块的文件。 安装失败怎么办有时候安装会失败。最大的可能是因为网速太慢，具体说是国内到pip官方软件仓库服务器的网速太慢。解决方案有两个： a. 找个网速好的地方再执行两次； b. 试试国内的镜像源，该镜像源可以通过-i 参数指定，比如，下述命令试图从国内清华的镜像源安装django模块： 1pip install django -i https://pypi.tuna.tsinghua.edu.cn/simple","categories":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/tags/Python/"}]},{"title":"说说程序中的命名规则","slug":"namemethod","date":"2019-06-08T23:35:04.000Z","updated":"2020-03-03T05:11:13.853Z","comments":true,"path":"2019/06/namemethod/","link":"","permalink":"http://codelearn.club/2019/06/namemethod/","excerpt":"程序里有很多东西需要命名， ​ 良好的命名习惯可以提高编程效率； 减少出错； ​ 良好命名的程序清晰易读。 ​ 好的名称可以提供很多有价值的信息。 本文解释作者在《Python编程基础及应用》一书中所使用的命名规则。","text":"程序里有很多东西需要命名， ​ 良好的命名习惯可以提高编程效率； 减少出错； ​ 良好命名的程序清晰易读。 ​ 好的名称可以提供很多有价值的信息。 本文解释作者在《Python编程基础及应用》一书中所使用的命名规则。 命名示例 变量、类的数据成员 iSum sName fPrice 函数名称 add() convert() del() empty() push_back() pop() getPrice() setPrice() draw() render() repaint() 类型名称 Student GraphDrawer Campus Engine FloatBuffer Lesson Monitor Printer EMailPacket 版权声明 本文可以在互联网上自由转载，但必须：注明出处(作者：海洋饼干叔叔)并包含指向本页面的链接。 本文不可以以纸质出版为目的进行改编、摘抄。 正确， 错误 vs 好，相对不好， 坏只要符合所用语言的命名规则的命名原则上都是“正确”的。 不同的人有不同的命名习惯。 没有标准答案，只有主观的好或者相对不好的判断。 但真的很重要： ​ 良好的命名习惯可以提高编程效率； 减少出错； ​ 良好命名的程序清晰易读。 ​ 好的名称可以提供很多有价值的信息。 规则1 全程使用英文，不准用拼音 ▪KHBH XH ZHYE DQJG - 猜得出这些名称是什么意思吗？ sCustomerNo, sStudentNo fAccountBalance fCurrentPrice Too long for you ? sCusNo, sStuNo, fAccBalance , fCurPrice 规则2 变量/类的数据成员的命名类型名缩写(小写） + 英文单词或其缩写（首字母大写） 类型 解释 缩写 举例 float 浮点数 f fPrice fSum fAmount fScore fHeight fWeight int 整数 i iCount / iCnt iStudentCount iWidth iHeight iCapacity string 字符串 s sStudentNo sMemo sHint sDiagnostics sContent sName bool 布尔型 b bFound bCaptured bFull bHungry bDied bMarried bAvailable 如果变量表达的是一个集合（数组或者list), 用小写的英文单词的复数形式： ​ students members prices wheels teachers universities shoes arms 规则3 函数的命名一个英文单词： 小写 add() convert() del() empty() try() pop() push() 两个英文单词： 第二个单词首字母大写 动+名 addAmount() setPrice() getPrice() setEmpty() pushDown() riseUp() toString() toDouble() 规则4 类型的命名由一个或者两个英文单词构成，每个单词的首字母均大写 FloatBuffer PrinterQueue Student Lesson Movie Song Employee Team Board Company Supplier GoldFish CellPhone GraphDrawer 在面向对象程序设计当中，一个文件通常只包括一个类型，通常文件名由类型名 + . + 扩展名构成: Student.py Company.h Company.cpp PrinterQueue.java 规则5 例外如果有一个临时变量，仅在上下几行局部代码中被使用，用完即弃，可以用小写单字母：(代码阅读者容易通过上下文确定变量的类型和用途) 12345s = s + “, Done”print(s)for i in range(100): print(i) 当心中文目录及中文文件名很多开发环境及软件对中文的支持并不好，永远不要使用任何包含中文的目录或文件名： 示例 正/误 d:/学习资料/python/实验1 X d:/Learing/python/Test1 √ 忠告命名这件事不同的人有不同的看法。 认真命好每个名， 尽量遵守规则。 表面上花时间，实际上省时间。 程序如果需要交给教师检查或者请求教师协助，两件事情先做好： 确认命名符合要求； 把程序排列整齐，检查缩进，分行。","categories":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/tags/Python/"},{"name":"语法","slug":"语法","permalink":"http://codelearn.club/tags/%E8%AF%AD%E6%B3%95/"}]},{"title":"Python解释器的安装","slug":"pythoninstall","date":"2019-06-08T23:35:04.000Z","updated":"2020-03-03T05:14:32.385Z","comments":true,"path":"2019/06/pythoninstall/","link":"","permalink":"http://codelearn.club/2019/06/pythoninstall/","excerpt":"本文描述Python官方解释器的下载及安装方法，主要考虑Windows系统。 Mac OS X以及Linux系统也有涉及。","text":"本文描述Python官方解释器的下载及安装方法，主要考虑Windows系统。 Mac OS X以及Linux系统也有涉及。 版权声明 本文可以在互联网上自由转载，但必须：注明出处(作者：海洋饼干叔叔)并包含指向本页面的链接。 本文不可以以纸质出版为目的进行改编、摘抄。 Python解释器软件可以在www.python.org官网上下载。下载前，读者可能需要先了解自己的计算机是64位或者32位系统。 对于Windows系统，可以在系统属性页面查得相关信息。 Python官网可能会同时提供多个版本，包括Beta版本（测试中的极可能包含错误的版本）供用户选择，建议读者下载稳定-Stable版本。对于32位系统，下载时应选择x86版本，对于64位操作系统，下载时应选择x86-64的版本。由于作者的系统是Windows 10 64位系统，所以作者选择”Windows x86-64 executable installer”进行下载。 下载完成后，作者得到了一个名为python-3.7.3-amd64.exe的可执行文件。对于这种可执行文件，下载后浏览器或者操作系统出于安全考虑可能会让你确认是否保留该文件，请选择保留。 在文件夹中鼠标左键双击运行，请务必勾选下方的两个选项，其中，Add Python 3.7 to PATH将Python相关目录加入操作系统的PATH环境变量。然后选择Install Now进行安装。 安装大约持续一两分钟，结束后点Close按钮即可。 注意：请不要在一台计算机上同时安装Python解释器的多个版本，这通常会导致初学者难以解决的混乱。 使用Mac OS X系统的读者 ​ 基本的安装方法差异不大，只是读者在下载安装包时，需要下载Mac OS X对应用版本。 使用Ubuntu等Linux系统的读者 请在终端-Terminal下执行下述命令，进行安装。 1sudo apt-get install python3","categories":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/tags/Python/"}]},{"title":"Python解释器的简单使用","slug":"pythonuse","date":"2019-06-08T23:35:04.000Z","updated":"2020-03-03T05:15:10.230Z","comments":true,"path":"2019/06/pythonuse/","link":"","permalink":"http://codelearn.club/2019/06/pythonuse/","excerpt":"本文简单描述Python官方解释器的使用方法。","text":"本文简单描述Python官方解释器的使用方法。 版权声明 本文可以在互联网上自由转载，但必须：注明出处(作者：海洋饼干叔叔)并包含指向本页面的链接。 本文不可以以纸质出版为目的进行改编、摘抄。 在Windows系统下，Python解释器可以在终端命令行中启动。读者可以在Windows系统菜单中选择命令提示符，以进入终端。在Mac OS X或者Linux系统中，终端通常称为Terminal。 在终端中输入python，然后回车-Enter，即可运行Python解释器。如果终端提示Python不是可运行的程序或者命令，那说明前述安装过程不正确或者安装启动时那个重要的勾没有打上，请卸载后重新安装。在Linux等其它系统中，启动Python 3版本的解释器可能需要输入python3命令，直接输入python很可能运行的是Python 2版本的解释器。 解释器里的&gt;&gt;&gt;符号后可以看到光标在闪烁，这里我们输入a = 3 + 2，然回按回车键；接下来输入a，再回车，可以看到系统报告a的值为5。在&gt;&gt;&gt;后输入命令exit()，解释器软件退出。 部分读者在终端/命令提示符会遇到命令无法输入的困难，这很可能跟输入法设置有关。建议初学者尽量将输入法切换至EN(英语)。","categories":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/tags/Python/"}]},{"title":"Visual Studio Code的扩展安装及配置","slug":"vscconfig","date":"2019-06-08T23:35:04.000Z","updated":"2020-03-03T05:02:32.671Z","comments":true,"path":"2019/06/vscconfig/","link":"","permalink":"http://codelearn.club/2019/06/vscconfig/","excerpt":"本文描述Visual Studio Code的扩展安装及配置方法。","text":"本文描述Visual Studio Code的扩展安装及配置方法。 版权声明 本文可以在互联网上自由转载，但必须：注明出处(作者：海洋饼干叔叔)并包含指向本页面的链接。 本文不可以以纸质出版为目的进行改编、摘抄。 界面左侧的这个图标用于管理Visual Studio Code的扩展 -Extensions。 在扩展页里，读者可以看到已经安装好的扩展，比如上述名为Python的扩展，以及系统推荐安装的扩展。必要时，读者还可以在Marketplace中搜索安装特定的扩展。正是这些扩展，赋予Visual Studio Code编译不同语言代码的能力，它既可以用于编辑Python，也可以编译C++, Java等语言代码。 读者可能会发现你的Visual Studio Code界面的配色，以及字体等与作者的不同。为了方便印刷和演示，作者对软件进行了设置。读者可以通过File-Preferences-Settings菜单项进行设置界面。在这里，读者可以设置界面的字体-Font, 界面的外观-Appearance等选项。 通过菜单File-Preferences-Keyboard Shortcuts可以调出软件全部的快捷键。等读者建立起一定的熟练程度后，适当记忆并使用这些快捷键有助于提高工作效率。","categories":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/categories/Python/"}],"tags":[{"name":"IDE","slug":"IDE","permalink":"http://codelearn.club/tags/IDE/"}]},{"title":"Visual Studio Code的下载与安装","slug":"vscinstall","date":"2019-06-08T23:35:04.000Z","updated":"2020-03-03T05:02:44.669Z","comments":true,"path":"2019/06/vscinstall/","link":"","permalink":"http://codelearn.club/2019/06/vscinstall/","excerpt":"本文描述Visual Studio Code的下载及安装方法。","text":"本文描述Visual Studio Code的下载及安装方法。 版权声明 本文可以在互联网上自由转载，但必须：注明出处(作者：海洋饼干叔叔)并包含指向本页面的链接。 本文不可以以纸质出版为目的进行改编、摘抄。 Visual Studio Code是由微软公司提供的免费代码编辑工具，可以在下述网址下载。同样地，读者需要根据自己的操作系统类型和位数(32/64位)选择对应的版本。 https://code.visualstudio.com/Download 作者选择的是Windows-System Installer 64bit版本。下载完成的软件是一个名为VSCodeSetup-x64-1.35.0.exe的可执行文件。 双击该文件启动安装。 选择“下一步”继续。 MIT协议是一种开源软件许可协议，其名源自“麻省理工学院”，这种协议赋予被授权者极大的自由和很少的限制。选择“我接受协议”，然后选“下一步”。在后续安装过程中，一直选“下一步”。 在这一页，我们建议读者将全部选项打上勾，这将方便软件的后续使用。 选择“安装”。安装完成后，读者应能在Windows系统的桌面上找到一个名为Visual Studio Code的图标。如果桌面上没有，在系统的开始菜单里应能找到： 在桌面上双击该图标，或者在系统开始菜单里选择该图标，可以启动Visual Studio Code软件。","categories":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/categories/Python/"}],"tags":[{"name":"IDE","slug":"IDE","permalink":"http://codelearn.club/tags/IDE/"}]},{"title":"Visual Studio Code的简单使用","slug":"vscuse","date":"2019-06-08T23:35:04.000Z","updated":"2020-03-03T05:02:56.316Z","comments":true,"path":"2019/06/vscuse/","link":"","permalink":"http://codelearn.club/2019/06/vscuse/","excerpt":"本文描述Visual Studio Code的基本使用方法。","text":"本文描述Visual Studio Code的基本使用方法。 版权声明 本文可以在互联网上自由转载，但必须：注明出处(作者：海洋饼干叔叔)并包含指向本页面的链接。 本文不可以以纸质出版为目的进行改编、摘抄。 1.打开或者创建项目目录Visual Studio Code是一个跨语言的代码编辑工具，可以简单地使用目录-Folder来管理程序文件。选择File-Open Folder…菜单。 然后在某个盘下创建一个不含中文字符的英文目录，比如PyLearn, 选中，然后选“选择文件夹”。作者强烈建议，不要在程序目录或者程序的文件名中使用中文字符，英文是编程世界的通用语言，使用中文字符可能带来一些意想不到的问题。 界面左上角的图标为EXPLORER图标，点击它可以打开或者关闭位于界面左侧的EXPLORER。 2. 添加py程序文件在EXPLORER中，可以看到打开的PyLearn目录，点击目录右方的New File加号按钮，增加一个名为1.py的文件。点击New Folder加号按钮，则可以在PyLearn目录下添加子目录。 1.py中点前面的”1”称之为文件的基本名，点之后的”py”则为文件的扩展名。一个文件的扩展名为py说明文件中包括的是Python语言书写的程序。双击1.py可以打开该文件进行编辑。我们在文件中输入如下内容： 请注意，上述内容是往左顶格输入的，即字母p前没有空格；另个，整行内容全部是英文字符，没有中文字符。 3. 安装PyLint扩展 此时，软件可能会提示你安装一个跟Python有关的扩展-extension，请选择”Install”。 4. 程序运行，查看结果安装完扩展后，就可以尝试执行1.py文件内的代码了。保持1.py被打开，然后选择Debug-Start Without Debugging，即可运行1.py程序。 如果你在软件的下方找到了上述 “Hello”输出，那么说明，你已准备好了本书所需要的软件环境。 请读者注意上图中的红色箭头所指向的滚动条，有时，需要向下拉动这个滚动条至最下端，才可以看到Visual Studio Code的最新输出。 作者认为这是Visual Sudio Code的一个小小的设计缺陷，希望读者读到这些文字时，该缺陷已经得到修正。","categories":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/categories/Python/"}],"tags":[{"name":"IDE","slug":"IDE","permalink":"http://codelearn.club/tags/IDE/"}]},{"title":"在线MOOC - 第1章 @Python编程基础及应用","slug":"pymooc1","date":"2019-05-03T23:35:04.000Z","updated":"2020-03-03T06:40:50.822Z","comments":true,"path":"2019/05/pymooc1/","link":"","permalink":"http://codelearn.club/2019/05/pymooc1/","excerpt":"","text":"在线MOOC - 第1章 @Python编程基础及应用 https://www.bilibili.com/video/av34409478/?p=21","categories":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/tags/Python/"}]},{"title":"在线MOOC - 第10章 @Python编程基础及应用","slug":"pymooc10","date":"2019-05-03T23:35:04.000Z","updated":"2020-03-03T06:42:21.153Z","comments":true,"path":"2019/05/pymooc10/","link":"","permalink":"http://codelearn.club/2019/05/pymooc10/","excerpt":"","text":"在线MOOC - 第10章 @Python编程基础及应用 https://www.bilibili.com/video/av34409478/?p=46","categories":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/tags/Python/"}]},{"title":"在线MOOC - 第13章 @Python编程基础及应用","slug":"pymooc13","date":"2019-05-03T23:35:04.000Z","updated":"2020-03-03T06:42:13.291Z","comments":true,"path":"2019/05/pymooc13/","link":"","permalink":"http://codelearn.club/2019/05/pymooc13/","excerpt":"","text":"在线MOOC - 第13章 @Python编程基础及应用 https://www.bilibili.com/video/av34409478/?p=55","categories":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/tags/Python/"}]},{"title":"在线MOOC - 第12章 @Python编程基础及应用","slug":"pymooc12","date":"2019-05-03T23:35:04.000Z","updated":"2020-03-03T06:42:15.499Z","comments":true,"path":"2019/05/pymooc12/","link":"","permalink":"http://codelearn.club/2019/05/pymooc12/","excerpt":"","text":"在线MOOC - 第12章 @Python编程基础及应用 https://www.bilibili.com/video/av34409478/?p=54","categories":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/tags/Python/"}]},{"title":"在线MOOC - 第16章 @Python编程基础及应用","slug":"pymooc16","date":"2019-05-03T23:35:04.000Z","updated":"2020-03-03T06:43:24.380Z","comments":true,"path":"2019/05/pymooc16/","link":"","permalink":"http://codelearn.club/2019/05/pymooc16/","excerpt":"","text":"在线MOOC - 第16章 @Python编程基础及应用 https://www.bilibili.com/video/av34409478/?p=49","categories":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/tags/Python/"}]},{"title":"在线MOOC - 第11章 @Python编程基础及应用","slug":"pymooc11","date":"2019-05-03T23:35:04.000Z","updated":"2020-03-03T06:42:17.660Z","comments":true,"path":"2019/05/pymooc11/","link":"","permalink":"http://codelearn.club/2019/05/pymooc11/","excerpt":"","text":"在线MOOC - 第11章 @Python编程基础及应用 https://www.bilibili.com/video/av34409478/?p=46","categories":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/tags/Python/"}]},{"title":"在线MOOC - 第14章 @Python编程基础及应用","slug":"pymooc14","date":"2019-05-03T23:35:04.000Z","updated":"2020-03-03T06:42:09.722Z","comments":true,"path":"2019/05/pymooc14/","link":"","permalink":"http://codelearn.club/2019/05/pymooc14/","excerpt":"","text":"在线MOOC - 第14章 @Python编程基础及应用 https://www.bilibili.com/video/av34409478/?p=57","categories":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/tags/Python/"}]},{"title":"在线MOOC - 第15章 @Python编程基础及应用","slug":"pymooc15","date":"2019-05-03T23:35:04.000Z","updated":"2020-03-03T06:43:24.380Z","comments":true,"path":"2019/05/pymooc15/","link":"","permalink":"http://codelearn.club/2019/05/pymooc15/","excerpt":"","text":"在线MOOC - 第15章 @Python编程基础及应用 https://www.bilibili.com/video/av34409478/?p=57","categories":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/tags/Python/"}]},{"title":"在线MOOC - 第19章 @Python编程基础及应用","slug":"pymooc19","date":"2019-05-03T23:35:04.000Z","updated":"2020-03-03T06:43:24.381Z","comments":true,"path":"2019/05/pymooc19/","link":"","permalink":"http://codelearn.club/2019/05/pymooc19/","excerpt":"","text":"在线MOOC - 第19章 @Python编程基础及应用 https://www.bilibili.com/video/av34409478/?p=61","categories":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/tags/Python/"}]},{"title":"在线MOOC - 第17章 @Python编程基础及应用","slug":"pymooc17","date":"2019-05-03T23:35:04.000Z","updated":"2020-03-03T06:43:24.380Z","comments":true,"path":"2019/05/pymooc17/","link":"","permalink":"http://codelearn.club/2019/05/pymooc17/","excerpt":"","text":"在线MOOC - 第17章 @Python编程基础及应用 https://www.bilibili.com/video/av34409478/?p=50","categories":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/tags/Python/"}]},{"title":"在线MOOC - 第21章 @Python编程基础及应用","slug":"pymooc21","date":"2019-05-03T23:35:04.000Z","updated":"2020-03-03T06:43:24.380Z","comments":true,"path":"2019/05/pymooc21/","link":"","permalink":"http://codelearn.club/2019/05/pymooc21/","excerpt":"","text":"在线MOOC - 第21章 @Python编程基础及应用 https://www.bilibili.com/video/av34409478/?p=63","categories":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/tags/Python/"}]},{"title":"在线MOOC - 第2章 @Python编程基础及应用","slug":"pymooc2","date":"2019-05-03T23:35:04.000Z","updated":"2020-03-03T06:42:39.012Z","comments":true,"path":"2019/05/pymooc2/","link":"","permalink":"http://codelearn.club/2019/05/pymooc2/","excerpt":"","text":"在线MOOC - 第2章 @Python编程基础及应用 https://www.bilibili.com/video/av34409478/?p=5","categories":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/tags/Python/"}]},{"title":"在线MOOC - 第18章 @Python编程基础及应用","slug":"pymooc18","date":"2019-05-03T23:35:04.000Z","updated":"2020-03-03T06:43:24.380Z","comments":true,"path":"2019/05/pymooc18/","link":"","permalink":"http://codelearn.club/2019/05/pymooc18/","excerpt":"","text":"在线MOOC - 第18章 @Python编程基础及应用 https://www.bilibili.com/video/av34409478/?p=65","categories":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/tags/Python/"}]},{"title":"在线MOOC - 第20章 @Python编程基础及应用","slug":"pymooc20","date":"2019-05-03T23:35:04.000Z","updated":"2020-03-03T06:43:24.380Z","comments":true,"path":"2019/05/pymooc20/","link":"","permalink":"http://codelearn.club/2019/05/pymooc20/","excerpt":"","text":"在线MOOC - 第20章 @Python编程基础及应用 https://www.bilibili.com/video/av34409478/?p=64","categories":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/tags/Python/"}]},{"title":"在线MOOC - 第23章 @Python编程基础及应用","slug":"pymooc23","date":"2019-05-03T23:35:04.000Z","updated":"2020-03-03T06:43:21.798Z","comments":true,"path":"2019/05/pymooc23/","link":"","permalink":"http://codelearn.club/2019/05/pymooc23/","excerpt":"","text":"在线MOOC - 第23章 @Python编程基础及应用 https://www.bilibili.com/video/av34409478/?p=63","categories":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/tags/Python/"}]},{"title":"在线MOOC - 第3章 @Python编程基础及应用","slug":"pymooc3","date":"2019-05-03T23:35:04.000Z","updated":"2020-03-03T06:42:36.546Z","comments":true,"path":"2019/05/pymooc3/","link":"","permalink":"http://codelearn.club/2019/05/pymooc3/","excerpt":"","text":"在线MOOC - 第3章 @Python编程基础及应用 https://www.bilibili.com/video/av34409478/?p=10","categories":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/tags/Python/"}]},{"title":"在线MOOC - 第4章 @Python编程基础及应用","slug":"pymooc4","date":"2019-05-03T23:35:04.000Z","updated":"2020-03-03T06:42:33.961Z","comments":true,"path":"2019/05/pymooc4/","link":"","permalink":"http://codelearn.club/2019/05/pymooc4/","excerpt":"","text":"在线MOOC - 第4章 @Python编程基础及应用 https://www.bilibili.com/video/av34409478/?p=21","categories":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/tags/Python/"}]},{"title":"在线MOOC - 第22章 @Python编程基础及应用","slug":"pymooc22","date":"2019-05-03T23:35:04.000Z","updated":"2020-03-03T06:43:24.380Z","comments":true,"path":"2019/05/pymooc22/","link":"","permalink":"http://codelearn.club/2019/05/pymooc22/","excerpt":"","text":"在线MOOC - 第22章 @Python编程基础及应用 https://www.bilibili.com/video/av34409478/?p=63","categories":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/tags/Python/"}]},{"title":"在线MOOC - 第5章 @Python编程基础及应用","slug":"pymooc5","date":"2019-05-03T23:35:04.000Z","updated":"2020-03-03T06:42:31.733Z","comments":true,"path":"2019/05/pymooc5/","link":"","permalink":"http://codelearn.club/2019/05/pymooc5/","excerpt":"","text":"在线MOOC - 第5章 @Python编程基础及应用 https://www.bilibili.com/video/av34409478/?p=25","categories":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/tags/Python/"}]},{"title":"在线MOOC - 第7章 @Python编程基础及应用","slug":"pymooc7","date":"2019-05-03T23:35:04.000Z","updated":"2020-03-03T06:42:27.142Z","comments":true,"path":"2019/05/pymooc7/","link":"","permalink":"http://codelearn.club/2019/05/pymooc7/","excerpt":"","text":"在线MOOC - 第7章 @Python编程基础及应用 https://www.bilibili.com/video/av34409478/?p=31","categories":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/tags/Python/"}]},{"title":"在线MOOC - 第6章 @Python编程基础及应用","slug":"pymooc6","date":"2019-05-03T23:35:04.000Z","updated":"2020-03-03T06:42:29.176Z","comments":true,"path":"2019/05/pymooc6/","link":"","permalink":"http://codelearn.club/2019/05/pymooc6/","excerpt":"","text":"在线MOOC - 第6章 @Python编程基础及应用 https://www.bilibili.com/video/av34409478/?p=28","categories":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/tags/Python/"}]},{"title":"在线MOOC - 第8章 @Python编程基础及应用","slug":"pymooc8","date":"2019-05-03T23:35:04.000Z","updated":"2020-03-03T06:42:25.178Z","comments":true,"path":"2019/05/pymooc8/","link":"","permalink":"http://codelearn.club/2019/05/pymooc8/","excerpt":"","text":"在线MOOC - 第8章 @Python编程基础及应用 https://www.bilibili.com/video/av34409478/?p=34","categories":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/tags/Python/"}]},{"title":"在线MOOC - 第9章 @Python编程基础及应用","slug":"pymooc9","date":"2019-05-03T23:35:04.000Z","updated":"2020-03-03T06:42:23.156Z","comments":true,"path":"2019/05/pymooc9/","link":"","permalink":"http://codelearn.club/2019/05/pymooc9/","excerpt":"","text":"在线MOOC - 第9章 @Python编程基础及应用 https://www.bilibili.com/video/av34409478/?p=37","categories":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/tags/Python/"}]},{"title":"Lorenz洛伦兹微分方程求解","slug":"pylorenzintegrate","date":"2019-02-11T03:35:04.000Z","updated":"2020-03-03T05:00:28.152Z","comments":true,"path":"2019/02/pylorenzintegrate/","link":"","permalink":"http://codelearn.club/2019/02/pylorenzintegrate/","excerpt":"本小节求解Lorenz微分方程：在“数学之美”那一章里，为方便读者理解，Lorenz吸引子轨迹的计算采用了比较“原始”的方法。采用integrate模块中的odeint()函数可以更加方便地完成计算。Lorenz吸引子由下述三个微分方程定义：$$\\frac{dx}{dt}=\\sigma(y-x), \\quad \\frac{dy}{dt}=x(\\rho-z)-y,\\quad \\frac{dz}{dt}=xy-\\beta z$$","text":"本小节求解Lorenz微分方程：在“数学之美”那一章里，为方便读者理解，Lorenz吸引子轨迹的计算采用了比较“原始”的方法。采用integrate模块中的odeint()函数可以更加方便地完成计算。Lorenz吸引子由下述三个微分方程定义：$$\\frac{dx}{dt}=\\sigma(y-x), \\quad \\frac{dy}{dt}=x(\\rho-z)-y,\\quad \\frac{dz}{dt}=xy-\\beta z$$ 版权声明 本文可以在互联网上自由转载，但必须：注明出处(作者：海洋饼干叔叔)并包含指向本页面的链接。 本文不可以以纸质出版为目的进行改编、摘抄。 微实践 - Lorenz吸引子常微分方程组求解​ 在“数学之美”那一章里，为方便读者理解，Lorenz吸引子轨迹的计算采用了比较“原始”的方法。采用integrate模块中的odeint()函数可以更加方便地完成计算。Lorenz吸引子由下述三个微分方程定义：$$\\frac{dx}{dt}=\\sigma(y-x), \\quad \\frac{dy}{dt}=x(\\rho-z)-y,\\quad \\frac{dz}{dt}=xy-\\beta z$$​ 其中，σ, ρ, β为参数。这些方程定义了三维空间中的一个无质量点(x,y,z)的各轴坐标相对于时间的速度矢量。我们这里需要计算随着时间t的变化，无质量点(x,y,z)的运动轨迹，也就是一组时间点上的系统状态。 ​ 源代码如下： 123456789101112131415161718192021import numpy as npfrom scipy import integrateimport matplotlib.pyplot as pltfrom mpl_toolkits.mplot3d import Axes3Ddef lorenz(p,t,s,r,b): x,y,z = p.tolist() #无质量点的当前位置(x,y,z) print(\"x,y,z,t:\",x,y,z,t) #帮助理解odeint的执行过程 return s*(y-x),x*(r-z)-y,x*y-b*z #返回dx/dt,dy/dt,dz/dtt = np.arange(0,30,0.01)track1 = integrate.odeint(lorenz,(0.0,1.00,0.0),t,args=(10.0,28.0,2.6))track2 = integrate.odeint(lorenz,(0.0,1.01,0.0),t,args=(10.0,28.0,2.6))print(\"type(track1):\",type(track1),\"track1.shape:\",track1.shape)fig = plt.figure(figsize=(12,6))ax = fig.gca(projection='3d') #获取当前子图，指定三维模式ax.plot(track1[:,0],track1[:,1],track1[:,2],lw=1.0,color='r') #画轨迹1 ax.plot(track2[:,0],track2[:,1],track2[:,2],lw=1.0,color='g') #画轨迹2 ...plt.show() 控制台输出： 123456...x,y,z,t: -5.64346434502397 -6.711791064199058 21.875348370569984 12.728116763457338x,y,z,t: -5.6434643216721705 -6.7117909582448 21.875348207825766 12.728116763457338x,y,z,t: -5.776218568580239 -7.038353710472807 21.677470196579595 12.739506857199522...type(track1): &lt;class &#39;numpy.ndarray&#39;&gt; track1.shape: (3000, 3) ​ 首先，定义了函数lorenz()，它的任分是计算无质量点坐标各方向相对于时间t的微分值。参数s,r,b分别对应方程组中的σ, ρ, β，t为时间（在函数里没有用到），p是一个ndarray，p.tolist()将其转换成一个列表，其中包括当前无质量点的坐标。 ​ t = np.arange(0,30,0.01)以0.01有间隔，生成从0至30(不含)的等差数列，它代表了一组离散的时间点。 ​ integrate.odeint()则进行微分方程求解，参数lorenz指明了微分计算函数，(0.0,1.00,0.0)则为无质量点的位置初始值；t为离散时间点；args指定了要传递给lorenz函数的额外参数，对应s,r,b，为固定值。odeint()会迭代调用lorenz()函数，用于生成无质量点的运动轨迹。上述控制台输出的结果可以帮助读者理解x,y,z坐标及t的变化过程。 ​ t是一个长度为3000的一维数组，odeint()返回结果为一个形状为(3000,3)的二维数组，用3000个离散的三维空间点来表示无质量点的运动轨迹。据信，odeint()会将lorenz()函数返回的微分值再乘以dt以获得dx,dy和dz，这个过程其实跟我们在“数学之美”那一章的模拟计算过程类似，但更高效，更精确。 ​ track1[:,0]对track1二维数组进行下标切片，得到3000个元素的一维数组，表示3000个空间点的x坐标，y和z坐标以类似方式获得。 ​ 我们可以看到，track1-红和track2-绿仅在系统初始值上有细微差异，但随着时间的推进，其运动轨迹差异越来越大，表现出“混沌”性：南美洲一只蝴蝶扇动翅膀，会引起对面半球一场飓风。","categories":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/categories/Python/"},{"name":"科学计算","slug":"Python/科学计算","permalink":"http://codelearn.club/categories/Python/%E7%A7%91%E5%AD%A6%E8%AE%A1%E7%AE%97/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/tags/Python/"},{"name":"SciPy","slug":"SciPy","permalink":"http://codelearn.club/tags/SciPy/"},{"name":"integrate","slug":"integrate","permalink":"http://codelearn.club/tags/integrate/"},{"name":"混沌","slug":"混沌","permalink":"http://codelearn.club/tags/%E6%B7%B7%E6%B2%8C/"},{"name":"Lorenz","slug":"Lorenz","permalink":"http://codelearn.club/tags/Lorenz/"}]},{"title":"Python求解数值积分-定积分求解","slug":"pyintegrate","date":"2019-02-10T23:35:04.000Z","updated":"2020-03-03T05:13:32.604Z","comments":true,"path":"2019/02/pyintegrate/","link":"","permalink":"http://codelearn.club/2019/02/pyintegrate/","excerpt":"本小节求解下述定积分：$$\\int_{0.7}^4(cos(2πx)e^{-x}+1.2)\\mathrm{d}x$$","text":"本小节求解下述定积分：$$\\int_{0.7}^4(cos(2πx)e^{-x}+1.2)\\mathrm{d}x$$ 版权声明 本文可以在互联网上自由转载，但必须：注明出处(作者：海洋饼干叔叔)并包含指向本页面的链接。 本文不可以以纸质出版为目的进行改编、摘抄。 数值积分-integrate​ integrate模块提供了好几种数值积分的方法，包括常微分方程组(ODE)的数值积分。相关函数列表如下： 函数名 作用 函数名 作用 quad() 一元定积分 dblquad() 二元定积分 triquad() 三元定积分 odeint() 计算常微分方程组的数值解 微实践 - 定积分求解​ 本小节求解下述定积分：$$\\int_{0.7}^4(cos(2πx)e^{-x}+1.2)\\mathrm{d}x$$​ 为了方便说明，我们先使用下述代码画出示意图： 1234567891011121314import numpy as npfrom matplotlib import pyplot as pltx = np.linspace(0,6,1000)y = np.cos(2*np.pi*x)*np.exp(-x)+1.2plt.axis([np.min(x),np.max(x),0,np.max(y)]) #坐标范围plt.plot(x,y,label=\"$cos(2πx)e^&#123;-x&#125;+1.2$\") #画曲线，带图示plt.fill_between(x,y1=y,y2=0,where=(x&gt;=0.7)&amp;(x&lt;=4), #填充积分区域 facecolor='blue',alpha=0.2)plt.text(0.5*(0.7+4),0.4,r\"$\\int_&#123;0.7&#125;^4(cos(2πx)e^&#123;-x&#125;+1.2)\\mathrm&#123;d&#125;x$\", horizontalalignment='center',fontsize=14) #增加说明文本plt.legend() #显示图示plt.show() 执行结果： ​ plt.axis()函数设定了图的坐标范围。fill_between(x,y1=y,y2=0,where=(x&gt;=0.7)&amp;(x&lt;=4)…)则用于填充积分区域，其中，x和y1构成曲线1; x和y2=0构成曲线2(也就是横坐标线)；该函数填充两条曲线之间x值域为[0.7,4]的部分，where参数指明了这个值域。facecolor指定填充颜色，alpha参数指定透明度。 ​ plt.text()则在图上添加文本，前两个参数指定了文本的坐标位置，horizontalalignment=’center’要求文本在指定的位置水平居中摆放(指定位置位于文本的水平中心)。r”$…$“为文本内容：字符串前加表示放弃对字符串内的内容进行\\转义；两个”为文本内容：字符串前加r表示放弃对字符串内的内容进行\\转义；两个$包含起来说明其中的内容为LaTeX格式的公式。 ​ 显然，上述定积分就是上图中阴影部分的面积。 ​ 方法1：分成小矩形，计算面积和 1234567import numpy as npx = np.linspace(0.7,4.0,1000)y = np.cos(2*np.pi*x)*np.exp(-x)+1.2dx = x[1] - x[0] #每个矩形的宽度fArea = np.sum(y*dx) #矩形宽*高，再求和print(\"Integral area:\",fArea) 执行结果： 1Integral area: 4.032803310221616 ​ 上述代码中，把曲线的阴影部分分成1000个矩形，每个矩形的宽都是dx，第i个矩形的高则是yi。每个矩形的长乘宽，再求和，得积分面积。 ​ 方法2：使用quad()函数进行积分 123456789import mathfrom scipy import integratedef func(x): print(\"x=\",x) #用于展示quad()函数对func的多次调用 return math.cos(2*math.pi*x)*math.exp(-x)+1.2fArea,err = integrate.quad(func,0.7,4)print(\"Integral area:\",fArea) 执行结果： 1234567x&#x3D; 2.35x&#x3D; 0.7430542279466668x&#x3D; 3.9569457720533334x&#x3D; 2.4613227224815875...x&#x3D; 3.4178741117287044Integral area: 4.029065401143393 ​ 首先，我们定义了一个函数func()，它根据x计算y值。当对单个数值进行计算时，numpy的ufunc并不具备速度优势，所以我们使用了math模块。 ​ integrate.quad()专门用于计算一元定积分，fArea,err = integrate.quad(func,0.7,4)取x值域[0.7,4]进行数值积分，在积分过程中，会反复调用func()函数计算y值。其返回一个元组，包括积分结果及误差。 ​ integrate.quad()计算的积分会比方法1的矩形面积求和方法更加精确。","categories":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/categories/Python/"},{"name":"科学计算","slug":"Python/科学计算","permalink":"http://codelearn.club/categories/Python/%E7%A7%91%E5%AD%A6%E8%AE%A1%E7%AE%97/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/tags/Python/"},{"name":"SciPy","slug":"SciPy","permalink":"http://codelearn.club/tags/SciPy/"},{"name":"integrate","slug":"integrate","permalink":"http://codelearn.club/tags/integrate/"}]},{"title":"深入讨论Python中的序列切片语法","slug":"pyslice","date":"2019-02-10T23:35:04.000Z","updated":"2020-03-03T05:00:56.918Z","comments":true,"path":"2019/02/pyslice/","link":"","permalink":"http://codelearn.club/2019/02/pyslice/","excerpt":"本小节深入探讨Python中的序列切片语法。切片-slicing可以获取序列的子序列（列表，字符串…)： 12345678numbers = [x for x in range(10)]print(\"numbers:\",numbers)print(\"numbers[3:9]:\",numbers[3:9])print(\"numbers[3:]:\",numbers[3:])print(\"numbers[:9]:\",numbers[:9])print(\"numbers[-6:-1]:\",numbers[-6:-1])print(\"numbers[1:9:2]:\",numbers[1:9:2])print(\"numbers[-1:1:-2]:\",numbers[-1:1:-2])","text":"本小节深入探讨Python中的序列切片语法。切片-slicing可以获取序列的子序列（列表，字符串…)： 12345678numbers = [x for x in range(10)]print(\"numbers:\",numbers)print(\"numbers[3:9]:\",numbers[3:9])print(\"numbers[3:]:\",numbers[3:])print(\"numbers[:9]:\",numbers[:9])print(\"numbers[-6:-1]:\",numbers[-6:-1])print(\"numbers[1:9:2]:\",numbers[1:9:2])print(\"numbers[-1:1:-2]:\",numbers[-1:1:-2]) 版权声明 本文可以在互联网上自由转载，但必须：注明出处(作者：海洋饼干叔叔)并包含指向本页面的链接。 本文不可以以纸质出版为目的进行改编、摘抄。 切片切片-slicing可以获取序列的子序列（列表，字符串…)： 12345678numbers = [x for x in range(10)]print(\"numbers:\",numbers)print(\"numbers[3:9]:\",numbers[3:9])print(\"numbers[3:]:\",numbers[3:])print(\"numbers[:9]:\",numbers[:9])print(\"numbers[-6:-1]:\",numbers[-6:-1])print(\"numbers[1:9:2]:\",numbers[1:9:2])print(\"numbers[-1:1:-2]:\",numbers[-1:1:-2]) 执行结果： 1234567numbers: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]numbers[3:9]: [3, 4, 5, 6, 7, 8]numbers[3:]: [3, 4, 5, 6, 7, 8, 9]numbers[:9]: [0, 1, 2, 3, 4, 5, 6, 7, 8]numbers[-6:-1]: [4, 5, 6, 7, 8]numbers[1:9:2]: [1, 3, 5, 7]numbers[-1:1:-2]: [9, 7, 5, 3] 说明 - 切片功能强大到令人发挥的程度，同时也复杂到令人费解； - numbers[3:9]从下标3开始复制元素，直到下标8(9-1)； - numbers[3:]等价于numbers[3:10]，从下标3开始复制元素，直到末尾，即下标9(10-1)； - numbers[:9]等价于numbers[0:9]，从下标0开始复制元素，直到下标8(9-1)； - numbers[-6:-1]等价于numbers[4:9]，其中len(numbers)-6=4, len(numbers)-1=9； - numbers[1:9:2]从下标1开始复制元素，每复制1个元素，下标+2, 直到下标达到或超过9结束（注意不包括下标为9的元素); - numbers[-1:1:-2]从下标len(numbers)-1，即下标9开始复制元素，每复制1个元素，下标-2，直到下标&lt;=1结束（注意不包括下标为1的元素)。 ​ 综上，numbers的切片的完整形式为: numbers[x:y:z]，z为步长，缺省值为1，x为起始下标，y为终止下标。z &gt; 0时，x缺省为0, 包括最左端的元素， y缺省为len(numbers)，包括最右端的元素，最右端元素的下标为len(numbers)-1。注意，当z值为负数时，切片方向为从右往左，起始下标x应包括最右方（也就是最后一个）元素，故x的缺省值为len(numbers)-1；终止下标y则为-1， 这有点让有费解：因为如果y为0的话，列表的下标0元素将不会被包括在切片中。如果你还感到疑惑，请看下一小节。 深入理解切片​ 切片的过程事实上跟数值列表range(x,y,z)的计数过程十分类似，由于这个切片过程适用于所有序列(字符串，列表…)，故下图中我们用seq[x:y:z]表示序列及其切片参数，首先考虑z&gt;0的情况： ​ 现以numbers[1:9:2]为例，依上述流程图说明输出集合为什么是[1,3,5,7]。首先，下标取值x=1，然后开始循环： 123456789- 下标1 &lt; 9成立，复制numbers[1],即值1; - 下标&#x3D;1+2&#x3D;3; - 下标3 &lt; 9成立，复制numbers[3],即值3； - 下标&#x3D;3+2&#x3D;5; - 下标5 &lt; 9成立，复制numbers[5],即值5；- 下标&#x3D;5+2&#x3D;7; - 下标7 &lt; 9成立，复制numbers[7],即值7；- 下标&#x3D;7+2&#x3D;9; - 下标9 &lt; 9不成立，循环结束。 ​ 如果你有C/C++经验，看下面的代码秒懂，因为Python的解释器就是用C/C++编写的。 123for (int i=x;i&lt;y;i+=z)&#123; copy(seq[i]);&#125; ​ 当z&lt;0时，seq[x:y:z]的切片流程图如下： ​ ​ 当z&lt;0时，切片过程事实上是从序列尾部往头部方向行进的，由于z是负数，所以下标=下标+z事实上导致下标减小。如果你有C/C++经验，看下面的代码秒懂，因为Python的解释器就是用C/C++编写的。 123for (int i=x;i&gt;y;i+=z)&#123; copy(seq[i]);&#125; ​ 该你了，请依上述流程图，人肉执行numbers[-1:1:-2]的切片过程，看看输出结果跟Python解释器输出是否一致。提示，-1表示倒数第1个元素，即len(numbers)-1=9。 ​ 妙用切片12345678910numbers = [x for x in range(10)]numbersCopy = numbers[:]print(\"id:\", id(numbers), numbers)print(\"id:\", id(numbersCopy), numbersCopy)numbersReversed = numbers[::-1]print(\"numbersReversed:\",numbersReversed)numbers[3:5] = 77,88print(\"numbers:\",numbers) 执行结果： 1234id: 2611651371592 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]id: 2611651371656 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]numbersReversed: [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]numbers: [0, 1, 2, 77, 88, 5, 6, 7, 8, 9] ​ 从上述代码及执行结果可以看出，numbers[:]产生了numbers的副本，其效果等价于numbers.copy(), numbers与numbersCopy的id值不同；而numbers[::-1]从尾部往前进行切片，其切片正好将序列倒序。这与numbers.reverse()有区别，numbers.reverse()会导致numbers列表被改变，且不会返回新列表；而numbers[::-1]会保持numbers列表不变，并生成一个新的列表。 ​ 请注意倒数第二行代码，对列表的切片还可以用于批量修改列表元素。从结果可见，numbers[3:5] = 77,88等价于numbers[3] = 77和numbers[4] = 88。 字符串切片​ 作为一种序列，字符串的切片方法与列表几乎完全相同，见下述代码： 1234numbers = '0123456789'print(numbers[2:5])print(numbers[1:9:2])print(numbers[:3:-2]) 执行结果： 1232341357975","categories":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/tags/Python/"},{"name":"切片","slug":"切片","permalink":"http://codelearn.club/tags/%E5%88%87%E7%89%87/"}]},{"title":"深入理解Python的数据类型及名字绑定","slug":"pynamebinding","date":"2019-02-10T22:35:04.000Z","updated":"2020-03-03T05:00:33.921Z","comments":true,"path":"2019/02/pynamebinding/","link":"","permalink":"http://codelearn.club/2019/02/pynamebinding/","excerpt":"​ 本小节深入讨论Python中的数据类型与名字绑定的关系，了解赋值过程的内部细节。","text":"​ 本小节深入讨论Python中的数据类型与名字绑定的关系，了解赋值过程的内部细节。 版权声明 本文可以在互联网上自由转载，但必须：注明出处(作者：海洋饼干叔叔)并包含指向本页面的链接。 本文不可以以纸质出版为目的进行改编、摘抄。 数据类型及名字绑定​ 除了已经讨论过的整数-int、 浮点数-float、 布尔型-bool、字符串-str、列表-list之外，还有一些数据类型尚待讨论。 元组-只读的列表​ 元组-tuple就是只读的列表。所谓只读，是指一个元组创建出来以后， 其值或者元素可以获取，但不能修改。上一章所讲述的关于列表的嵌套、in、not in、统计、运算等都适用于元组，切片也适用。注意切片并不会导致原始列表/元组被修改，其只会创建一个新列表/元组。 ​ 那些会导致列表发生修改的成员函数，比如remove(), sort()则不适用于元组，因为元组是只读的。 123456789patient = ('2012011', 'Eric Zhang', 'male', 77, True, (67,22,78))print(type(patient), patient)print(len(patient))print(patient[1:4])print(patient.count(True))print(True in patient)print(max((1,3,5)))print((1,2) + (2,3) + (4,))print((1,2) * 5) 执行结果： 12345678&lt;class &#39;tuple&#39;&gt; (&#39;2012011&#39;, &#39;Eric Zhang&#39;, &#39;male&#39;, 77, True, (67, 22, 78))6(&#39;Eric Zhang&#39;, &#39;male&#39;, 77)1True5(1, 2, 2, 3, 4)(1, 2, 1, 2, 1, 2, 1, 2, 1, 2) ​ 可以看到，元组用()框起来定义。上面的代码展示了元组的嵌套、len()函数、切片、max()、count()成员函数、in、拼接、运算等操作，其方法和用途与列表完全相同。 ​ 请注意上述代码中最后一行这个奇怪的表达”(4,)“, 这是告知解释器，这是由一个元素构成的元组，而不是打了括号的整数4。 ​ 下述操作则不适用于元组，因为这些操作预期会改变元组的值，而元组是只读的。 123456patient = ('2012011', 'Eric Zhang', 'male', 77, True, (67,22,78))#下述代码是发生执行错误patient[1] = 'NEW VALUE'patientSort = patient.sort()patient.remove(77)patient.clear() 生成与转换12345678numbers = tuple([1,2,3])print(numbers)chars = tuple('abc')print(chars)digits1 = (x for x in range(9))print(\"digits1:\", digits1)digits2 = tuple(x for x in range(9))print(digits2) 执行结果： 1234(1, 2, 3)(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;)digits1: &lt;generator object &lt;genexpr&gt; at 0x0000019D5458BA20&gt;(0, 1, 2, 3, 4, 5, 6, 7, 8) 可以看到，tuple()函数接受一个列表、字符串或者一个生成者对象-generator object作为参数，并返回一个元组。注意，digits1 = (x for x in range(9))被认为是一个生成者对象-generator object。 bytes​ 本节是介绍性内容，初学者如果对底层细节不感兴趣，可以略过。 ​ 在工业应用中，比如用Python语言编写工业机器人的控制程序，我们经常需要跟硬件直接通信。在数字电路里，永远是二进制的，所以我们所描述的全部数据类型在计算机内部最终全部以二进制形式存储和传输。bytes是只读的“二进制字节流”类型。 123456789buffer = b'abcdefghijklmn'print(buffer,type(buffer),\"len=\",len(buffer))print(buffer[2:9:2])buffer = b'\\x11\\xff\\x77'print(\"%x\" % (buffer[1]))buffer = bytes(i+0x10 for i in range(10))print(buffer) 执行结果： 1234b&#39;abcdefghijklmn&#39; &lt;class &#39;bytes&#39;&gt; len&#x3D; 14b&#39;cegi&#39;ffb&#39;\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19&#39; ​ 上述代码及执行结果展示了bytes的定义，len()函数、切片等基本操作。bytes()函数可以把一个生成者对象转换为bytes。一个字节如果看作无符号整数的话， 可以存储0-255之间的任何值。所以bytes作为字节流，其每个字节可以存任何0-255之间的任意整数，不限于’a’,’2’ 这些”可见”字符。 转换12345678x = 65534bufferLittle = x.to_bytes(2, 'little')print(\"little endian:\", bufferLittle)bufferBig = x.to_bytes(2,'big')print(\"big endian:\", bufferBig)y = int.from_bytes(b'\\xfe\\xff','little')print(y) 执行结果： 123little endian: b&#39;\\xfe\\xff&#39;big endian: b&#39;\\xff\\xfe&#39;65534 ​ 如上，int的to_bytes()成员函数将一个整数转换成指定字节长度(示例中为2)的bytes，第2个参数’little’指明了字节编码顺序。现存的CPU在存储和处理数据时，存在little endian和big endian两种标准，其中，little endian高位字节存高地址，big endian则正好相反。常用的Intel x86 CPU（用于PC系统）以及ARM CPU(常见于智能手机及其它嵌入式系统，智能电视之类)都是little endian的。 ​ int的from_bytes()成员函数则把bytes重新打包成Python的int对象。 ​ 借助于struct模块，我们可以更方便地把int, float和其它数据类型同bytes进行相互转换。 bytearray​ 本节是介绍性内容，初学者如果对底层细节不感兴趣，可以略过。 ​ bytearray可以译作字节数组，其功用与bytes类似，区别在于，bytearray不是只读的，可修改。 1234567buffer = bytearray(0x00 for x in range(10))print(type(buffer), buffer)buffer = bytearray(b'abcdefghijklmn')buffer[1] = ord('B')print(buffer)print(buffer[3:11:3]) 执行结果： 123&lt;class &#39;bytearray&#39;&gt; bytearray(b&#39;\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00&#39;)bytearray(b&#39;aBcdefghijklmn&#39;)bytearray(b&#39;dgj&#39;) ​ 上述代码及执行结果展示了bytearray的定义，切片方法。其中，ord()函数来自于英文order, 它将一个字符转换成其对应的ASCII码整数。 ​ ASCII码是一个表格，将每个字符与一个整数对应，这个整数事实上就是字符在计算机内部的实际存储值。 按位与、或、移位​ 本节是介绍性内容，初学者如果对底层细节不感兴趣，可以略过。 12345678x = 0xaaprint(\"x =\", bin(x))print(\"x &amp; 0x7f =\", bin(x &amp; 0x7f))print(\"x | 0x77 =\", bin(x | 0x77))y = 0x00ffy = y &lt;&lt; 8print(\"y =\", hex(y)) 执行结果： 1234x &#x3D; 0b10101010x &amp; 0x7f &#x3D; 0b101010x | 0x77 &#x3D; 0b11111111y &#x3D; 0xff00 ​ 上述代码及执行结果展示了按位与-&amp;、按位或-|、左移位-&lt;&lt;操作符的使用方法。这些操作符只有当你跟底层硬件打交道时才会用得到。 ​ 所谓按位与，即是把原始比特值做逻辑与运算，1看作真，0看作假，结果也用1或0表示： ​ 1 &amp; 1 = 1; 1 &amp; 0 = 0; 0 &amp; 0 = 0。 ​ 按位或即是把原始比特值做逻辑或运算。左移位&lt;&lt;操作符则是把全部比特向左移指定位数，右边补0。除此之外，还有按位取反~，按位异或^，右移位&gt;&gt;等操作符，各位等到用时再查资料即可。 序列​ 列表-list、字符串-str、元组-tuple、bytes、bytearray都可视作序列类型。共同点在于： 可以通过下标或索引访问其元素（只读类型只可获取，不得修改）； 可通过切片操作获取其子序列。 作为序列类型，上述类型的使用方法有很多相通之处。 名字绑定​ 在第4章，我们已经见识了将一个列表从一个变量赋值给另一个变量后的令人疑惑的操作结果： 12345person1 = ['10000', 'Jack Ma', 'male', 47, 'CEO']person2 = person1person2[1] = \"Tom Henry\"print(person1)print(person2) 执行结果: 12[&#39;10000&#39;, &#39;Tom Henry&#39;, &#39;male&#39;, 47, &#39;CEO&#39;][&#39;10000&#39;, &#39;Tom Henry&#39;, &#39;male&#39;, 47, &#39;CEO&#39;] ​ 看起来，似乎person2和person1指向的是同一个列表实体。因为person2被修改后，person1也跟着改变了。初学者很容易感到疑惑，本章试图从原理层面讲清楚这个重要的问题。 再看a=112345678a = 1print(\"id:\",id(a))a = 2print(\"id:\",id(a))b = aprint(\"id of a:\", id(a), \"id of b:\",id(b))a += 1print(\"id:\",id(a)) 执行结果： 1234id: 140720188347424id: 140720188347456id of a: 140720188347456 id of b: 140720188347456id: 140720188347488 ​ id()函数返回对象在Python解释器内部的编号，每一个对象都是一个唯一的id号，你可以把id号想象成该对象在内存中的地址。可以看到，a每经过一次赋值，其id号是不同的。 ​ 之前，我们是这样描述a = 1的： a是一个变量/对象，赋值操作符=把类型为整数的对象1传递给了变量/对象a，赋值之后a是一个类型为整数的变量/对象，其值为1。这种描述方法是传统习惯，目的是方便你在课程前期能够看懂，但这不是事实。 名字、对象及绑定 a = 1执行结果： - 值1是一个对象-object，它有内存地址(id号)；- a只是一个名字-name，所谓赋值，就是把这个名字绑定在相应的对象上。 同理，a = 2被执行时， 解释器会将名字a绑定在值为2的整数对象上。由于2是一个跟1不同的对象，所以id(a)会返回不同的地址。如下图： a = 2执行结果： ​ 请注意，此时，值为1的对象此时仍然存在，但没有名字与其绑定。事实上，对象内部会有专门的引用计数来表明这个对象当前与多少个名字绑定，当对象的引用计数下降到0后，Python解释器会在恰当的时候从内存中销毁这个对象，这个机制称为“垃圾回收”。 b = a执行结果： - 如图：b = a中的赋值并没有创建新对象; - 赋值操作只是简单地把名字b也绑定到名字a绑定的对象上; - 由于a,b都绑定了同一个对象，所以id(a)与 id(b)的值相同。 ​ Python的这种操作方式有其合理之处，特别是对于那些体量比较大的对象，比如列表，赋值时不创建复制品而是简单地执行名字绑定，可以快速地完成形式上的赋值。大多数情况下，这没有什么问题。如上例，虽然名字a和名字b被绑在了同一个值为2的对象上，但无论是通过名字a还是名字b取值，都可得到2；当其中一个名字，比如b被赋以不同的新值时，名字b又会被绑定到别的对象上，名字a不受影响。 ​ 同理，a += 1 等价于 a = a + 1, 通过计算后，解释器把名字a绑定在了值为3的另一个对象上，所以我们又看到了新的不同的id(a)值。 ​ 需要注意的是，Python解释器可能会出于执行速度优化的考虑，倾向于将名字尽可能绑定在系统已有的对象上，而不是创建新对象。 1234a = 3b = int(a ** 2 / 3)print(a,b)print(id(a),id(b)) 执行结果: 123 3140720185398368 140720185398368 ​ a被赋值为3, b也被赋值为计算出来的结果3，与预期的不一样，a和b并没有并绑定到两个不同的值为3的整数对象，而是被绑定到同一个值为3的整数对象。作者相信这是某种形式的解释器优化的结果，解释器试图尽可能快地执行代码。 is 和 ==12345a = 3b = 3.0print(\"a==b:\",a==b)print(\"a is b:\",a is b)print(id(a),id(b)) 执行结果： 123a&#x3D;&#x3D;b: Truea is b: False140720188347488 2675211874712 ​ 每个名字所绑定的对象都至少包括三个属性：id-就是对象的内存地址；type-类型；value-对象的值。a is b将a的id与b的id作比较，只有两者相同时才返回True，这里显然a,b没有绑定到同一个对象，所以a is b返回False；a == b将两个对象的值进行比较，3等于3.0，故返回True。在实践中，为了避免不必要的麻烦，建议尽量使用==而不是is。 只读数据类型​ 下表列出了我们已经讨论过的全部数据类型： 只读数据类型 可修改数据类型 整数-int, 浮点数-float，字符串str，布尔-bool, 二进制字节流-bytes,元组-tuple 列表-list, 二进制字节数组-bytearray ​ 对于只读类型，编程者完全可以忽略名字绑定这件事，任何赋值操作的最终结果都会跟你的期望一致。 123456789values = (3,2,1)valuesCopy = valuesvaluesCopy = (1,2,3)print(values, \"-\", valuesCopy)string = \"string\"stringCopy = stringstringCopy = \"new string\"print(string, \"-\", stringCopy) 执行结果： 12(3, 2, 1) - (1, 2, 3)string - new string ​ 可以看到，上述代码中，valuesCopy与values, stringCopy与string都曾经同时绑定到同一个只读类型对象，由于对象是只读的，所以对象无法修改，任何对valuesCopy, stringCopy的赋值都将创建一个新对象，values，string名字绑定的原有对象不受影响。 可修改数据类型​ 终于到了可以解决疑惑的时间了。列表-list, 二进制字节数组-bytearray属于可修改数据类型，当列表、bytearray被赋值给多个名字时，可能会导致意料之外的结果，需要十分小心。 12345person1 = ['10000', 'Jack Ma', 'male', 47, 'CEO']person2 = person1person2[1] = \"Tom Henry\"print(person1)print(person2) 执行结果: 12[&#39;10000&#39;, &#39;Tom Henry&#39;, &#39;male&#39;, 47, &#39;CEO&#39;][&#39;10000&#39;, &#39;Tom Henry&#39;, &#39;male&#39;, 47, &#39;CEO&#39;] ​ 请注意，第2行person2 = person1之后，两个名字事实上绑定到了同一个列表对象。由于列表是可修改类型，对person2的修改事实上是对person1和person2共同绑定的同一个对象的修改。所以，修改完成后，person1和person2打印出来的值相同。事实上，如果打印一下id(person1)和id(person2)，结果肯定是一样的。 ​ 大多数情况下，两个名字绑定同一个列表对象并没有什么不好，比如，当一个列表作为函数实参传递给形参时，这种名字绑定的方法可以非常快地完成形式上的参数传递，执行效率非常高。但如果你在函数内部修改了列表的元素值，外面那个名字所绑定的列表也会跟着改变（事实上就是同一个），这可能不是你所期望的。为了避免这种情况的发生，可以借助于列表的copy()成员函数制造一个完全独立的副本，也可以借助列表的切片,比如 person1[:]来产生一个全新的副本。还可以借助于copy模块的copy()及deepcopy()函数来完成对象复制。下面的代码展示了这些方法在bytearray和list上的应用。 12345678910111213import copychars = bytearray(b'abcdefghijklmn')charsCopy = chars.copy()charsCopy2 = chars[:]print(id(chars),\"-\",id(charsCopy),\"-\",id(charsCopy2))numbers = [0,1,2,3,4,5,6,7]numbersCopy = numbers.copy()numbersCopy2 = numbers[:]numbersCopy3 = copy.copy(numbers)numbersCopy4 = copy.deepcopy(numbers)print(id(numbers),\"-\",id(numbersCopy),\"-\",id(numbersCopy2), \"-\",id(numbersCopy3),\"-\",id(numbersCopy4)) 执行结果： 122090502934232 - 2090502931208 - 20905029509602090503871624 - 2090503792584 - 2090503872008 - 2090503871560 - 2090503871880 ​ 可以看到，上述名字对应对象的id值均不相同，是相互独立的对象和名字。 ​ 当列表有嵌套时，copy()和deepcopy()是有差异的。copy()只会复制列表本身，复制出来的列表(设名为b)与原列表(设名为a)的相同元素位仍可能绑定在一个相同的子列表对象上，此时，修改a的这个子列表事实上就是修改b的同一个子列表。deepcopy()会将列表及其嵌套列表完整复制，以避免上述情况。 123456a = [1,2,3,[3,2,1]]b = a.copy()print(id(a),id(b))print(id(a[3]),id(b[3]))b[3][2] = 99print(a,b) 执行结果： 1231989546107528 19895466019281989546107464 1989546107464[1, 2, 3, [3, 2, 99]] [1, 2, 3, [3, 2, 99]] ​ 可以看出，通过浅拷贝copy()后，a,b绑定的是两个独立的列表对象。但由于列表有子列表[3,2,1]，两个列表对象的下标3位置仍然绑定了同一个子列表对象，这从id(a[3])和id(b[3])的值可以看出来。些时，修改b[3]的元素值事实上就是在修改a[3]的对应元素值。借助于b = copy.deepcopy(a)，不光列表会被复制，子列表以及子列表的子列表也会被复制，这样b与a之间不再有任何联系。 1234567import copya = [1,2,3,[3,2,1]]b = copy.deepcopy(a)print(id(a),id(b))print(id(a[3]),id(b[3]))b[3][2] = 99print(a,b) 执行结果： 1231723423500488 17234234992721723423628168 1723423628488[1, 2, 3, [3, 2, 1]] [1, 2, 3, [3, 2, 99]] ​ 列表的任意元素位置也可以看作是一个名字，它同具体的对象相绑定。 ​ 虽然我们已经了解了名字、对象、绑定这些背后的秘密，但本书的后续部分，我们有时仍将沿用变量、赋值这些术语，因为习惯。","categories":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/tags/Python/"},{"name":"名字绑定","slug":"名字绑定","permalink":"http://codelearn.club/tags/%E5%90%8D%E5%AD%97%E7%BB%91%E5%AE%9A/"}]},{"title":"使用numpy进行9宫格图像拼接","slug":"imagesconcatenate","date":"2019-01-20T03:35:04.000Z","updated":"2020-03-03T04:59:16.308Z","comments":true,"path":"2019/01/imagesconcatenate/","link":"","permalink":"http://codelearn.club/2019/01/imagesconcatenate/","excerpt":"本节内容要用到opencv-python模块，请先行安装。本例程中使用到的图片保存在pictures子目录下。本例的任务是要将9张JPG格式图片按三行三列拼接成下述九宫格。","text":"本节内容要用到opencv-python模块，请先行安装。本例程中使用到的图片保存在pictures子目录下。本例的任务是要将9张JPG格式图片按三行三列拼接成下述九宫格。 版权声明 本文可以在互联网上自由转载，但必须：注明出处(作者：海洋饼干叔叔)并包含指向本页面的链接。 本文不可以以纸质出版为目的进行改编、摘抄。 本文配套在线视频： https://www.bilibili.com/video/av34409478/?p=49 ### 微实践：九宫格图像拼接 本节内容要用到opencv-python模块，请先行安装。本例程中使用到的图片保存在pictures子目录下。本例的任务是要将9张JPG格式图片按三行三列拼接成下述九宫格。 12345678910111213#pictures9.pyimport globimport numpy as npfrom cv2 import imread,imwrite #cv2来自OpenCV-Python扩展库imgs,heights,widths = [],[],[]for f in glob.glob(\"pictures/*.jpg\"): img = imread(f,-1) print(\"original:\",img.shape) h,w = img.shape[:2] heights.append(h) widths.append(w) imgs.append(img) 控制台输出: 12345original: (960, 1280, 3)...original: (793, 1280, 3)...original: (960, 1280, 3) glob.glob(“pictures/*.jpg”)返回一个序列，该序列包括当前目录之pictures子目录下的所有扩展名为jpg的图片文件的文件名(含路径)。读者可以在上述循环中加上print(f)把这些文件名打出来看看。 imread()函数来自opencv-python扩展库，它读取一个图片，并返回一个多维数组。我们打印了这些多维数组的形状，典型如(960,1280,3)：它表示对应图片高960个像素，宽1280个像素，每个像素由3个值构成，分别表示该像素红、绿、蓝三个通道的颜色值。请读者注意，本例中的9张图片的高度值并不相等。 img.shape[:2]取出了图像/多维数组的高度和宽度，分别赋值给h和w。所有的图片高、宽均存入heights、widths列表备用。所有的图片/多维数组均存入imgs列表备用。 显然，(960,1280)的图片尺寸对于九宫格拼接而言太大了，需要分别提取缩略图。 123456789101112#pictures9.py#制作缩略图，纵横向每3个像素抽一个minHeight = min(heights)minWidth = min(widths)for i,x in enumerate(imgs): imgs[i] = x[:minHeight:3,:minWidth:3,:] print(\"thumbnail:\",imgs[i].shape)#横向沿轴1拼接img = np.concatenate(imgs,1)print(\"concatenated by axis1:\",img.shape)imwrite(\"concatenated_1.jpg\",img) 控制台输出： 1234thumbnail: (265, 427, 3)...thumbnail: (265, 427, 3)concatenated by axis1: (265, 3843, 3) 我们首先获得了全部图像的最小高度 - min(heights)和最小宽度 - min(widths)。然后，遍历并逐一使用多维数组的切片下标语法提取缩略图：横纵向都从每3个像素中抽1个像素。根据打印出来的值，我们可以看到，所有的缩略图都是265 x 427个像素。 接下来，我们使用np.concatenate()函数将imgs列表中的9张图沿1轴拼接（横向拼接）至img。根据打印的结果，横向拼接后的图片尺寸为265 x 3843。imwrite()则将img存至文件”concatenated_1.jpg”。读者可以在项目目录中找到这个照片，如下： 下述代码及其执行结果可以帮助读者理解concatenate()函数的作用：可以看到，对于二维数组而言，沿0轴拼接相当于纵向延长数组，沿1轴拼接则相当于横向延长数组。 123456789101112#con.pyimport numpy as npa = np.array([[1,2],[3,4]])b = np.array([[11,22],[33,44]])print(\"a=\\n\",a)print(\"b=\\n\",b)c = np.concatenate([a,b],0) #沿0轴拼接，纵向延长print(\"np.concatenate([a,b],0)=\\n\",c)c = np.concatenate([a,b],1) #沿1轴拼接，横向延长print(\"np.concatenate([a,b],1)=\\n\",c) 执行结果： 1234567891011121314a&#x3D; [[1 2] [3 4]]b&#x3D; [[11 22] [33 44]]np.concatenate([a,b],0)&#x3D; [[ 1 2] [ 3 4] [11 22] [33 44]]np.concatenate([a,b],1)&#x3D; [[ 1 2 11 22] [ 3 4 33 44]] 借助于concatenate()函数，我们可以先将图片0-2横向拼接，再将图片3-5横向拼接，接着再将图片6-8横向拼接。最后再将拼接结果纵向拼接，即得3x3的九宫格： 12345678#pictures9.py#方法1img0 = np.concatenate(imgs[:3],1) #沿1轴横向拼接img1 = np.concatenate(imgs[3:6],1)img2 = np.concatenate(imgs[6:],1)img9 = np.concatenate([img0,img1,img2],0) #沿0轴纵向拼接print(\"3x3_0, shape:\",img9.shape)imwrite(\"3x3_0.jpg\",img9) 控制台输出： 13x3_0, shape: (795, 1281, 3) 上述3x3_0.jpg应该与本例开始处的图片相同，该文件也存入了当前项目目录，读者自行查证。除了上面这个方法外，下面这个方法也可以达到相同的效果，但真的很难理解。在下述代码中，img1.swapaxes(1,2)将img1的1轴与2轴进行了交换。 123456#方法2img = np.concatenate(imgs,0) #将9图沿0轴纵向拼img1 = img.reshape(3,3,265,427,3) #改变形状至5维数组img9 = img1.swapaxes(1,2).reshape(795,1281,3) #1轴和2轴交换，再改变形状print(\"3x3_1, shape:\",img9.shape)imwrite(\"3x3_1.jpg\",img9) 控制台输出： 13x3_1, shape: (795, 1281, 3) 读者可以查证3x3_1.jpg的最终效果。 读者可以试着执行下述代码来观察轴交换的效果： 12345678910#swapaxes.pyimport numpy as npa = np.array([[1,2],[3,4]])print(\"a=\\n\",a)print(\"a.swapaxes(0,1):\\n\",a.swapaxes(0,1))b = np.array([[1,2,3,4],[5,6,7,8]])print(\"b=\\n\",b)print(\"b.reshape(2,2,2)=\\n\",b.reshape(2,2,2))print(\"b.reshape(2,2,2).swapaxes(1,2))=\\n\",b.reshape(2,2,2).swapaxes(1,2)) ​ 与多维数组操作有关的函数列表如下： 函数名 作用 函数名 作用 concatenate() 拼接多个数组 vstack/hstack() 沿0/1轴拼接数组 column_stack() 按列连接多个一维数组 split,array_split() 将数组分为多段 transpose() 重设轴的顺序 swapaxes() 交换两个轴的顺序","categories":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/categories/Python/"},{"name":"图像处理","slug":"Python/图像处理","permalink":"http://codelearn.club/categories/Python/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/tags/Python/"},{"name":"numpy","slug":"numpy","permalink":"http://codelearn.club/tags/numpy/"},{"name":"图像处理","slug":"图像处理","permalink":"http://codelearn.club/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"},{"name":"OpenCV","slug":"OpenCV","permalink":"http://codelearn.club/tags/OpenCV/"}]},{"title":"Python, Cython绘制美妙绝伦的Mandelbrot集, 曼德博集分形图案","slug":"python-mandelbrot","date":"2019-01-19T15:48:13.000Z","updated":"2020-03-03T05:15:03.373Z","comments":true,"path":"2019/01/python-mandelbrot/","link":"","permalink":"http://codelearn.club/2019/01/python-mandelbrot/","excerpt":"上世纪60-70年代，美籍数学家曼德博 - Benoit B. Mandelbrot几乎单枪匹马的创立了一个新的数学分支，即分形几何学 - fractal geometry。这个新的数学分支有助于人类探索物理现象背后的数学规律，分形混沌之旋风，横扫数学、理化、生物、大气、海洋以至社会学科，在音乐、美术领域也产生了一定的影响。","text":"上世纪60-70年代，美籍数学家曼德博 - Benoit B. Mandelbrot几乎单枪匹马的创立了一个新的数学分支，即分形几何学 - fractal geometry。这个新的数学分支有助于人类探索物理现象背后的数学规律，分形混沌之旋风，横扫数学、理化、生物、大气、海洋以至社会学科，在音乐、美术领域也产生了一定的影响。 分形艺术 - fractal art不同于普通的电脑绘画，它利用分形几何学和计算机强大的运算能力，将数学公式反复迭代运算，再结合作者的审美及艺术性的塑造，从而将抽象神秘的数学公式变成一幅幅精美绝伦的艺术画作。 版权声明 本文可以在互联网上自由转载，但必须：注明出处(作者：海洋饼干叔叔)并包含指向本页面的链接。 本文不可以以纸质出版为目的进行改编、摘抄。 本文配套在线视频： https://www.bilibili.com/video/av34409478/?p=45 1. Mandelbrot集1.1 定义​ 说明：阅读Mandelbrot集相关内容需要一点复数及复平面的知识，缺乏相关背景知识的读者可以略过，不影响后续内容的理解。 ​ Mandelbrot(曼德布洛特)集是在复平面上构成分形图案的点的集合。它可以用下述复二次多项式定义：$$f_{c}(z)=z^{2}+c$$​ 这里的c = x + yi是一个复数，如果把实部x和虚部y视为复平面上的横纵坐标的话，那么c对应该复平面上的一个点。从z=0开始，反复应用上述二次多项式进行迭代计算，z值将不断变化，其或者延伸至无限大，或者停留在有限半径的圆内部。如果是后者，我们称参数c导致了不发散的迭代z序列，此时，c点属于Mandelbrot集合，否则不属于。 1.2 计算​ 计算机显然没有办法进行无穷尽的计算才确认c所导致的迭代z值是否发散，所以我们简单地计算c点的逃逸时间 - 也就是经过多少轮迭代计算，z值的模超过2。在绘图过程中，该逃逸时间将作为c点在平面上的颜色。 12345678def getEscapeTime(c): \"计算参数c的逃逸时间，该逃逸时间将用作点的颜色\" z = 0 for i in range(100): if abs(z) &gt; 2: return i z = z*z + c return i ​ 如代码所示，abs(z)用于计算复数的模，在该代码中，逃逸时间最大为100-1 = 99。同时，应注意到，Python原生支持复数运算，z*z + c就是在复数之间的运算，其代码与普通实数间的运算没有什么不同。 ​ 接下来，就可以计算Mandelbrot集合了。广义的Mandelbrot集合是个无穷大的复平面，显然，我们只可能画其中一小块。下述代码计算以(xCenter,yCenter)为中心点，semiWidth为半宽的正方形区域内的Mandelbrot集。这个正方形区域x坐标范围为xCenter±semiWidth，y坐标范围为yCenter±semiWidth。考虑到计算机只能计算离散点，所以该正方形区域将被分成N*N个点进行计算。当N=600时，下述函数的结果矩阵就是一个600x600的图像，矩形元素值代表该点的颜色。 12345678import numpy as npdef computeMandelbrot(xCenter,yCenter,semiWidth,N): xFrom,xTo,yFrom,yTo = xCenter-semiWidth,xCenter+semiWidth,\\ yCenter-semiWidth,yCenter+semiWidth y,x = np.ogrid[yFrom:yTo:N*1j,xFrom:xTo:N*1j] c = x + y*1j print(\"c.shape:\",c.shape,\"x.shape:\",x.shape,\"y.shape:\",y.shape) return np.frompyfunc(getEscapeTime,1,1)(c).astype(np.float) ​ 上述代码的理解并不容易，需要先从多维数据np.ndarray的广播运算开始。对于复杂的问题，做一点小规模的模拟运算可以帮助理解。 123456import numpy as npy,x = np.ogrid[1:4:4j,1:3:3j]print(\"y=\")print(y)print(\"x=\",x)print(\"shape of y:\",y.shape,\"shape of x:\",x.shape) 执行如果如下： 1234567y&#x3D;[[1.] [2.] [3.] [4.]]x&#x3D; [[1. 2. 3.]]shape of y: (4, 1) shape of x: (1, 3) ​ np.ogrid是一个特殊对象，它使用切片元组作为下标，专门用于生成用来广播的数组。1:4:4j有点类似于np.linspace(1,4,4)，用于生成从1到4（含4）的有4个元素的等差数列，这里的j并不表示复数，只是一种表达形式。可以看到，ogrid生成的y是一个4行1列的二维数组，x则是一个1行3列的二维数组。其值见上。 12z = y*1jprint(\"z = y*1j =\",z) 执行结果： 1234z &#x3D; y*1j &#x3D; [[0.+1.j] [0.+2.j] [0.+3.j] [0.+4.j]] ​ y*1j是把复数1j同y里的每一个元素相乘，并返回相同形状（维度)的数组。由于numpy模块并不是Python的原生内容，所以这里的*号并不是普通意义的Python乘法，它事实上是一个被重载的操作符函数，这个函数位于numpy模块，是用C语言书写的。可见，y*1j的结果元素的实部全是0，虚部则等于原元素值乘以1j。 ​ 再来看看x + z会得到什么，注意这里的z就是y*1j的结果。 123c = x + zprint(c)print(\"shape of c:\",c.shape) 执行结果： 12345[[1.+1.j 2.+1.j 3.+1.j] [1.+2.j 2.+2.j 3.+2.j] [1.+3.j 2.+3.j 3.+3.j] [1.+4.j 2.+4.j 3.+4.j]]shape of c: (4, 3) ​ x是一个1行3列的二维数组，z = y*1j是一个4行1列的二维数组。两者相加事实上也是实际的被重载的numpy模块内的操作符函数，该函数将两个数组的对应元素相加。问题来了，两个数组的形状/维度不同，如何确定元素间的对应性呢？ numpy进行了所谓“广播”运算，结果数组c将取x,z的各轴的最大值，其结果维度为(4,3)也就是4行3列。对于c的各个元素，比如c[3][2]为例，其值应等于x[3][2] + z[3][2]，由于x[3][2]并不存在，广播规则取x[0][2] = 3代替；同样地，z[3][2]也不存在，广播规则取z[3][0] = 0. + 4.j代替；所以，c[3][2] = 3 + 0. + 4.j = 3. + 4.j。请注意，结果元素的实部来自于x数组，虚部来自于z数组，也就是y*1j的结果数组。 ​ 这里所述的“广播规则”是指当输入数组的某个轴的长度为1时，取值时均取该轴的下标0值。比如x[3][2]，由于x数组的0轴长度为1，故x[3][2]的0轴下标改取0，即x[0][2]。 ​ 请读者再次观察c数组内的复数，把它看作一幅图像，从上向下，虚部的值在等差递增；从左向右，实部的值在等差递增。 1234xFrom,xTo,yFrom,yTo = xCenter-semiWidth,xCenter+semiWidth,\\ yCenter-semiWidth,yCenter+semiWidthy,x = np.ogrid[yFrom:yTo:N*1j,xFrom:xTo:N*1j]c = x + y*1j ​ 现在这段程序容易理解了，它使用与上述解读过程相同的方法把以(xCenter,yCenter)为中心点，semiWidth为半径的复平面正方形区域等分成了N行N列，多维数组c的维度即为(N,N)。c中的元素为复数，其实部在xFrom至xTo之间等差横向变化，其虚部在yFrom至yTo间等差纵向变化。 ​ 再来看函数最后一行代码： 1return np.frompyfunc(getEscapeTime,1,1)(c).astype(np.float) ​ getEscapeTime(c)是之前已经定义好的一个Python语言函数，它接受一个复数参数c并计算返回这个复数参数对应的逃逸时间。np.frompyfunc()函数将二维数组c中的复数元素逐一交给getEscapeTime()进行计算，得到一个与c形状相同的结果数组。c里有多少个元素，getEscapeTime()函数就会执行多少次。执行这个结果数组的astype函数将结果数组中的元素全部转换成np.float类型。上述参数1,1表示getEscapeTime()函数接受1个参数，返回1个结果元素。 ​ 综上，computeMandelbrot()函数最后返回了一个N行N列的二维数组，数组元素为np.float类型，表明了该点的逃逸时间；而元素所在的行列编号则间接表示了元素点在结果图像/复平面中的坐标。 1.3 绘图​ 我们使用matplotlib绘制了Mandelbrot集的局部。左图的中心点c = 0.27322626 + 0.595153338j, 正方形半宽为0.2；右图的中心点与左图相同，半宽为0.23，相当于把左图放大了25倍。 ​ 接下来分析代码。 123456789101112131415from matplotlib import cm...def drawMandelbrot(ax,xCenter,yCenter,semiWidth,N,cmap): \"(xCenter,yCenter)-中心点，semiWidth-矩形半宽，N*N像素.\" ax.set_axis_off() ds = computeMandelbrot(xCenter,yCenter,semiWidth,N) ax.imshow(ds,cmap=cmap) #在子图-ax上绘制图像，ds是计算而得的二维数组，其元素为逃逸时间def refresh(): c = cm.get_cmap(para.cmaps[para.idxColorMap%len(para.cmaps)]) drawMandelbrot(para.ax0, para.x, para.y, semiWidth=0.2, N=600,cmap=c) drawMandelbrot(para.ax1, para.x, para.y, semiWidth=0.2 ** 3, N=600,cmap=c) para.fig.canvas.draw() #要求图-Fig重绘 ​ pyplot中的图称为figure，图内包含一个或者多个子图-axes。drawMandelbrot()函数负责在子图上计算并画出Mandelbrot集图像。ax.set_axis_off()隐藏了子图的坐标，然后计算得到N*N像素的结果图像数组ds，接着使用ax.imshow()函数将ds在子图上画出来。该函数将ds二维数据视为一幅二维图像，ds内的每一个元素则对应图像中的一个像素点。imshow()函数内的cmap函数对应一个颜色映射对象，该对象负责把元素的值（就是复数c的逃逸时间）转换成对应的颜色。 ​ refresh()函数则两次调用drawMandelbrot()函数画出左子图-ax0和右子图-ax1。注意，两次绘图的中心点坐标是一样的，区别是半宽不同，一个是0.2，一个是0.23。matplotlib中的cm负责管理颜色映射对象，通过cm.get_cmap()函数可以通过字符串类型的名称比如’rainbow’获得对应的颜色映射对象。para.fig.canvas.draw()函数则通知图/fig重绘。这里，我们看到一个名为para的对象，下述代码做出了解释。 12345678910111213141516171819202122232425262728from matplotlib import pyplot as plt...#操作者通过按上下箭头改变图像描绘颜色def on_key_release(event): #按键松开勾子函数 if event.key == 'up': para.idxColorMap+=1 elif event.key == 'down': para.idxColorMap-=1 else: return refresh()class Para: #一个仅有名字的Para类用于存储全局参数 passpara = Para()para.x, para.y = 0.27322626, 0.595153338para.idxColorMap = 0para.cmaps = ['flag', 'prism', 'ocean', 'gist_earth', 'terrain', 'gist_stern', 'gnuplot', 'gnuplot2', 'CMRmap', 'cubehelix', 'brg','gist_rainbow', 'rainbow', 'jet', 'nipy_spectral', 'gist_ncar']para.fig = plt.figure(figsize=(12,6),dpi=100)para.fig.canvas.mpl_connect('key_release_event',on_key_release)plt.subplots_adjust(0,0,1,1,0.0,0)para.ax0 = plt.subplot(121)para.ax1 = plt.subplot(122)refresh()plt.show() ​ 考虑到阅读本章的读者可能并不具备面向对象程序设计的知识背景，所以本章尽量避免自定义类。但作者又非常不喜欢数量过多的全局变量。作者定义了一个仅有名字的Para类并实例化了一个para对象，其中将存储那里跨函数被使用的“全局”变量。这样，理论上，全部变量只有一个，那就是para。 ​ plt.figure()函数创建了一个长12英寸，宽6英寸的图-figure，注意dpi/每英寸点数被设定为100，这意味着图长1200像素，宽600像素。 ​ para.fig.canvas.mpl_connect()函数将按键弹起事件与on_key_release()函数相关联，即图-figure处于活动状态时，操作者按下一个键并松开时，on_key_release(event)函数将被执行，event参数包括了事件的相关信息：比如事件的类型，哪个键被松开等等。这个on_key_release()函数与特定事件相绑定，俗称“勾子函数” - hook function。 ​ plt.subplots_adjust()函数调整了子图间的间距和边距，使得整个显示窗口被充分利用。 ​ plt.subplot(121)在当前图-figure对象内创建了一个子图-axes，并存于para.ax0。121参数被该函数以非常特别的方式处理，它表示将当前图的可见区域分成1行2列，在其中1号位置创建一个子图，即结果中的左子图。同理，plt.subplot(122)将当前图的可见区域分成1行2列，在其中2号位置创建一个子图，即结果中的右子图。 ​ refresh()函数将计算并画出两个子图。plt.show()则把窗口显示出来。 ​ 接下来，我们研究一下勾子函数on_key_release(event)。这个函数使得操作者按上下箭头可以改变当前图像颜色并重绘。para.cmaps列表存储了一系列可用的映射对象的名称，para.idxColorMap则记录了当前使用的映射对象在para.cmaps列表中的下标。on_key_release(event)函数判断event对应的按键类型，如果是up，para.idxColorMap+1，如果是down, para.idxColorMap-1。on_key_release()函数通过调用refresh()函数再实现图的重绘，在refresh函数内部，para.idxColorMap以len(para.cmaps)取模后再使用。这是因为，para.idxColorMap的加减没有进行越界检查，para.idxColorMap可能为负数，也可能为超过para.cmaps长度的正数，取模可以保证获得合法的下标。 ​ 需要提醒读者的是，一幅子图有600*600 = 36万个像素，两幅子图有72万个像素。每个像素的计算都会调用一次getEscapeTime()函数，而这个函数是Python语言写的，并且里面要进行不超过100次的循环运算，执行速度很慢。所以读者运行出界面后，按上下箭头时不要太心急，按一下后要等刷新结束再按下一次。 2. Cython加速Mandelbrot集​ 用纯Python语言写就的Mandelbrot集绘图程序速度太慢了！ 但Python是所谓的胶水语言，可以很方便地通过C或者其它语言来书写扩展库，numpy, scipy, matploblib都是这些扩展库的杰出代表。 ​ 至少有两个途径可以加速Mandelbrot集的计算速度。方法1是直接用C语言书写计算逃逸时间的函数，然后使用mingw、g++或者Visual C++编译器将其编译成目标模块，然后在Python语言里调用。这非常麻烦，因为函数的参数需要手工解析，还需要记忆和使用大量的Python API。 ​ 方法2则是Cython。Cython在语法上基本与Python相同，同时又允许直接定义和调用C语言函数、定义变量类型等功能。Cython的编译器会把Cython的源程序编译成C语言程序，再经由C语言编译器编译成Python模块。由于Python解释器本身也是由C语言写就，并经由C语言编译器编译的，所以Cython里可以很方便地访问Python类型对象。 2.1 环境准备​ 世界发展得太快，当读者阅读本书时，下述信息或许已经过时。 ​ 作者使用的是Windows 10环境下的64位的Python3.7解释器， 所以作者安装了微软的Visual Studio社区版的”使用C++的桌面开发”部分，其中包括了VC 2017 version 15.9 v14.16以及相关的Windows SDK。该软件可以从 https://visualstudio.microsoft.com 获得。请注意，Visual Studio是一个非常宠大的IDE软件，除上述必要部分之外的请不要选择，否则非常耗时而且占据硬盘空间。 ​ 如果读者使用的是Linux, 则系统自带的gcc编译通常足够使用。Linux下Cython代码的编译过程与下述过程相当，但细节或有区别。 ​ 读者还需要安装Cython模块，在Windows命令行或者Linux终端中运行pip install cython即可。 2.2 重写逃逸时间计算函数​ 在PyCharm中新建一个文件(New-&gt;File)，命名为MandelbrotComp.pyx。其内为Cython代码： 123456789def getEscapeTime(complex c): &quot;计算参数c的逃逸时间，该逃逸速度将用作点的颜色&quot; cdef complex z &#x3D; 0 cdef int i for i in range(255): if z.real * z.real + z.imag*z.imag &gt; 4: return i z &#x3D; z*z + c return i ​ 可以看到，上述代码与之前纯Python写的getEscapeTime()函数主要有如下的不同： ​ 首先，所有的变量/对象都有类型声明，大部分通过cdef关键字定义。c,z的类型为complex，i的类型为int。强类型是C/C++的特点，也是C/C++可以编译出高效机器码的必要条件。 ​ 第二，我们没有再使用abs来计算复数z的模，这可能有两个原因：1). 原生C语言没有用于复数求模的abs()函数，沿用abs()函数很可能会导致该模块再次内部调用Python的abs()函数；2). 复数的求模运算需要求平方根，而平方根的求解运算代价较高。而且，平方根的求解在此处是不必要的，我们直接求z的实部和虚部的平方之和，再比较其是否大于4事实上等价于比较z的模是否大于2。 2.3 编译为扩展模块​ 按照Cython文档的建议，我们准备了一个setup.py文件，其内容如下： 12345from distutils.core import setupfrom Cython.Build import cythonizesetup(name='Mandelbrot Computation', ext_modules=cythonize(\"MandelbrotComp.pyx\")) 请注意，setup.py与MandelbrotComp.pyx以及预期使用该扩展块的Mandelbrot绘图程序均在同一目录下。然后通过Windows开始菜单进入”适用于VS 2017的x64本机工具命令提示”，通过cd命令切换至setup.py及MandelbrotComp.pyx所在目录。再执行python setup.py build_ext –inplace命令。 ​ 如下图所示，需要说明的是，下图事实上是个黑黑的终端界面，cd等命令可以追溯到40年前的DOS操作系统，也就是Windows操作系统的前身。该命令提示界面与普通Windows命令行的主要区别在于通过执行vcvarsall.bat批处理命令， 该界面内对环境变量Path进行了临时设置，以确保VC编译器-cl.exe，以及相关的C语言头文件，库文件可以被找到。读者不要在普通的Windows命令行下做下述工作，setup.py会报告找不到编译器或者C语言头文件。 1234567891011121314适用于VS2017的x64本机工具命令提示************************************************************************ Visual Studio 2017 Developer Command Prompt v15.9.4** Copyright (c) 2017 Microsoft Corporation**********************************************************************[vcvarsall.bat] Environment initialized for: &#39;x64&#39;C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community&gt;d:D:\\&gt;cd PythonD:\\Python&gt;cd MathBeautyD:\\Python\\MathBeauty&gt;python setup.py build_ext --inplace ​ 一切顺利的话，上述命令将报告“已完成代码的生成”。此时，可以在PyCharm里看到代码目录下多出来两个文件，其中一个名为MandelbrotComp.c。这是由Cython编译MandelbrotComp.pyx生成的C语言程序，作者抄出来一个小片段： 12345678910111213for (__pyx_t_1 = 0; __pyx_t_1 &lt; 0x64; __pyx_t_1+=1) &#123; __pyx_v_i = __pyx_t_1; __pyx_t_2 = ((((__Pyx_CREAL(__pyx_v_z) * __Pyx_CREAL(__pyx_v_z)) + (__Pyx_CIMAG(__pyx_v_z) * __Pyx_CIMAG(__pyx_v_z))) &gt; 4.0) != 0); if (__pyx_t_2) &#123; __Pyx_XDECREF(__pyx_r); __pyx_t_3 = __Pyx_PyInt_From_int(__pyx_v_i); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 7, __pyx_L1_error) __Pyx_GOTREF(__pyx_t_3); __pyx_r = __pyx_t_3; __pyx_t_3 = 0; goto __pyx_L0; &#125; __pyx_v_z = __Pyx_c_sum_double(__Pyx_c_prod_double(__pyx_v_z, __pyx_v_z), __pyx_v_c);&#125; ​ 由于是机器“写”出来的C代码，特别难理解。作者找到了那个从0到100(不含100)的循环，0x64是十六进制，它就是十进制的100。 ​ 另外一个生成出来的文件名为MandelbrotComp.cp37-win_amd64.pyd。读者的Python版本或者操作系统如果与作者的不同，该名称或有差异。这个文件就是编译好的Python扩展模块。 2.4 调用扩展模块123456789from MandelbrotComp import getEscapeTimedef computeMandelbrot(xCenter,yCenter,semiWidth,N): xFrom,xTo,yFrom,yTo = xCenter-semiWidth,xCenter+semiWidth,\\ yCenter-semiWidth,yCenter+semiWidth y,x = np.ogrid[yFrom:yTo:N*1j,xFrom:xTo:N*1j] c = x + y*1j print(\"c.shape:\",c.shape,\"x.shape:\",x.shape,\"y.shape:\",y.shape) return np.frompyfunc(getEscapeTime,1,1)(c).astype(np.float) ​ 上述pyd文件与绘图代码在同一目录下。使用该扩展模块与使用其它模块没有什么不同。from MandelbrotComp import getEscapeTime导入了该模块并引用了函数名。np.frompyfunc()则函数则直接使用该函数对象。此时，当numpy的C程序将c二维数组中的元素逐一交给getEscapeTime()函数计算时，该函数由于是C语言编写，其执行速度有了质的提升。读者可以运行随书代码中的InteractiveMandelbrot.py，体会一下速度变化。 ​ 需要说明的是，如果读者使用的不是Windows，那么InteractiveMandelbrot.py无法直接运行。C语言的编译结果与硬件平台(Intel x86或者ARM体系结构)、操作系统等有关。在Windows下编译的机器代码是无法在Linux下直接运行的。读者需要重新编译MandelbrotComp.pyx文件为扩展模块。 2.5 交互Mandelbrot绘图​ 作者随书提供了一个名为InteractiveMandelbrot.py的文件，该绘图程序提供了交互功能。操作者除了可以使用上下箭头来改变绘图颜色之外，还可以使用鼠标的左右键来放大/缩小图像。按下Esc键，则图像还原。 123para.semiWidth &#x3D; 1.5para.figWidth,para.figHeight &#x3D; 700,700para.fig.canvas.mpl_connect(&#39;button_release_event&#39;,on_button_release) ​ 为了实现上述功能，作者在para对象增加了figWidth, figHeight以表示绘图窗口的像素宽度和高度。para.semiWidth则表明当前的绘图半宽。当该绘图半宽变小，则相当于图像被放大。 ​ 当鼠标按键被松开时，on_button_release()勾子函数被调用。 12345678def on_button_release(event): para.x = (para.x - para.semiWidth) + 2*para.semiWidth*event.xdata/para.figWidth para.y = (para.y - para.semiWidth) + 2*para.semiWidth*event.ydata/para.figHeight if event.button == 1: para.semiWidth /= 3.0 elif event.button == 3: para.semiWidth *= 3.0 refresh() ​ 该函数首先借助于para.figWidth, figHeight, 鼠标点击坐标event.xdata, event.ydata等信息重新计算了新的绘图中心点para.x, para.y。 ​ 如果是鼠标左键弹起(event.button==1)，则减少绘图半宽-para.semiWidth，放大图像。否则增大绘图半宽，缩小图像。refresh()函数则负责重绘，绘图中心点以及半宽从para.x, para.y, para.semiWidth取值。 1234567891011def on_key_release(event): if event.key == 'up': para.idxColorMap+=1 elif event.key == 'down': para.idxColorMap-=1 elif event.key == 'escape': para.x, para.y = -0.5, 0.0 para.semiWidth = 1.5 else: return refresh() ​ 在on_key_release()勾子函数内，’escape’键弹起时，恢复para.x, para.y, para.semiWidth的初值并重绘，图像还原成初始状态。 ​ 下面是中心点为(-0.5, 0.0)，半宽为1.5的“全局”图像（图1）以及不同轮次放大的局部图像。","categories":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/categories/Python/"},{"name":"数学之美","slug":"Python/数学之美","permalink":"http://codelearn.club/categories/Python/%E6%95%B0%E5%AD%A6%E4%B9%8B%E7%BE%8E/"},{"name":"分形","slug":"Python/分形","permalink":"http://codelearn.club/categories/Python/%E5%88%86%E5%BD%A2/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/tags/Python/"},{"name":"Mandelbrot","slug":"Mandelbrot","permalink":"http://codelearn.club/tags/Mandelbrot/"},{"name":"分形数学","slug":"分形数学","permalink":"http://codelearn.club/tags/%E5%88%86%E5%BD%A2%E6%95%B0%E5%AD%A6/"},{"name":"曼德博集","slug":"曼德博集","permalink":"http://codelearn.club/tags/%E6%9B%BC%E5%BE%B7%E5%8D%9A%E9%9B%86/"},{"name":"Cython","slug":"Cython","permalink":"http://codelearn.club/tags/Cython/"}]},{"title":"实践 - 使用Python画一棵递归分形树","slug":"python-buildtree","date":"2019-01-19T12:48:13.000Z","updated":"2020-03-03T05:01:04.296Z","comments":true,"path":"2019/01/python-buildtree/","link":"","permalink":"http://codelearn.club/2019/01/python-buildtree/","excerpt":"本实践中，作者要介绍用Python在Tkinter上画一棵树的方法。通过本实践，读者可以：练习面向对象的程序设计方法；了解生成器的使用方法；运用递归函数；了解Tkinter画图的基本方法；以及学习“树”这种重要的数据结构。","text":"本实践中，作者要介绍用Python在Tkinter上画一棵树的方法。通过本实践，读者可以：练习面向对象的程序设计方法；了解生成器的使用方法；运用递归函数；了解Tkinter画图的基本方法；以及学习“树”这种重要的数据结构。 版权声明 本文可以在互联网上自由转载，但必须：注明出处(作者：海洋饼干叔叔)并包含指向本页面的链接。 本文不可以以纸质出版为目的进行改编、摘抄。 本文配套在线视频： https://www.bilibili.com/video/av34409478/?p=33 本实践中，作者要介绍用Python在Tkinter上画一棵树的方法。通过本实践，读者可以：练习面向对象的程序设计方法；了解生成器的使用方法；运用递归函数；了解Tkinter画图的基本方法；以及学习“树”这种重要的数据结构。 ​ 在本书配套的网站上，你可以下载到本实践的全部代码。本章要画的图“大概”长成下面这样。为什么说是大概呢？ 因为树的结构是在一定约束条件下随机生成的。 1. 数据结构 - 树​ 要完成本实践，读者首先要了解一点数据结构 - data structure的知识。数据结构大概是指计算机内部表达和组织数据的方式。 1.1 树 ​ 树-Tree是一种数据结构，它用于模拟真实世界中的树形结构，通常描绘成上图的样子。为了说明方便，作者把每个节点用字母作了标识。 ​ T是一棵树，树上的每个圆圈称之为一个节点-node，其中，a是树T的根节点 - root node。节点可以有后代 - descendents，其中，直接的后代称为儿子节点 - child。上图中，b,c,d是节点a的儿子，h,i是节点d的儿子。有儿子的节点称为内节点，没有儿子的节点称为叶子-leaf。上图中，e,f,k等节点没有儿子，作者用粗线圆作了标识，它们是叶子。 ​ T’是树T的一棵子树-sub tree，其根节点为d，我们称树T’是树T中以d节点为根的子树。理论上，任何一个节点其及全部后代都可视为一棵树。 ​ 上树中右侧的数字0,1,2,3表示节点在树中的深度-depth。a节点的深度为0，g,h节点的深度为1，j,k,l节点的深度为3。 1.2 树的递归表示123456789101112class TreeNode: def __init__(self,label): self.sLabel = label self.children = []a = TreeNode('a')b = TreeNode('b')c = TreeNode('c')d = TreeNode('d')a.children.extend([b,c,d])b.children.extend([TreeNode('e'),TreeNode('f')])... ​ 上边的代码展示了一个表示树的Python递归结构。TreeNode类有一个sLabel属性，存储节点的标签。此外，该类还有一个类型为列表的数据成员children，这里面存储该结点的全部儿子节点。而儿子节点的类型也为TreeNode，其也有children列表用于存储该儿子节点的儿子。当一个TreeNode对象的children列表为空时，表明该节点为叶子。 ​ 上述代码的后几行建立了前小节中树结构的一部分。其中a为根节点，a有b,c,d三个儿子，而b又有两个儿子e和f… 2. Top-Left坐标系 ​ 在图形程序设计中，一般采用Top-Left坐标系。如上图，以屏幕或者窗口的左上角为原点，横向为x轴，纵向为y轴。位置越靠右，x越大；位置越靠下，y越大。窗口内的任意一个点，可用一对(x,y)构成，这一对(x,y)值，称为该点的坐标。 3. 实例中的树表达123456789101112131415class Point: def __init__(self, x, y): self.x = x self.y = yclass TreeNode: maxDepth = 8 nBranches = 3 def __init__(self, bottom, top, depth=0): self.bottom = bottom self.top = top self.drawingTop = top self.depth = depth self.children = [] self.__generateDescendents() ​ 如代码所示，Point类有成员x和y，表明一个坐标点。TreeNode类表示一个树节点。类成员maxDepth表示树所允许的最大深度。类成员nBranches表示“建议”的树分叉数，即一根树支将分出多少根下层树支。此处之所以用了“建议”一词，是因为实际树的生成过程中分支数会引入随机成分。 ​ TreeNode对象的children属性是其儿子列表，depth表示该节点在树中的深度。TreeNode对象的另外几个属性需要结合下图来理解，这是作者在树上取下的一个小树支。下图中，a是一个TreeNode节点，其bottom表示以该节点为根的子树的“下”顶点；其top表示以该节点为根的子树的“上”顶点。注意，这里的上下打了引号，那是因为实践中，树支因地球引力，可能事实上倒垂向下。 ​ drawingTop定义为该节点自身（不含其子孙）的描绘用“上”顶点。a节点在树中的实际表现为一段树支，树支的描绘范围即为bottom至drawingTop点。从drawingTop一直到top则是a的子孙们的描绘区域。下图中，b,c,d为a的儿子，b,c,d也是TreeNode类型，其bottom应等于a的drawingTop。 ​ 此外，TreeNode类构造函数的最后一行执行了一个“不公开”成员函数__generateDescendents()，这个函数将递归生成以该节点的根的子树，该子树中节点的深度不超过TreeNode.maxDepth。该部分内容见后节。 变量、函数、类的判定准则 - 新手们写出来的程序通常可读性和健壮性都有问题。作者建议，当读者试图定义一个变量、函数、类时，都必须满足如下规则：如果其作用和取值可以用简洁明了没有歧义的讲清楚，那么其存在可能是合理的。如果说不清道不明，那么读者需要另寻它法。本实践中的，TreeNode之bottom,top,drawingTop，受限于其复杂性，很难用一句话描述，但至少借助于图示，是可以讲清楚的。 - Python之禅里有“If the implementation is easy to explain, it may be a good idea”。这里，请读者品味其含义。 4. 树的递归生成4.1 分叉树支生成12345678910111213141516171819class TreeNode: ... def __generateDescendents(self): \"Recursively build sub-tree of the current node.\" n = random.randint(TreeNode.nBranches//2,round(TreeNode.nBranches*1.5)) n = n if n &gt;=1 else 1 r = 0.20 + random.random() * 0.2 x = self.bottom.x + (self.top.x - self.bottom.x) * r y = self.bottom.y + (self.top.y - self.bottom.y) * r self.drawingTop = Point(x, y) if self.depth &lt; self.maxDepth: a = math.pi * 0.5 / n for i in range(n): angleOffset = a * (n-1) / 2 - a * i + math.pi angleOffset *= (0.9 + random.random() * 0.2) son = self.__bornSon(self.drawingTop, self.top, angleOffset) self.children.append(son) ​ 上述__generateDescendents()函数在节点的构造函数中被调用。从下到下解释该函数。 ​ 首先，函数确定当前树支的分叉数，也就是当前节点的儿子的数量n。可以看到，n随机取值为TreeNode.nBranches的0.5到1.5倍。为了稳妥起见，程序还限定n值至少为1。 ​ 接下来，程序确定当前树支的描绘顶点，即当前节点的drawingTop。drawingTop的确定也引入了随机性，从bottom顶点出发，往top顶点方向，前进总距离的0.2 - 0.4倍，即确定为drawingTop顶点。这里，random.random()返回[0,1)之间的随机浮点数，1之后的)号表明返回值不包含1，这说明，r的取值为0.2 - 0.4(不含)。 ​ 然后，如果当前节点的深度-depth小于约定的最大深度-maxDepth，则生成该节点的n个儿子结点，也就是当前树支的n个分叉。这里的代码比较复杂，涉及了弧度和三角函数的数学知识，简要描述之。如前节所述，当前节点/树支的drawingTop即为儿子节点/分叉的bottom。在当前节点/树支的drawingTop点，沿当前树支的伸展方向，左右各45度，共90度(即 π/2)范围内逐一”均布”生成n个分叉儿子节点。这里的“均布”是大致的，上述代码中的angleOffset被乘以了0.9-1.1的随机数。__bornSon(self.drawingTop, self.top, angleOffset)函数以当前树支的drawingTop为bottom，以“以当前树支为根的子树”的top为top，生成一个分叉儿子结点，分叉的伸展角度为当前树支的伸展角度加上偏移角angleOffset。 一个儿子生成完后，再将其加入到children列表中。 4.2 生成一个儿子123456789101112131415161718class TreeNode: ... def __bornSon(self, bottom, top, angleOffset): \"Born a son of current node, with designated offset angle.\" xWidth = top.x - bottom.x #Width of sub-tree yHeight = top.y - bottom.y #Height of sub-tree angleSubTree = math.atan(yHeight / xWidth) if xWidth !=0 else math.pi/2 if (angleSubTree &lt; 0 and bottom.y &gt; top.y) or \\ (angleSubTree &gt; 0 and bottom.y &lt; top.y): angleSubTree += math.pi angleSon = angleSubTree + angleOffset r = 0.9 + random.random() * 0.2 c = math.sqrt(xWidth ** 2 + yHeight ** 2) * r xOffset = c * math.cos(angleSon) yOffset = c * math.sin(angleSon) topNew = Point(xOffset + bottom.x, yOffset + bottom.y) return TreeNode(bottom, topNew, self.depth + 1) ​ 接上节，该函数需要沿其子树的伸展方向偏转一个偏移角生成一个儿子。 ​ 函数首先通过bottom，top之间的相对位置关系，使用反正切函数计算得到子树的伸展角angleSubTree。请注意，由于反正切函数的局限性(值域为(-π/2, +π/2)，不能表达全部圆周角度），代码不得不再次通过bottom, top的相对关系对angleSubTree进行修正。接下来，子节点的伸展角angleSon等于子树伸展角加上偏移角。 ​ 有了分支子节点的伸展角angleSon，再借助子树的对角线长度c乘以0.9-1.1随机数，使用正余弦函数计算出分支子节点的top - topNew。然后，函数以topNew为“上”顶点构造一个TreeNode对象，子节点的深度为当前节点深度加1。 ​ 需要特别说明的是，__bornSon()函数通过TreeNode构造函数生成一个子结点，而该子结点的构造函数又会执行__generateDescendents()函数生成其后代。所以，只要我们通过TreeNode的构造函数构造一个根节点-root node，该节点的构造函数会执行__generateDescendents()生成其子结点，而子结点的构造又会导致子结点的子结点被生成出来，… ，最终，生成了一棵完整的树。在生成后代的过程中，只有当当前节点的深度小于约定的最大深度时，才会尝试生成后代，因此，递归有恰当的边界条件会导致其终结。这种情况，我们也称递归函数会收敛。 4.3 生成整棵树12345678910111213141516171819202122232425class TreeBuilder: def setPara(bottom,top,nBranches=3,maxDepth=8): TreeBuilder.bottom = bottom TreeBuilder.top = top TreeBuilder.nBranches = nBranches TreeBuilder.maxDepth = maxDepth def buildTree(depthOffset=0): TreeBuilder.maxDepth += depthOffset TreeBuilder.maxDepth = TreeBuilder.maxDepth \\ if TreeBuilder.maxDepth &lt;=10 else 10 TreeBuilder.maxDepth = TreeBuilder.maxDepth \\ if TreeBuilder.maxDepth &gt;=2 else 2 print(\"Build a tree, branches:&#123;&#125;,depth:&#123;&#125;.\". format(TreeBuilder.nBranches,TreeBuilder.maxDepth)) TreeNode.maxDepth = TreeBuilder.maxDepth TreeNode.nBranches = TreeBuilder.nBranches t = TreeNode(TreeBuilder.bottom,TreeBuilder.top) RenderHelper.showTree(t) ... TreeBuilder.setPara(bottom=Point(1024/2,768-20), top=Point(1024/2,768*0.1)) TreeBuilder.buildTree() ​ TreeBuilder是一个所谓的“帮助”类，可以看到其两个函数都没有self参数，都属于类函数的范畴。也就是说，这两个函数的执行不以TreeBuilder类型对象的存在为前提。 ​ 在主程序中，我们首先通过TreeBuilder.setPara()函数设置了将要生成的树的bottom“下”顶点及top“上”顶点，1024和768是窗口的宽度和高度，可以看出，bottom左右居中，距窗口下边缘20个像素；top左右居中，距窗口上边缘10%。建议的树支分叉数nBranches以及树的最大深度maxDepth使用了默认值。 ​ 接下来，主程序调用TreeBuilder.buildTree()函数构造并显示一棵树。这个函数允许通过一个深度偏移量来改变原设定最大深度。在调整完深度并把深度及建议分叉数存入TreeNode.maxDepth和TreeNode.nBranches后，函数简单粗暴地构造了一个TreeNode对象t，这个t即为树的根节点。请注意，由于前小节所述的递归的原因，这个以t为根的树会被完整地生成出来，其深度为TreeNode.maxDepth。 ​ 请读者注意，作者对TreeBuilder.maxDepth进行了限定，不允许其超过10。原因很简单，树的节点的总数量随深度呈指数级增长，超过10的深度的树可能需要非常长的运行时间，甚至可能会超过你的计算机的存储或计算能力。 ​ 在buildTree()函数的最后，执行了RenderHelper.showTree(t)将树显示出来。 5 树的显示5.1 计算机里的颜色表示​ 画家可以仅凭“红”，“绿”，“蓝”调出他所需要的所有颜色，计算机也可以。计算机通常用三个字节来表示一种颜色，从左往右分别表示红、绿、蓝三种颜色成分，取值为0-255，即十六进制的0x00 - 0xff。通过三种颜色成分的不同组合，我们可以得到任意颜色。这种用红-Red，绿-Green，蓝-Blue来组合构成颜色的模型称为RGB模型。 RGB 说明 009000 红为0x00，绿为0x90，蓝为0x00，综合颜色为翠绿 ff0000 红为0ff，绿为0x00，蓝为0x00，综合颜色为红 909000 红为0x90，绿为0x90，蓝为0x00，综合颜色为黄 ffffff 三种颜色均为0xff，综合颜色为白 000000 三种颜色均为0x00，综合颜色为黑 606060 三种颜色均为0x60，综 合颜色介于黑和白之间，是灰色，值越大，灰越浅 ​ 在印刷业，使用的配色方案跟计算机里有所不同，他们使用青-Cyan、品红-Magenta和黄-Yellow来组合构成所有颜色，即所谓减色法，又称CMY模型。 5.2 树的遍历12345678910class TreeNode: ... def bfs(self): #breadth first search nodesQueue = [self] while True: if len(nodesQueue)==0: break x = nodesQueue.pop(0) yield x nodesQueue.extend(x.children) ​ 显示一棵树，即是迭代列举树的全部节点，并将其全部画出来。列举树的全部节点，又称为树的遍历。作者在这里使用了树的宽/广度优先遍历算法。 ​ 为了便于读者理解，作者以上面这棵小树为例，说明宽度优先遍历的过程。对A节点执行bfs()函数，队列nodesQueue初始化为[A]。遍历过程将一直持续到nodesQueue队列为空，即len(nodesQueue)==0为止。 ​ 首先，从队列中弹出A并yield。请注意，这里的bfs()函数被写成了生成器函数，关于生成器函数的工作原理，请参考本书相关章节。这里简单地认为yield x语句将x结点“抛”给使用方即可。 ​ A被yeild后，A的儿子结点被加入nodesQueue - [B,D]。接下来，弹出并yield B，B的儿子结点C被加入nodesQueue - [D,C]。接着，弹出并yield D，D的儿子结点E被加入nodesQueue - [C,E]。接下来，弹出并yield C，C没有儿子，故nodesQueue只剩下一个节点 - [E]。接着，E被弹出并yield，E的儿子F被加入nodesQueue - [F]。最后，F被弹出并yield，F是叶子，没有儿子可以加入nodesQueue，所以nodesQueue为空，全部节点已经成功列举，遍历结束。 ​ 如果列出全部节点的列举顺序，应该是A,B,D,C,E,F,正好是树的结点一层一层的逐层列举。这种列举了某个节点后，立即列举离这个节点最近的全部儿子的遍历方法称为“宽度优先”。与“宽度优先”对应的是“深度优先”，相关内容在数据结构课程中会得到深入研究。 5.2 树的显示1234567891011class RenderHelper: canvas = None def showTree(tree): \"Render a tree on canvas.\" assert RenderHelper.canvas != None, \"Please set canvas first.\" RenderHelper.tree = tree for x in RenderHelper.canvas.find_all(): RenderHelper.canvas.delete(x) for x in tree.bfs(): RenderHelper.__renderNode(x) RenderHelper.canvas.update() ​ 同样地，RenderHelper是一个帮助类，可以在不经实例化的情况下使用其类函数。canvas是主程序设置进来的Tkinter”画布”。showTree(tree)函数负责在canvas上把树“画”出来。 ​ 可以看到，showTree()首先并断言了canvas的可用性。然后，删除了canvas内已有的全部内容。接下后，通过for x in tree.bfs()遍历列举tree的全部节点x，逐一调用__renderNode(x)在画布上“画”出来。 ​ __renderNode(x)所谓的“画”其实只是在canvas的内部数据表达中增加相关元素（比如线、椭圆或其它图形），真正要把画布的内容展示在计算机屏幕上，还需要执行canvas.update()函数。 12345678910111213141516171819class RenderHelper: ... def __renderNode(node): \"Render a TreeNode.\" colorFill = \"#&#123;0:0&gt;2x&#125;&#123;0:0&gt;2x&#125;&#123;0:0&gt;2x&#125;\".\\ format(int(0x60 * node.depth / node.maxDepth)) RenderHelper.__drawLine(node.bottom,node.drawingTop, colorFill=colorFill,width=1.5 ** (node.maxDepth - node.depth)) if not node.children: #draw leaf if it is a leaf red = 0xff * node.drawingTop.y / RenderHelper.tree.drawingTop.y red = int(red * (0.8 + random.random() * 0.4)) red = red if red &lt;= 0xff else 0xff colorFill = \"#&#123;0:0&gt;2x&#125;9000\".format(red) RenderHelper.canvas.create_oval( node.drawingTop.x - 3,node.drawingTop.y - 3, node.drawingTop.x + 3,node.drawingTop.y + 3, fill=colorFill) RenderHelper.canvas.update() #This sentence for contruction show ​ __renderNode(node)函数负责在画布中“画”一个节点。首先，是画这个节点所代表的树支。 12colorFill = \"#&#123;0:0&gt;2x&#125;&#123;0:0&gt;2x&#125;&#123;0:0&gt;2x&#125;\".\\ format(int(0x60 * node.depth / node.maxDepth)) ​ colorFill为形如”#101010”的RGB模型颜色字符串，在这里，R，G，B三个值相等，且跟当前节节的深度有关，深度越浅，说明节点离树根越近，colorFill为取值接近”#000000”，黑色越深。当深度较大时，说明节点离叶子较近，colorFill取值接近”#606060”，黑色较浅，为灰色。 ​ __drawLine()函数从节点的bottom至drawingTop画一条线表示树支，颜色即上述colorFill，而线宽则同样与节点深度有关。深度越浅，树支越接近树根，线宽越宽。 ​ 当节点的儿子列表为空时，说明节点是叶子节点，此时需要画一个实心圆点表示树叶。树叶本来是绿色(取值0x90)的，但作者刚才正好从美丽的重庆大学虎溪校区泛黄的银杏树下走过，决定给树叶加点“红”色。红色成分的多少取决于树叶的描绘高度，越靠近树顶，红色越少，树叶越绿；越靠近地面，红色越多，树叶越黄。上述的colorFill字符串格式化的结果为”#309000”这样的字符串，绿为0x90，红为0x30或者其它值，蓝始终为0x00。注意，红色成分的多少也加入了一些随机因素。 ​ canvas.create_oval()函数在画布上创建一个实心圆树叶，该实心圆以drawingTop为圆心，colorFill为填充色。这个函数本来是画椭圆的，但由于正圆是椭圆的特例，所以也可以用来画正圆。 ​ __renderNode()函数的最后一行为RenderHelper.canvas.update()。update()会在显示器上实际渲染画布的内容，所以该函数执行至少要”花费”一个显示帧的时间。考虑到显示器的刷新频率一般是60Hz，这意味道着，程序每秒钟只能“画”出大约60个节点。所以，如果该行代码存在，你可以在计算机上看到树被一点点的画出来，并且还可以根据树支、叶片在界面上出现的先后顺序来理解树的“深度优先遍历”算法。读者可以删除该行代码，再运行试一试。 12345678910111213141516171819202122232425class RenderHelper: ... def __drawLine(pt0, pt1, width, colorFill, minDist=10): dots = RenderHelper.__generateDotsSequence(pt0,pt1,minDist) RenderHelper.canvas.create_line(dots,fill=colorFill,width=width, smooth=True) def __generateDotsSequence(pt0,pt1,minDist): dots = [] dx, dy = pt1.x - pt0.x, pt1.y - pt0.y c = math.sqrt(dx ** 2 + dy ** 2) n = int(c / minDist) + 1 xPrev,yPrev = pt0.x,pt0.y for i in range(n): xOffset = dx * i / n yOffset = dy * i / n if i &gt; 0: xOffset += minDist * (0.5 - random.random()) * 0.25 yOffset += minDist * (0.5 - random.random()) * 0.25 x,y = pt0.x + xOffset,pt0.y + yOffset dots.extend([xPrev,yPrev,x,y]) xPrev,yPrev = x,y dots.extend([xPrev,yPrev,pt1.x,pt1.y]) return dots ​ __drawLine()函数负责从pt0 - bottom到pt1 - drawingTop画一条宽度为width，颜色为colorFill的实心线来表示一条树支。 ​ 但现实中的树，树支不可以是完全直的。所以，借助__generateDotsSequence()函数，作者以minDist=10为间距，将树支分成多个小段，并加入一些随机因素。最后，再用canvas.create_line()将多点线画出来，尽可能模仿现实世界中树支的模样。 6 Tkinter循环123456789101112131415tk = tkinter.Tk()tk.title(\"Build Tree\")canvas = tkinter.Canvas(tk,width=1024,height=768,bg=\"#ffffff\")canvas.pack()RenderHelper.canvas = canvasTreeBuilder.setPara(bottom=Point(1024/2,768-20), top=Point(1024/2,768*0.1))TreeBuilder.buildTree()tk.bind(\"n\", lambda evt: TreeBuilder.buildTree())tk.bind(\"=\", lambda evt: TreeBuilder.buildTree(depthOffset=1))tk.bind(\"+\", lambda evt: TreeBuilder.buildTree(depthOffset=1))tk.bind(\"-\", lambda evt: TreeBuilder.buildTree(depthOffset=-1))tk.mainloop() ​ 主程序中，我们创建了一个tkinter对象，并生成了长1024，宽768，背景色为白色的画布 - canvas。然后，建造并显示了一棵树。 ​ 接下来，我们对程序创建了几个快捷键，程序运行中，当你按下n时，TreeBuilder.buildTree()会被执行，这将建造并显示一棵新树。按下+或者=时，TreeBuilder.buildTree(depthOffset=1)会被执行，系统会尝试将树的深度加1并建造和显示一棵新树。按下-时，TreeBuilder.buildTree(depthOffset=-1)，系统会尝试将树的深度减1并建并建造和显示一棵新树。 ​ 此处的lambda表示匿名函数，它将带有实参的TreeBuilder.buildTree(depthOffset=1)封装成一个没有名字的函数。 ​ tk.mainloop()将执行所谓的消息循环，在里面，Tkinter将不断地循环等待来自用户的命令并执行，直到用户关闭Tkinter窗口。 7 小结​ 本实践的主要用意在于帮助读者掌握和运用面向对象的程序设计方法，以及递归的算法、树的数据结构表示方法等。Tkinter库的使用不是重点。作为Python自带的标准GUI工具包，Tkinter库在小型应用中仍有一席之地，但当应用的规模略大时，作者认为不太方便。在本书中，作者将着重介绍另一种更强大的GUI工具包，那就是PyQt。","categories":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/categories/Python/"},{"name":"数学之美","slug":"Python/数学之美","permalink":"http://codelearn.club/categories/Python/%E6%95%B0%E5%AD%A6%E4%B9%8B%E7%BE%8E/"},{"name":"分形","slug":"Python/分形","permalink":"http://codelearn.club/categories/Python/%E5%88%86%E5%BD%A2/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://codelearn.club/tags/Python/"},{"name":"分形数学","slug":"分形数学","permalink":"http://codelearn.club/tags/%E5%88%86%E5%BD%A2%E6%95%B0%E5%AD%A6/"},{"name":"递归","slug":"递归","permalink":"http://codelearn.club/tags/%E9%80%92%E5%BD%92/"},{"name":"树","slug":"树","permalink":"http://codelearn.club/tags/%E6%A0%91/"},{"name":"Tkinter","slug":"Tkinter","permalink":"http://codelearn.club/tags/Tkinter/"}]}]}